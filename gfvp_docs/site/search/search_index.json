{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"GFVP - Green Fuel Validation Platform \u00b6 ## Solo Developer: Haradhan Sharma Email: haradhan.sharma@gmail.com Website: [hrdnsh.com](http://hrdnsh.com) Table of Contents \u00b6 Project Overview Project Structure Technology Stack Contributors Installation Usage Documentation License Project Overview \u00b6 GFVP (Green Fuel Validation Platform) is a web application built using Django 4.0.1 and various frontend technologies. It serves as a platform for validating and managing green fuel-related data. The application allows different types of users to interact with the system, and it's designed to support various features for managing data related to green fuels. Project Structure \u00b6 The project follows a well-organized directory structure: root/ accounts -> app blog -> app crm -> app doc -> app evaluation -> app feedback -> app gfvp -> project gfvp_docs -> mkdocs directory glossary -> app guide -> app home -> app navigation -> app logs static -> static folder upload -> media folder templates -> templates for apps and project .env .gitignore gfvp.dot gfvp.png ->database schema manage.py ->project manager mkdocs.yml ->mkdocs configuration requirements.txt robots.txt Ensure that the necessary Python packages specified in requirements.txt are installed for the project to run successfully. Technology Stack \u00b6 Python 3.10 Django 4.0.1 ReportLab Panda Numpy xhtml2pdf Material Admin Bootstrap 5 with Volt theme Chartist.js AOS.js HTMX jQuery Font Awesome Youtube API IPinfo API Contributors \u00b6 1. Business logic and instructions provided by: 1. Krishna Hara Chakrabarti 2. Jessica Hofman 2. Contributed to user guide 1. Pragya Chudal Installation \u00b6 Clone the repository to your local machine. git clone <repository_url> Create a virtual environment (optional but recommended). python -m venv venv Activate the virtual environment. // On Windows venv\\Scripts\\activate // On macOS and Linux source venv/bin/activate Install the required dependencies. pip install -r requirements.txt Create a .env file in the project root and configure any environment-specific settings. Apply database migrations. python manage.py migrate Start the development server. python manage.py runserver The application should now be accessible at http://localhost:8000/. Usage \u00b6 Genarate .dot file and database schema First, make sure you have django-extensions installed. If it's not already in your requirements.txt , you can add it: django-extensions==3.2.1 Then, run the following command to generate a graph_models.dot file: python manage.py graph_models -a -o gfvp.dot To generate a PNG image from the .dot file, you can use Graphviz. If you don't have Graphviz installed, you can add it to your requirements.txt : graphviz==0.17 After installing Graphviz, you can use the dot command to convert the .dot file to a PNG image: dot -Tpng gfvp.dot -o gfvp.png Mkdocs Commands \u00b6 Configure mkdocs.yml . Add xxxx.md in gfvp_docs/docs run mkdocs build command to build the documentation site. mkdocs -h - Print help message and exit. Documentation \u00b6 Documentation for each app can be found in their respective readme.md files: Accounts App Blog App CRM App Doc App Evaluation App Feedback App GFVP Project Glossary App Guide App Home App Navigation App Additional documentation for the project can be found in the code comments. License \u00b6 Copyright \u00a9 2023 Haradhan Sharma This project is licensed under the MIT License - see the LICENSE file for details.","title":"Home"},{"location":"index.html#gfvp_-_green_fuel_validation_platform","text":"## Solo Developer: Haradhan Sharma Email: haradhan.sharma@gmail.com Website: [hrdnsh.com](http://hrdnsh.com)","title":"GFVP - Green Fuel Validation Platform"},{"location":"index.html#table_of_contents","text":"Project Overview Project Structure Technology Stack Contributors Installation Usage Documentation License","title":"Table of Contents"},{"location":"index.html#project_overview","text":"GFVP (Green Fuel Validation Platform) is a web application built using Django 4.0.1 and various frontend technologies. It serves as a platform for validating and managing green fuel-related data. The application allows different types of users to interact with the system, and it's designed to support various features for managing data related to green fuels.","title":"Project Overview"},{"location":"index.html#project_structure","text":"The project follows a well-organized directory structure: root/ accounts -> app blog -> app crm -> app doc -> app evaluation -> app feedback -> app gfvp -> project gfvp_docs -> mkdocs directory glossary -> app guide -> app home -> app navigation -> app logs static -> static folder upload -> media folder templates -> templates for apps and project .env .gitignore gfvp.dot gfvp.png ->database schema manage.py ->project manager mkdocs.yml ->mkdocs configuration requirements.txt robots.txt Ensure that the necessary Python packages specified in requirements.txt are installed for the project to run successfully.","title":"Project Structure"},{"location":"index.html#technology_stack","text":"Python 3.10 Django 4.0.1 ReportLab Panda Numpy xhtml2pdf Material Admin Bootstrap 5 with Volt theme Chartist.js AOS.js HTMX jQuery Font Awesome Youtube API IPinfo API","title":"Technology Stack"},{"location":"index.html#contributors","text":"1. Business logic and instructions provided by: 1. Krishna Hara Chakrabarti 2. Jessica Hofman 2. Contributed to user guide 1. Pragya Chudal","title":"Contributors"},{"location":"index.html#installation","text":"Clone the repository to your local machine. git clone <repository_url> Create a virtual environment (optional but recommended). python -m venv venv Activate the virtual environment. // On Windows venv\\Scripts\\activate // On macOS and Linux source venv/bin/activate Install the required dependencies. pip install -r requirements.txt Create a .env file in the project root and configure any environment-specific settings. Apply database migrations. python manage.py migrate Start the development server. python manage.py runserver The application should now be accessible at http://localhost:8000/.","title":"Installation"},{"location":"index.html#usage","text":"Genarate .dot file and database schema First, make sure you have django-extensions installed. If it's not already in your requirements.txt , you can add it: django-extensions==3.2.1 Then, run the following command to generate a graph_models.dot file: python manage.py graph_models -a -o gfvp.dot To generate a PNG image from the .dot file, you can use Graphviz. If you don't have Graphviz installed, you can add it to your requirements.txt : graphviz==0.17 After installing Graphviz, you can use the dot command to convert the .dot file to a PNG image: dot -Tpng gfvp.dot -o gfvp.png","title":"Usage"},{"location":"index.html#mkdocs_commands","text":"Configure mkdocs.yml . Add xxxx.md in gfvp_docs/docs run mkdocs build command to build the documentation site. mkdocs -h - Print help message and exit.","title":"Mkdocs Commands"},{"location":"index.html#documentation","text":"Documentation for each app can be found in their respective readme.md files: Accounts App Blog App CRM App Doc App Evaluation App Feedback App GFVP Project Glossary App Guide App Home App Navigation App Additional documentation for the project can be found in the code comments.","title":"Documentation"},{"location":"index.html#license","text":"Copyright \u00a9 2023 Haradhan Sharma This project is licensed under the MIT License - see the LICENSE file for details.","title":"License"},{"location":"accounts.html","text":"Custom Django Admin Configuration for Accounts App \u00b6 This apps contains a custom Django admin configuration for managing user accounts and related models in an application. The admin configuration enhances the default Django admin interface by adding custom actions, custom fields, and filtering options. Overview \u00b6 The provided code extends the Django admin interface to manage user accounts, user profiles, and other related models. It includes custom actions for activating and deactivating user accounts, as well as sending emails to specific user groups. The customizations are designed to provide a more efficient way of managing users within the Django admin dashboard. Setup \u00b6 To use this custom admin configuration in your Django project, follow these steps: Copy the provided code to your Django project's admin.py file or a dedicated admin.py file within your app. Make sure you have the required models, forms, and templates as referenced in the code. Register the required models using the admin.site.register() function. Customize the custom actions, filters, and other admin settings to match your project's requirements. Run your Django development server and navigate to the admin dashboard to see the changes. Features \u00b6 Customized user list view with additional fields such as user type, expertise, phone number, and email verification status. Filtering users based on user type, activity status, staff status, expertise, and email verification status. Searching for users based on email, phone, organization, username, expertise, and email verification status. Inline editing of user profiles within the user admin page. Ordering users by their date of joining. Custom actions for activating and deactivating user accounts. Custom action for sending emails to selected marine experts for feedback updates. Management of user types with customizable display fields and filtering options. Custom Actions \u00b6 Activate Account and Send Mail \u00b6 This action allows admin users to activate selected user accounts and send activation emails to the users. Admins can select multiple users and trigger the action to activate their accounts. Deactivate Account \u00b6 This action enables admin users to deactivate selected user accounts. Similar to the previous action, admin users can select multiple users and deactivate their accounts. Send Mail to Expert \u00b6 Admin users can use this action to send courtesy emails to selected marine experts for feedback updates. The action is restricted to marine experts only. An email template is used for composing the emails. UserType Management \u00b6 The custom admin configuration also provides enhanced management for user types: Displaying user type fields in the admin list view. Filtering user types based on their names. Searching for user types using their names. Automatically populating the slug field based on the name field. Optimized Django User Type Decorators \u00b6 Overview \u00b6 This repository provides optimized decorators for controlling access to Django views based on user types, as well as a decorator for report creator access control. These decorators simplify the process of restricting access to specific user types or report creators, enhancing the security and usability of your Django application. Installation \u00b6 Copy the provided optimized decorators code to a suitable location within your Django project, such as a utility module. Import the decorators wherever you need to control access based on user types or report creator permissions. Usage \u00b6 Import the required decorators in your views or viewsets: .. code-block:: python from your_project.utils.decorators import expert_required, producer_required, consumer_required, marine_required, report_creator_required Apply the decorators to your views or viewsets where access control is needed: .. code-block:: python @expert_required def expert_view(request, ...): # Your view logic here ... @report_creator_required def report_edit_view(request, slug, ...): # Your view logic here ... User Type Decorators \u00b6 The following user type decorators are available: expert_required : Requires the user to be an expert, staff member, or superuser. producer_required : Requires the user to be a producer, staff member, or superuser. consumer_required : Requires the user to be a consumer, staff member, or superuser. marine_required : Requires the user to be a marine user, staff member, or superuser. Report Creator Decorator \u00b6 The report_creator_required decorator restricts access to views based on the report creator or staff/superuser. This is particularly useful for views related to report editing or management. Custom UserCreationForm for Admin \u00b6 The UserCreationForm class provided in this app is a customized version of Django's default UserCreationForm . It extends the functionality of the default form to include additional fields and customization options. Usage \u00b6 The UserCreationForm can be used for creating new user accounts with extended fields. It adds the following features: Additional fields: The form includes custom fields such as usertype , experts_in , and term_agree . Customized appearance: The form's appearance on the admin page is customized using the UserAdmin.add_fieldsets attribute. Compatibility with UserAdmin: The form is compatible with the Django UserAdmin interface. Customization \u00b6 The UserCreationForm is designed to enhance the default user registration process. It inherits from Django's UserCreationForm and extends its functionality: The __init__ method initializes the form instance. The UserAdmin.add_form is set to use the Django's default UserCreationForm . The UserAdmin.add_fieldsets are updated to include the additional fields and customize the appearance. To use this form in your project, simply import it and use it for user registration with the extended fields. .. code-block:: python from django.contrib.auth.forms import UserCreationForm as UserCreationFormDjango from .forms import UserCreationForm # Import the custom form from django.contrib.auth.admin import UserAdmin # Set the UserAdmin's add_form to use the custom UserCreationForm UserAdmin.add_form = UserCreationFormDjango UserCreationFormFront for user registration \u00b6 The UserCreationFormFront class is a custom user creation form specifically designed for the frontend registration page of your Django project's account app. This form extends the UserCreationFormDjango class. Usage \u00b6 This form includes various custom fields with HTML attributes to enhance user experience during registration. It also implements validations for username, email, and other fields. Additionally, it integrates with Google reCAPTCHA for added security. Custom Fields \u00b6 username : A field for the username with a placeholder and real-time username availability check using AJAX. email : An email field with a placeholder and real-time email availability check using AJAX. password1 : A password field for the user's password. password2 : A field to confirm the password. term_agree : A checkbox for agreeing to terms and conditions. newsletter_subscription : A checkbox to subscribe to the newsletter. Custom Widgets \u00b6 The form uses various custom widgets for improved user interactions: usertype : A dropdown widget for selecting the user type with AJAX-based data loading. experts_in : A dropdown widget for selecting areas of expertise. orgonization : A text input widget for the user's organization. is_public : A checkbox widget for specifying whether the user's profile is public. Validation and Email Verification \u00b6 The UserCreationFormFront class contains methods for custom field validation: clean_username() : Validates the username to disallow spaces. clean_experts_in() : Validates the experts_in field based on the user type. clean() : Implements a custom clean method for handling various validations and email verifications during registration. Email Verification Flow \u00b6 The form handles email verification during registration: If the provided email is not registered, the user can proceed with registration. If the email is already registered but not verified, a verification email is sent to the user for confirmation. If the email is verified but the account is not activated, the user receives a courtesy email and a message regarding activation status. Please note that this README provides a summary of the UserCreationFormFront class and its functionalities. For detailed implementation and integration instructions, refer to the associated source code and documentation within your Django project's account app. Custom UserChangeForm for Self-Account Data Editing \u00b6 Introduction \u00b6 The UserChangeForm Class ~~~~~~~~~~~~~~~~~~~~~~~~~~ The UserChangeForm class provided in this module is a custom form derived from Django's UserChangeForm . Its purpose is to extend the functionality of the default form to allow users to edit their own account data. This form is primarily used within the settings and password change sections of the dashboard. Usage \u00b6 To make use of the UserChangeForm , adhere to the following steps: Import the form into your views or forms module: .. code-block:: python from path.to.UserChangeForm import UserChangeForm In your view or form class, create an instance of the UserChangeForm : .. code-block:: python user_change_form = UserChangeForm(instance=request.user) Render the form within your template: .. code-block:: html <form method=\"post\"> {% csrf_token %} {{ user_change_form.as_p }} <button type=\"submit\">Save Changes</button> </form> Fields and Widgets \u00b6 The UserChangeForm inherits the fields and widgets of the default UserChangeForm provided by Django. However, this implementation extends these fields with additional customization, specifically: Email: The email field is tailored to use the forms.EmailInput widget. This results in an email input field that has the form-control class and an aria-label attribute, thereby enhancing accessibility. .. code-block:: python widgets = { 'email': forms.EmailInput(attrs={'class': 'form-control', 'aria-label': 'email'}), } Meta Class \u00b6 The Meta class within the UserChangeForm specifies the model to be utilized and the fields to be included in the form. In this case, the form is configured to operate with the user model returned by get_user_model() and encompasses all fields. .. code-block:: python class Meta: model = get_user_model() fields = '__all__' LoginForm Class in Account App \u00b6 Overview \u00b6 The LoginForm class is a custom login form designed for the Django project's account app. This form extends the default AuthenticationForm provided by Django, adding additional fields, custom validations, and integrating reCAPTCHA for enhanced security. Features \u00b6 Customized Fields: The LoginForm customizes the default Django form fields, adding HTML attributes to improve user experience. The username and password fields are styled using the form-control CSS class. Remember Me Option: A \"Remember Me\" checkbox allows users to choose whether to remember their login for 30 days, as per the site settings. This feature enhances user convenience. reCAPTCHA Integration: The form includes a Google reCAPTCHA field to prevent automated bot submissions. The reCAPTCHA is displayed as a checkbox for user interaction. Additional Details \u00b6 Meta Class: The Meta class within the LoginForm specifies the model and fields used in the form. The fields included in the form are username , password , and remember_me . Custom Validation: The clean method of the LoginForm class implements custom validation and checks. It ensures that the reCAPTCHA is completed and verifies the provided email and password. If the reCAPTCHA is not completed, a validation error is raised, requiring the user to complete the CAPTCHA. If the provided email and password are valid, the form checks if the email exists in the system. If the email does not exist, an error message is displayed. If the email exists but is not verified, the user is sent an email verification link for verification. A warning message is also displayed to the user. If the email is verified but not activated, different actions are taken based on the user's type (expert, marine, etc.). For certain user types, the user is notified that their account is awaiting approval. For others, an activation email is resent. If the email is verified and activated, the user is authenticated using their email and password. If the authentication fails, an error message is shown. Usage \u00b6 To utilize the LoginForm class, follow these steps: Import the LoginForm class into the appropriate module: .. code-block:: python from account.forms import LoginForm Use the LoginForm class in your views, passing it to your template context for rendering: .. code-block:: python def login_view(request): # ... form = LoginForm(request, ...) # ... Render the form in your template using Django template tags: .. code-block:: html {% csrf_token %} {{ form.as_p }} Login Notes \u00b6 Ensure that the necessary Django imports and configurations are set up before using the LoginForm class. Modify the form template as needed to match your project's styling and design. The form relies on reCAPTCHA. Make sure to set up reCAPTCHA keys in your project settings for the CAPTCHA field to function properly. For further assistance or customization, refer to the Django documentation and comments within the code. Helper of Accounts APP \u00b6 This is a brief description of the My App project. Custom Username Validator \u00b6 .. code-block:: python class CustomsernameValidator(UnicodeUsernameValidator, ASCIIUsernameValidator): \"\"\" Custom username validator that allows only letters, numbers, and periods. \"\"\" ... Permission Check Function \u00b6 The following function is abandoned and not currently in use: .. code-block:: python def check_type(request, slug): \"\"\" Checks if the current user has the permission to access the requested resource. Args: request (django.http.HttpRequest): The HTTP request object. slug (str): The slug of the user type. Raises: PermissionDenied: If the current user does not have the permission to access the requested resource. \"\"\" ... Email Function \u00b6 The following function sends an email to all admins: .. code-block:: python def send_admin_mail(subject, message): \"\"\" Sends an email to all admins. Args: subject (str): The email subject. message (str): The email message. \"\"\" ... Automatic Profile Creation \u00b6 The accounts app includes a signal that automatically creates or updates user profiles whenever a new user is registered or an existing user is saved. This functionality is achieved through the use of Django signals. Whenever a User instance is created, the signal is triggered, and the create_or_update_user_profile function is called. This function checks if the user is newly created or being updated and accordingly creates a new profile or updates the existing one. Usage \u00b6 To use this automatic profile creation feature in your Django project, follow these steps: Make sure the accounts app is installed in your project and properly configured. In your accounts app, create a file named signals.py if it doesn't already exist. Add the following code to your signals.py file: .. code-block:: python @receiver(post_save, sender=User) def create_or_update_user_profile(sender, instance, created, **kwargs): ... In the above code, make sure to replace 'models' with the correct import path to your Profile model if it's in a different module or app. In your project's settings.py file, add the 'accounts.signals' module to the INSTALLED_APPS list to ensure that the signal is properly connected. You can uncomment the post_save.connect(create_or_update_user_profile, sender=User) line in the signals.py file or connect the signal in your preferred way. With these steps completed, your project will automatically create or update user profiles whenever a new user is registered or an existing user is saved. Remember to run your project's migrations after making these changes to ensure that the database schema is updated accordingly. Automatic Notification Settings Creation \u00b6 The accounts app includes a signal that automatically creates or updates notification settings associated with a user whenever a new user is registered or an existing user is saved. This functionality is achieved through the use of Django signals. Whenever a User instance is created or updated, the signal is triggered, and the create_or_update_notification_settings function is called. This function checks if the user is newly created or being updated and accordingly creates a new notification setting or updates the existing one. Usage \u00b6 To use this automatic notification settings creation feature in your Django project, follow these steps: Make sure the accounts app is installed in your project and properly configured. In your accounts app, create a file named signals.py if it doesn't already exist. Add the following code to your signals.py file: ```python from django.db.models.signals import post_save from django.dispatch import receiver from .models import User, NotificationSettings @receiver(post_save, sender=User) def create_or_update_notification_settings(sender, instance, created, **kwargs): \"\"\" Creates or updates a notification setting associated with the User model. As it has been created after an existing user, we are checking for creating notification if it doesn't exist to avoid errors. Args: sender (Model): The model class that sent the signal (User in this case). instance (User): The specific instance of the User model that was saved. created (bool): Indicates whether a new instance was created or an existing one was saved. **kwargs: Additional keyword arguments passed along with the signal. Returns: None \"\"\" try: notification_settings = instance.notificationsettings # Attempt to access the related NotificationSettings except NotificationSettings.DoesNotExist: notification_settings = None if created or notification_settings is None: # Create a notification settings or update the existing one notification_settings, created = NotificationSettings.objects.get_or_create(user=instance) # Now, make sure that the instance.notificationsettings is set properly if instance.pk != notification_settings.pk: instance.notificationsettings = notification_settings instance.save() Account Activation Token Generator \u00b6 Accounts app includes a custom token generator, AccountActivationTokenGenerator , which is used to generate tokens for email validation during user signup. This token generator extends Django's built-in PasswordResetTokenGenerator to add activation-related information. Usage \u00b6 To use the AccountActivationTokenGenerator for email validation during user signup, follow these steps: Make sure the accounts app is installed in your project and properly configured. In your project's settings.py file, ensure that the 'accounts' app is included in the INSTALLED_APPS list. In your accounts app, create a file named tokens.py if it doesn't already exist. Add the following code to your tokens.py file: .. code-block:: python class AccountActivationTokenGenerator(PasswordResetTokenGenerator): def _make_hash_value(self, user, timestamp): ... account_activation_token = AccountActivationTokenGenerator() In the above code, AccountActivationTokenGenerator extends Django's PasswordResetTokenGenerator and includes custom logic for generating tokens with user activation information. The account_activation_token instance of the AccountActivationTokenGenerator class can be used to generate tokens for user email validation during signup. URL Configuration \u00b6 Here's an overview of the URL patterns defined in the urls.py file of the accounts app: User Signup: URL: /signup/ View: views.signup Description: The endpoint for user registration. Renders the signup form and handles form submission. User Login: URL: /login/ View: views.CustomLoginView Description: The endpoint for user login. Uses a custom login view to manage authentication and redirection. User Profile: URL: /my-profile/ View: views.userpage Description: The endpoint for the user's profile page. Displays the user's profile information and related details. User Activation: URL: /activate/<uidb64>/<token>/ View: views.activate Description: The endpoint for user account activation via token. Activates a user's account using the provided token. Check Username Availability: URL: /check-username/ View: views.check_username Description: Endpoint to check the availability of a chosen username during registration. Check Email Availability: URL: /check-email/ View: views.check_email Description: Endpoint to check the availability of a chosen email address during registration. Commit User Service: URL: /<str:user_id>/<str:na_id>/commit-service/ View: views.commit_service Description: Endpoint to commit a service associated with a user's profile. Delete User Service: URL: /<str:user_id>/<str:na_id>/delete-service/ View: views.delete_service Description: Endpoint to delete a service associated with a user's profile. Custom Login View \u00b6 .. note:: This section describes the custom login view implemented in this project. The project includes a custom login view called ``CustomLoginView``, which is built upon Django's built-in ``LoginView`` class. This custom view allows for fine-grained control over the login process and introduces additional features. Features \u00b6 Uses a custom login form ( LoginForm ) to collect user credentials. Sets a custom URL for redirection after a successful login. Handles the 'remember me' functionality to control session duration. Usage \u00b6 To use the custom login view in your project, follow these steps: Ensure that you have the necessary prerequisites and Django set up. Copy the CustomLoginView class from the provided source code. Import the necessary modules and classes in your project, including the custom form ( LoginForm ). Example Usage \u00b6 Below is an example of how you might use the CustomLoginView in your Django project's views.py : .. code-block:: python from django.urls import reverse_lazy from custom_login_app.forms import LoginForm # Import the custom LoginForm from custom_login_app.views import CustomLoginView # Import the CustomLoginView class MyCustomLoginView(CustomLoginView): form_class = LoginForm # Use the custom LoginForm next_page = reverse_lazy('accounts:user_link') # Set a custom redirection URL Context Data \u00b6 The custom login view also provides additional context data to enhance the rendering of the login page. This includes meta information such as title, description, tags, and robots. Signup View \u00b6 The signup view function is responsible for handling user signup and registration. It provides a user-friendly interface for users to create accounts on the website. The view supports various user types and expert subtypes. .. code-block:: python def signup(request): \"\"\" View function for user signup. This view handles the signup procedure for different user types and experts' subtypes. The process involves segregating users based on their selected user type or expert subtype. Users who have already selected a user type during their session are directed to the signup form. If anyone attempts to signup without selecting a user type, they are redirected to choose one. Expert users only need to select the \"Expert\" user type during signup. :param request: The HTTP request object. :type request: HttpRequest :return: The rendered signup page or redirection to appropriate pages. :rtype: HttpResponse \"\"\" Features \u00b6 User Type Segregation: Users are directed to select their user type or expert subtype before proceeding with registration. This segregation ensures accurate registration and user role assignment. Email Confirmation: After submitting the signup form, users receive an email confirmation containing an activation link. This link is used to verify the user's email address and complete the registration process. Interactive Frontend: The frontend of the signup page is interactive, guiding users through the registration process. The form is pre-filled with default values, ensuring a seamless user experience. Installation \u00b6 Install the required Python packages using pip: .. code-block:: bash pip install -r requirements.txt Add the account app to your Django project's settings: .. code-block:: python INSTALLED_APPS = [ # ... 'account', # ... ] Include the app's URLs in your project's URL configuration: .. code-block:: python from django.urls import path from account.views import signup urlpatterns = [ # ... path('signup/', signup, name='signup'), # ... ] Activate User Account \u00b6 The accounts app provides functionality for user account activation and related actions after the signup process. The activate function in this app is responsible for activating a user's account using the provided activation link. The following actions are performed during the activation process: Preparation of data for the site. Verification of the activation URL and decoding of the user ID. If the activation link is valid, the user's account is marked as email verified. a. If the user is an expert or marine, the account is activated manually by the site admin, and the user is notified to wait for approval. b. If the user is not an expert, the account is activated automatically, and an account activation email is sent. User data is saved, considering different approval policies based on user type. Creating Lead \u00b6 After the activation process, the app performs the following actions: Retrieves location information from the HTTP request. Creates a lead using the user's full name, email address, city, and country information. Creating Newsletter Subscription \u00b6 The app also handles newsletter subscriptions: If the user has opted to receive the newsletter during signup, the app checks whether the user's email already exists in the CRM. If the email exists, the subscription status is updated to True . If the email does not exist, a new lead is created with the user's information, and the subscription status is set to True . Usage \u00b6 To use the activate function, pass the required arguments: request (HttpRequest): The HTTP request object. uidb64 (str): The base64-encoded user ID. token (str): The activation token. The function will redirect to appropriate views based on the activation result. Make sure to configure your project's URLs and templates accordingly to handle the activation process and related notifications. Note: This readme provides a summary of the activate function's functionality. Please refer to the source code for complete implementation details. User Profile Page View \u00b6 This Django view function displays a user's profile page, providing information about their reports and activities. Usage \u00b6 Decorator Usage: This view function is decorated with @login_required to ensure that only authenticated users can access it. Input: request (HttpRequest): The HTTP request object sent by the client. Output: HttpResponse : The rendered user profile page with relevant user data. Functionality \u00b6 When a user accesses their profile page, the following steps are performed: Clear the session data to ensure a clean state when the user logs in. Retrieve the user from the request. Check if a report slug is provided in the query parameters. If so, attempt to retrieve the corresponding report. If no report slug is provided, retrieve the most recent report created by the user. If a report is found, generate label-wise data from the report. Calculate statistics based on the label data: ans_ques : Total answered questions dont_know_ans : Number of questions not answered pos_ans : Total positive answers positive_percent : Percentage of positive answers dont_know_percent : Percentage of unanswered questions Retrieve the first parent question for the evaluation. If not found, display an error message. Get all reports with the last answer related to the first parent question. Paginate the reports for display. Construct a URL for a button linked to the last report. Prepare the context for rendering the user profile page. If no reports are found for the user: Display links to various sections that users can explore. Meta data is prepared for the page, including title, description, tags, and image. The context is updated with the prepared meta data. Finally, the view renders the user profile page with the provided context. Documentation \u00b6 The function is documented using docstrings, explaining its purpose, inputs, and outputs. Comments within the code provide additional explanations about specific code sections and their functionality. Various sections of the code are explained in detail to provide better understanding. Comments and explanations are provided for context variables and calculations. Usage Recommendations \u00b6 This view function should be used within a Django application where user profiles and reports are managed. Developers should ensure that the required models and utilities are imported and configured properly before using this function. To maintain security, ensure that the @login_required decorator is applied to this view function to restrict access to authenticated users only. Developers can modify the context variables and calculations to customize the content and presentation of the user profile page as per their project requirements. Note \u00b6 This documentation is provided as an explanatory guide and may need to be adapted based on the specific use case and context of the project. Username Check Function \u00b6 Check the availability and validity of a username in a signup form. This function takes a POST request containing a 'username' parameter and checks if the provided username is valid and available for registration. Function Signature \u00b6 .. code-block:: python def check_username(request): \"\"\" Check the availability and validity of a username in a signup form. Args: request (HttpRequest): A POST request containing the 'username' parameter. Returns: HttpResponse: A response indicating whether the username is valid and available. - If the username contains spaces, returns a danger message. - If the username already exists in the User model, returns a danger message. - If the username is valid and available, returns a success message. \"\"\" Function Parameters \u00b6 request (HttpRequest): A POST request containing the 'username' parameter. Function Behavior \u00b6 Retrieve the username from the POST request. Check for spaces in the username. If spaces are found, return a danger message. Check if the username already exists in the User model. If the username already exists, return a danger message. If the username is valid and available, return a success message. Usage Example \u00b6 .. code-block:: python from django.http import HttpRequest, HttpResponse from myapp.models import User # Replace with actual import def check_username(request): # Your implementation here check_email View Function \u00b6 Checks the validity and availability of an email address provided in a sign-up form. This function takes a POST request containing an email address from a sign-up form and performs the following checks: Validates the email format using Django's django.core.validators.validate_email function. Checks if the email address already exists in the User model. If the email is valid and not already taken, it returns a success message. If the email is invalid, already taken, or an exception occurs during validation, it returns an appropriate error message. :param HttpRequest request: The HTTP request containing the email in the POST data. :return: A response indicating the validity and availability of the email. :rtype: HttpResponse :raises: None Example:: from django.core.validators import validate_email email = request.POST.get('email') try: validate_email(email) if User.objects.filter(email=email).exists(): return HttpResponse('<span class=\"text-danger\">This email already exists!</span>') else: return HttpResponse('<span class=\"text-success\">This email available!</span>') except: return HttpResponse('<span class=\"text-danger\">Type a valid email address!</span>') partner_service View Function \u00b6 .. code-block:: python @login_required @cache_control(no_cache=True, must_revalidate=True, no_store=True) def partner_service(request, pk): \"\"\" Display the personalized service page for a partner user. This view displays the personalized service page for a visiting partner user. It retrieves the necessary information such as next activities and selected activities to be displayed on the page. It also handles visibility permissions based on the user's role (expert, staff, superuser). Additionally, it generates meta data for SEO purposes. Args: request (HttpRequest): The HTTP request object. pk (int): The primary key of the visiting user. Returns: HttpResponse: Rendered HTML template displaying the service page. \"\"\" # To avoid circular reference from evaluation.models import NextActivities Description \u00b6 The partner_service view function is responsible for displaying a personalized service page for visiting partner users. It retrieves essential information such as next activities and selected activities to be shown on the page. This view also handles visibility permissions based on the user's role (expert, staff, superuser) and generates metadata for SEO purposes. Parameters \u00b6 request (HttpRequest): The HTTP request object. pk (int): The primary key of the visiting user. Returns \u00b6 HttpResponse: Rendered HTML template displaying the service page. Functionality \u00b6 Retrieves the visiting user based on the provided primary key. Retrieves the currently logged-in user. Retrieves all next activities with prefetch for related 'quotnextactivity'. Gets the selected activities of the visiting user. Notifies the admin if there are no next activities and the current user is an expert. Determines whether the visiting user's role allows visibility of certain blocks. Creates a dictionary containing context data to be passed to the template. Generates metadata for SEO and page information. Updates the context with the generated metadata. Renders the template with the provided context. Usage \u00b6 Apply @login_required and caching decorators to the view function. Call the partner_service function with the request and pk parameters to display the personalized service page for a partner user. Note: Make sure to handle imports, mail sending, and any other dependencies properly for the view to work correctly in your project. Commit Service View \u00b6 The commit_service view function is responsible for handling the process of users committing to a service, specifically related to next activities. This view enforces user authentication and certain permissions to ensure the ethical use of the application. Functionality \u00b6 The commit_service view follows a step-by-step process to achieve its goals: User Authentication and Permissions The user is required to be logged in. If not, an error message is returned indicating the unauthenticated operation as unethical. Fetching Data The function retrieves a list of active next activities, along with their associated details. This data is fetched using the NextActivities model. Verification of User and Next Activity The function verifies that the provided user_id corresponds to the currently logged-in user. If not, an error message is returned as the operation would be considered unethical. It also verifies the existence and validity of the provided na_id by querying the NextActivities model. If the next activity doesn't exist, an error message is returned. Recording User's Commitment The function checks whether the user has already committed to the specified next activity. If not, a new record is created in the UsersNextActivity model to associate the user with the next activity. Preparing Data for Rendering Based on the user's permissions, the block_visible flag is determined. If the user is an expert, staff, or superuser, the flag is set to True to indicate that certain blocks should be visible. Data including the visiting user, current user, list of next activities, next activities in which the user has already committed, and the block_visible flag are organized to be passed to the template. Rendering the Template The final step involves rendering the commit_service.html template with the prepared context data. Permissions \u00b6 The function enforces the following permissions: - The user must be logged in. - The user must have the expert_required decorator, indicating they have a certain level of expertise to perform the action. Ethical Operation \u00b6 The view ensures ethical operation by checking user authentication, permissions, and the validity of the provided data. Any deviation from these criteria results in error messages that indicate an unethical operation. Usage \u00b6 To use the commit_service view, provide the user_id and na_id as URL parameters. For instance, to commit a service for user with ID 123 and next activity ID 456: Make sure to include the required URL patterns in your project's URL configuration to map to the commit_service view. Requirements \u00b6 Django: This view relies on the Django framework for web application development. Models and Decorators: This view assumes the existence of models such as NextActivities , UsersNextActivity , and decorators like login_required and expert_required . Please note that this documentation assumes familiarity with Django concepts and practices. If you encounter any issues or have questions, consult the Django documentation or seek assistance from experienced developers. Delete Service View \u00b6 This view function enables expert users to delete a specific Next Activity associated with a visiting user. Usage \u00b6 To use this view, ensure that the user is logged in and has expert privileges. The function is decorated with the @login_required and @expert_required decorators to ensure the required permissions are met. Parameters \u00b6 request (HttpRequest): The HTTP request object. user_id (str): The ID of the visiting user. na_id (str): The ID of the Next Activity to be deleted. Returns \u00b6 HttpResponse : A rendered HTML response displaying the result of the operation. Behavior \u00b6 If the user_id is 'None', a message is returned indicating unethical operation due to not being logged in. Otherwise, the function retrieves the visiting user's details and validates their access permissions. The function fetches the list of active Next Activities and their related quotnextactivity objects. It checks if the current user has the permission to delete Next Activities. If not, a message about unethical operation is returned. The target Next Activity to be deleted is fetched, and if not found, an unethical operation message is returned. The target Next Activity is deleted. The visibility of a certain block is determined based on the current user's role (expert, staff, or superuser). Data is prepared to be sent to the template, including visiting user details, current user details, available next activities, next activities associated with the visiting user, and block visibility status. The context is updated with the prepared data. The template registration/commit_service.html is rendered using the context, and the HTML response is returned. Please note that the decorators and exception handling are in place to ensure that only authorized users can perform this action, and the function takes care of various edge cases to prevent unethical operations. Example Usage \u00b6 Assuming a logged-in expert user with appropriate permissions, the URL might look like this:: /delete-service/<user_id>/<na_id>/ where <user_id> and <na_id> should be replaced with the appropriate values. Dependencies \u00b6 This function depends on the Django framework and specific models and decorators within the application. See Also \u00b6 Django Documentation <https://docs.djangoproject.com/en/stable/> _ Django Login Required <https://docs.djangoproject.com/en/stable/topics/auth/default/#the-login-required-decorator> _ Custom Decorators in Django <https://djangocentral.com/creating-custom-decorators-in-django/> _ expert_required Decorator \u00b6 The @expert_required decorator is a custom decorator that checks whether the current user is an expert or has appropriate permissions before allowing access to the view. It can be defined as follows: .. code-block:: python def expert_required(view_func): @wraps(view_func) def _wrapped_view(request, *args, **kwargs): if request.user.is_authenticated and (request.user.is_expert or request.user.is_staff or request.user.is_superuser): return view_func(request, *args, **kwargs) else: return HttpResponse('You do not have permission to access this page.') return _wrapped_view Contributions \u00b6 Contributions to enhance or expand this custom Django admin configuration are welcome. Feel free to submit pull requests with improvements, bug fixes, or additional features. License \u00b6 This code is provided under the MIT License . Credits \u00b6 This app is developed by Haradhan Sharma . For more information, visit the GF-VP website .","title":"Accounts"},{"location":"accounts.html#custom_django_admin_configuration_for_accounts_app","text":"This apps contains a custom Django admin configuration for managing user accounts and related models in an application. The admin configuration enhances the default Django admin interface by adding custom actions, custom fields, and filtering options.","title":"Custom Django Admin Configuration for Accounts App"},{"location":"accounts.html#overview","text":"The provided code extends the Django admin interface to manage user accounts, user profiles, and other related models. It includes custom actions for activating and deactivating user accounts, as well as sending emails to specific user groups. The customizations are designed to provide a more efficient way of managing users within the Django admin dashboard.","title":"Overview"},{"location":"accounts.html#setup","text":"To use this custom admin configuration in your Django project, follow these steps: Copy the provided code to your Django project's admin.py file or a dedicated admin.py file within your app. Make sure you have the required models, forms, and templates as referenced in the code. Register the required models using the admin.site.register() function. Customize the custom actions, filters, and other admin settings to match your project's requirements. Run your Django development server and navigate to the admin dashboard to see the changes.","title":"Setup"},{"location":"accounts.html#features","text":"Customized user list view with additional fields such as user type, expertise, phone number, and email verification status. Filtering users based on user type, activity status, staff status, expertise, and email verification status. Searching for users based on email, phone, organization, username, expertise, and email verification status. Inline editing of user profiles within the user admin page. Ordering users by their date of joining. Custom actions for activating and deactivating user accounts. Custom action for sending emails to selected marine experts for feedback updates. Management of user types with customizable display fields and filtering options.","title":"Features"},{"location":"accounts.html#custom_actions","text":"","title":"Custom Actions"},{"location":"accounts.html#activate_account_and_send_mail","text":"This action allows admin users to activate selected user accounts and send activation emails to the users. Admins can select multiple users and trigger the action to activate their accounts.","title":"Activate Account and Send Mail"},{"location":"accounts.html#deactivate_account","text":"This action enables admin users to deactivate selected user accounts. Similar to the previous action, admin users can select multiple users and deactivate their accounts.","title":"Deactivate Account"},{"location":"accounts.html#send_mail_to_expert","text":"Admin users can use this action to send courtesy emails to selected marine experts for feedback updates. The action is restricted to marine experts only. An email template is used for composing the emails.","title":"Send Mail to Expert"},{"location":"accounts.html#usertype_management","text":"The custom admin configuration also provides enhanced management for user types: Displaying user type fields in the admin list view. Filtering user types based on their names. Searching for user types using their names. Automatically populating the slug field based on the name field.","title":"UserType Management"},{"location":"accounts.html#optimized_django_user_type_decorators","text":"","title":"Optimized Django User Type Decorators"},{"location":"accounts.html#overview_1","text":"This repository provides optimized decorators for controlling access to Django views based on user types, as well as a decorator for report creator access control. These decorators simplify the process of restricting access to specific user types or report creators, enhancing the security and usability of your Django application.","title":"Overview"},{"location":"accounts.html#installation","text":"Copy the provided optimized decorators code to a suitable location within your Django project, such as a utility module. Import the decorators wherever you need to control access based on user types or report creator permissions.","title":"Installation"},{"location":"accounts.html#usage","text":"Import the required decorators in your views or viewsets: .. code-block:: python from your_project.utils.decorators import expert_required, producer_required, consumer_required, marine_required, report_creator_required Apply the decorators to your views or viewsets where access control is needed: .. code-block:: python @expert_required def expert_view(request, ...): # Your view logic here ... @report_creator_required def report_edit_view(request, slug, ...): # Your view logic here ...","title":"Usage"},{"location":"accounts.html#user_type_decorators","text":"The following user type decorators are available: expert_required : Requires the user to be an expert, staff member, or superuser. producer_required : Requires the user to be a producer, staff member, or superuser. consumer_required : Requires the user to be a consumer, staff member, or superuser. marine_required : Requires the user to be a marine user, staff member, or superuser.","title":"User Type Decorators"},{"location":"accounts.html#report_creator_decorator","text":"The report_creator_required decorator restricts access to views based on the report creator or staff/superuser. This is particularly useful for views related to report editing or management.","title":"Report Creator Decorator"},{"location":"accounts.html#custom_usercreationform_for_admin","text":"The UserCreationForm class provided in this app is a customized version of Django's default UserCreationForm . It extends the functionality of the default form to include additional fields and customization options.","title":"Custom UserCreationForm for Admin"},{"location":"accounts.html#usage_1","text":"The UserCreationForm can be used for creating new user accounts with extended fields. It adds the following features: Additional fields: The form includes custom fields such as usertype , experts_in , and term_agree . Customized appearance: The form's appearance on the admin page is customized using the UserAdmin.add_fieldsets attribute. Compatibility with UserAdmin: The form is compatible with the Django UserAdmin interface.","title":"Usage"},{"location":"accounts.html#customization","text":"The UserCreationForm is designed to enhance the default user registration process. It inherits from Django's UserCreationForm and extends its functionality: The __init__ method initializes the form instance. The UserAdmin.add_form is set to use the Django's default UserCreationForm . The UserAdmin.add_fieldsets are updated to include the additional fields and customize the appearance. To use this form in your project, simply import it and use it for user registration with the extended fields. .. code-block:: python from django.contrib.auth.forms import UserCreationForm as UserCreationFormDjango from .forms import UserCreationForm # Import the custom form from django.contrib.auth.admin import UserAdmin # Set the UserAdmin's add_form to use the custom UserCreationForm UserAdmin.add_form = UserCreationFormDjango","title":"Customization"},{"location":"accounts.html#usercreationformfront_for_user_registration","text":"The UserCreationFormFront class is a custom user creation form specifically designed for the frontend registration page of your Django project's account app. This form extends the UserCreationFormDjango class.","title":"UserCreationFormFront for user registration"},{"location":"accounts.html#usage_2","text":"This form includes various custom fields with HTML attributes to enhance user experience during registration. It also implements validations for username, email, and other fields. Additionally, it integrates with Google reCAPTCHA for added security.","title":"Usage"},{"location":"accounts.html#custom_fields","text":"username : A field for the username with a placeholder and real-time username availability check using AJAX. email : An email field with a placeholder and real-time email availability check using AJAX. password1 : A password field for the user's password. password2 : A field to confirm the password. term_agree : A checkbox for agreeing to terms and conditions. newsletter_subscription : A checkbox to subscribe to the newsletter.","title":"Custom Fields"},{"location":"accounts.html#custom_widgets","text":"The form uses various custom widgets for improved user interactions: usertype : A dropdown widget for selecting the user type with AJAX-based data loading. experts_in : A dropdown widget for selecting areas of expertise. orgonization : A text input widget for the user's organization. is_public : A checkbox widget for specifying whether the user's profile is public.","title":"Custom Widgets"},{"location":"accounts.html#validation_and_email_verification","text":"The UserCreationFormFront class contains methods for custom field validation: clean_username() : Validates the username to disallow spaces. clean_experts_in() : Validates the experts_in field based on the user type. clean() : Implements a custom clean method for handling various validations and email verifications during registration.","title":"Validation and Email Verification"},{"location":"accounts.html#email_verification_flow","text":"The form handles email verification during registration: If the provided email is not registered, the user can proceed with registration. If the email is already registered but not verified, a verification email is sent to the user for confirmation. If the email is verified but the account is not activated, the user receives a courtesy email and a message regarding activation status. Please note that this README provides a summary of the UserCreationFormFront class and its functionalities. For detailed implementation and integration instructions, refer to the associated source code and documentation within your Django project's account app.","title":"Email Verification Flow"},{"location":"accounts.html#custom_userchangeform_for_self-account_data_editing","text":"","title":"Custom UserChangeForm for Self-Account Data Editing"},{"location":"accounts.html#introduction","text":"The UserChangeForm Class ~~~~~~~~~~~~~~~~~~~~~~~~~~ The UserChangeForm class provided in this module is a custom form derived from Django's UserChangeForm . Its purpose is to extend the functionality of the default form to allow users to edit their own account data. This form is primarily used within the settings and password change sections of the dashboard.","title":"Introduction"},{"location":"accounts.html#usage_3","text":"To make use of the UserChangeForm , adhere to the following steps: Import the form into your views or forms module: .. code-block:: python from path.to.UserChangeForm import UserChangeForm In your view or form class, create an instance of the UserChangeForm : .. code-block:: python user_change_form = UserChangeForm(instance=request.user) Render the form within your template: .. code-block:: html <form method=\"post\"> {% csrf_token %} {{ user_change_form.as_p }} <button type=\"submit\">Save Changes</button> </form>","title":"Usage"},{"location":"accounts.html#fields_and_widgets","text":"The UserChangeForm inherits the fields and widgets of the default UserChangeForm provided by Django. However, this implementation extends these fields with additional customization, specifically: Email: The email field is tailored to use the forms.EmailInput widget. This results in an email input field that has the form-control class and an aria-label attribute, thereby enhancing accessibility. .. code-block:: python widgets = { 'email': forms.EmailInput(attrs={'class': 'form-control', 'aria-label': 'email'}), }","title":"Fields and Widgets"},{"location":"accounts.html#meta_class","text":"The Meta class within the UserChangeForm specifies the model to be utilized and the fields to be included in the form. In this case, the form is configured to operate with the user model returned by get_user_model() and encompasses all fields. .. code-block:: python class Meta: model = get_user_model() fields = '__all__'","title":"Meta Class"},{"location":"accounts.html#loginform_class_in_account_app","text":"","title":"LoginForm Class in Account App"},{"location":"accounts.html#overview_2","text":"The LoginForm class is a custom login form designed for the Django project's account app. This form extends the default AuthenticationForm provided by Django, adding additional fields, custom validations, and integrating reCAPTCHA for enhanced security.","title":"Overview"},{"location":"accounts.html#features_1","text":"Customized Fields: The LoginForm customizes the default Django form fields, adding HTML attributes to improve user experience. The username and password fields are styled using the form-control CSS class. Remember Me Option: A \"Remember Me\" checkbox allows users to choose whether to remember their login for 30 days, as per the site settings. This feature enhances user convenience. reCAPTCHA Integration: The form includes a Google reCAPTCHA field to prevent automated bot submissions. The reCAPTCHA is displayed as a checkbox for user interaction.","title":"Features"},{"location":"accounts.html#additional_details","text":"Meta Class: The Meta class within the LoginForm specifies the model and fields used in the form. The fields included in the form are username , password , and remember_me . Custom Validation: The clean method of the LoginForm class implements custom validation and checks. It ensures that the reCAPTCHA is completed and verifies the provided email and password. If the reCAPTCHA is not completed, a validation error is raised, requiring the user to complete the CAPTCHA. If the provided email and password are valid, the form checks if the email exists in the system. If the email does not exist, an error message is displayed. If the email exists but is not verified, the user is sent an email verification link for verification. A warning message is also displayed to the user. If the email is verified but not activated, different actions are taken based on the user's type (expert, marine, etc.). For certain user types, the user is notified that their account is awaiting approval. For others, an activation email is resent. If the email is verified and activated, the user is authenticated using their email and password. If the authentication fails, an error message is shown.","title":"Additional Details"},{"location":"accounts.html#usage_4","text":"To utilize the LoginForm class, follow these steps: Import the LoginForm class into the appropriate module: .. code-block:: python from account.forms import LoginForm Use the LoginForm class in your views, passing it to your template context for rendering: .. code-block:: python def login_view(request): # ... form = LoginForm(request, ...) # ... Render the form in your template using Django template tags: .. code-block:: html {% csrf_token %} {{ form.as_p }} Login","title":"Usage"},{"location":"accounts.html#notes","text":"Ensure that the necessary Django imports and configurations are set up before using the LoginForm class. Modify the form template as needed to match your project's styling and design. The form relies on reCAPTCHA. Make sure to set up reCAPTCHA keys in your project settings for the CAPTCHA field to function properly. For further assistance or customization, refer to the Django documentation and comments within the code.","title":"Notes"},{"location":"accounts.html#helper_of_accounts_app","text":"This is a brief description of the My App project.","title":"Helper of Accounts APP"},{"location":"accounts.html#custom_username_validator","text":".. code-block:: python class CustomsernameValidator(UnicodeUsernameValidator, ASCIIUsernameValidator): \"\"\" Custom username validator that allows only letters, numbers, and periods. \"\"\" ...","title":"Custom Username Validator"},{"location":"accounts.html#permission_check_function","text":"The following function is abandoned and not currently in use: .. code-block:: python def check_type(request, slug): \"\"\" Checks if the current user has the permission to access the requested resource. Args: request (django.http.HttpRequest): The HTTP request object. slug (str): The slug of the user type. Raises: PermissionDenied: If the current user does not have the permission to access the requested resource. \"\"\" ...","title":"Permission Check Function"},{"location":"accounts.html#email_function","text":"The following function sends an email to all admins: .. code-block:: python def send_admin_mail(subject, message): \"\"\" Sends an email to all admins. Args: subject (str): The email subject. message (str): The email message. \"\"\" ...","title":"Email Function"},{"location":"accounts.html#automatic_profile_creation","text":"The accounts app includes a signal that automatically creates or updates user profiles whenever a new user is registered or an existing user is saved. This functionality is achieved through the use of Django signals. Whenever a User instance is created, the signal is triggered, and the create_or_update_user_profile function is called. This function checks if the user is newly created or being updated and accordingly creates a new profile or updates the existing one.","title":"Automatic Profile Creation"},{"location":"accounts.html#usage_5","text":"To use this automatic profile creation feature in your Django project, follow these steps: Make sure the accounts app is installed in your project and properly configured. In your accounts app, create a file named signals.py if it doesn't already exist. Add the following code to your signals.py file: .. code-block:: python @receiver(post_save, sender=User) def create_or_update_user_profile(sender, instance, created, **kwargs): ... In the above code, make sure to replace 'models' with the correct import path to your Profile model if it's in a different module or app. In your project's settings.py file, add the 'accounts.signals' module to the INSTALLED_APPS list to ensure that the signal is properly connected. You can uncomment the post_save.connect(create_or_update_user_profile, sender=User) line in the signals.py file or connect the signal in your preferred way. With these steps completed, your project will automatically create or update user profiles whenever a new user is registered or an existing user is saved. Remember to run your project's migrations after making these changes to ensure that the database schema is updated accordingly.","title":"Usage"},{"location":"accounts.html#automatic_notification_settings_creation","text":"The accounts app includes a signal that automatically creates or updates notification settings associated with a user whenever a new user is registered or an existing user is saved. This functionality is achieved through the use of Django signals. Whenever a User instance is created or updated, the signal is triggered, and the create_or_update_notification_settings function is called. This function checks if the user is newly created or being updated and accordingly creates a new notification setting or updates the existing one.","title":"Automatic Notification Settings Creation"},{"location":"accounts.html#usage_6","text":"To use this automatic notification settings creation feature in your Django project, follow these steps: Make sure the accounts app is installed in your project and properly configured. In your accounts app, create a file named signals.py if it doesn't already exist. Add the following code to your signals.py file: ```python from django.db.models.signals import post_save from django.dispatch import receiver from .models import User, NotificationSettings @receiver(post_save, sender=User) def create_or_update_notification_settings(sender, instance, created, **kwargs): \"\"\" Creates or updates a notification setting associated with the User model. As it has been created after an existing user, we are checking for creating notification if it doesn't exist to avoid errors. Args: sender (Model): The model class that sent the signal (User in this case). instance (User): The specific instance of the User model that was saved. created (bool): Indicates whether a new instance was created or an existing one was saved. **kwargs: Additional keyword arguments passed along with the signal. Returns: None \"\"\" try: notification_settings = instance.notificationsettings # Attempt to access the related NotificationSettings except NotificationSettings.DoesNotExist: notification_settings = None if created or notification_settings is None: # Create a notification settings or update the existing one notification_settings, created = NotificationSettings.objects.get_or_create(user=instance) # Now, make sure that the instance.notificationsettings is set properly if instance.pk != notification_settings.pk: instance.notificationsettings = notification_settings instance.save()","title":"Usage"},{"location":"accounts.html#account_activation_token_generator","text":"Accounts app includes a custom token generator, AccountActivationTokenGenerator , which is used to generate tokens for email validation during user signup. This token generator extends Django's built-in PasswordResetTokenGenerator to add activation-related information.","title":"Account Activation Token Generator"},{"location":"accounts.html#usage_7","text":"To use the AccountActivationTokenGenerator for email validation during user signup, follow these steps: Make sure the accounts app is installed in your project and properly configured. In your project's settings.py file, ensure that the 'accounts' app is included in the INSTALLED_APPS list. In your accounts app, create a file named tokens.py if it doesn't already exist. Add the following code to your tokens.py file: .. code-block:: python class AccountActivationTokenGenerator(PasswordResetTokenGenerator): def _make_hash_value(self, user, timestamp): ... account_activation_token = AccountActivationTokenGenerator() In the above code, AccountActivationTokenGenerator extends Django's PasswordResetTokenGenerator and includes custom logic for generating tokens with user activation information. The account_activation_token instance of the AccountActivationTokenGenerator class can be used to generate tokens for user email validation during signup.","title":"Usage"},{"location":"accounts.html#url_configuration","text":"Here's an overview of the URL patterns defined in the urls.py file of the accounts app: User Signup: URL: /signup/ View: views.signup Description: The endpoint for user registration. Renders the signup form and handles form submission. User Login: URL: /login/ View: views.CustomLoginView Description: The endpoint for user login. Uses a custom login view to manage authentication and redirection. User Profile: URL: /my-profile/ View: views.userpage Description: The endpoint for the user's profile page. Displays the user's profile information and related details. User Activation: URL: /activate/<uidb64>/<token>/ View: views.activate Description: The endpoint for user account activation via token. Activates a user's account using the provided token. Check Username Availability: URL: /check-username/ View: views.check_username Description: Endpoint to check the availability of a chosen username during registration. Check Email Availability: URL: /check-email/ View: views.check_email Description: Endpoint to check the availability of a chosen email address during registration. Commit User Service: URL: /<str:user_id>/<str:na_id>/commit-service/ View: views.commit_service Description: Endpoint to commit a service associated with a user's profile. Delete User Service: URL: /<str:user_id>/<str:na_id>/delete-service/ View: views.delete_service Description: Endpoint to delete a service associated with a user's profile.","title":"URL Configuration"},{"location":"accounts.html#custom_login_view","text":".. note:: This section describes the custom login view implemented in this project. The project includes a custom login view called ``CustomLoginView``, which is built upon Django's built-in ``LoginView`` class. This custom view allows for fine-grained control over the login process and introduces additional features.","title":"Custom Login View"},{"location":"accounts.html#features_2","text":"Uses a custom login form ( LoginForm ) to collect user credentials. Sets a custom URL for redirection after a successful login. Handles the 'remember me' functionality to control session duration.","title":"Features"},{"location":"accounts.html#usage_8","text":"To use the custom login view in your project, follow these steps: Ensure that you have the necessary prerequisites and Django set up. Copy the CustomLoginView class from the provided source code. Import the necessary modules and classes in your project, including the custom form ( LoginForm ).","title":"Usage"},{"location":"accounts.html#example_usage","text":"Below is an example of how you might use the CustomLoginView in your Django project's views.py : .. code-block:: python from django.urls import reverse_lazy from custom_login_app.forms import LoginForm # Import the custom LoginForm from custom_login_app.views import CustomLoginView # Import the CustomLoginView class MyCustomLoginView(CustomLoginView): form_class = LoginForm # Use the custom LoginForm next_page = reverse_lazy('accounts:user_link') # Set a custom redirection URL","title":"Example Usage"},{"location":"accounts.html#context_data","text":"The custom login view also provides additional context data to enhance the rendering of the login page. This includes meta information such as title, description, tags, and robots.","title":"Context Data"},{"location":"accounts.html#signup_view","text":"The signup view function is responsible for handling user signup and registration. It provides a user-friendly interface for users to create accounts on the website. The view supports various user types and expert subtypes. .. code-block:: python def signup(request): \"\"\" View function for user signup. This view handles the signup procedure for different user types and experts' subtypes. The process involves segregating users based on their selected user type or expert subtype. Users who have already selected a user type during their session are directed to the signup form. If anyone attempts to signup without selecting a user type, they are redirected to choose one. Expert users only need to select the \"Expert\" user type during signup. :param request: The HTTP request object. :type request: HttpRequest :return: The rendered signup page or redirection to appropriate pages. :rtype: HttpResponse \"\"\"","title":"Signup View"},{"location":"accounts.html#features_3","text":"User Type Segregation: Users are directed to select their user type or expert subtype before proceeding with registration. This segregation ensures accurate registration and user role assignment. Email Confirmation: After submitting the signup form, users receive an email confirmation containing an activation link. This link is used to verify the user's email address and complete the registration process. Interactive Frontend: The frontend of the signup page is interactive, guiding users through the registration process. The form is pre-filled with default values, ensuring a seamless user experience.","title":"Features"},{"location":"accounts.html#installation_1","text":"Install the required Python packages using pip: .. code-block:: bash pip install -r requirements.txt Add the account app to your Django project's settings: .. code-block:: python INSTALLED_APPS = [ # ... 'account', # ... ] Include the app's URLs in your project's URL configuration: .. code-block:: python from django.urls import path from account.views import signup urlpatterns = [ # ... path('signup/', signup, name='signup'), # ... ]","title":"Installation"},{"location":"accounts.html#activate_user_account","text":"The accounts app provides functionality for user account activation and related actions after the signup process. The activate function in this app is responsible for activating a user's account using the provided activation link. The following actions are performed during the activation process: Preparation of data for the site. Verification of the activation URL and decoding of the user ID. If the activation link is valid, the user's account is marked as email verified. a. If the user is an expert or marine, the account is activated manually by the site admin, and the user is notified to wait for approval. b. If the user is not an expert, the account is activated automatically, and an account activation email is sent. User data is saved, considering different approval policies based on user type.","title":"Activate User Account"},{"location":"accounts.html#creating_lead","text":"After the activation process, the app performs the following actions: Retrieves location information from the HTTP request. Creates a lead using the user's full name, email address, city, and country information.","title":"Creating Lead"},{"location":"accounts.html#creating_newsletter_subscription","text":"The app also handles newsletter subscriptions: If the user has opted to receive the newsletter during signup, the app checks whether the user's email already exists in the CRM. If the email exists, the subscription status is updated to True . If the email does not exist, a new lead is created with the user's information, and the subscription status is set to True .","title":"Creating Newsletter Subscription"},{"location":"accounts.html#usage_9","text":"To use the activate function, pass the required arguments: request (HttpRequest): The HTTP request object. uidb64 (str): The base64-encoded user ID. token (str): The activation token. The function will redirect to appropriate views based on the activation result. Make sure to configure your project's URLs and templates accordingly to handle the activation process and related notifications. Note: This readme provides a summary of the activate function's functionality. Please refer to the source code for complete implementation details.","title":"Usage"},{"location":"accounts.html#user_profile_page_view","text":"This Django view function displays a user's profile page, providing information about their reports and activities.","title":"User Profile Page View"},{"location":"accounts.html#usage_10","text":"Decorator Usage: This view function is decorated with @login_required to ensure that only authenticated users can access it. Input: request (HttpRequest): The HTTP request object sent by the client. Output: HttpResponse : The rendered user profile page with relevant user data.","title":"Usage"},{"location":"accounts.html#functionality","text":"When a user accesses their profile page, the following steps are performed: Clear the session data to ensure a clean state when the user logs in. Retrieve the user from the request. Check if a report slug is provided in the query parameters. If so, attempt to retrieve the corresponding report. If no report slug is provided, retrieve the most recent report created by the user. If a report is found, generate label-wise data from the report. Calculate statistics based on the label data: ans_ques : Total answered questions dont_know_ans : Number of questions not answered pos_ans : Total positive answers positive_percent : Percentage of positive answers dont_know_percent : Percentage of unanswered questions Retrieve the first parent question for the evaluation. If not found, display an error message. Get all reports with the last answer related to the first parent question. Paginate the reports for display. Construct a URL for a button linked to the last report. Prepare the context for rendering the user profile page. If no reports are found for the user: Display links to various sections that users can explore. Meta data is prepared for the page, including title, description, tags, and image. The context is updated with the prepared meta data. Finally, the view renders the user profile page with the provided context.","title":"Functionality"},{"location":"accounts.html#documentation","text":"The function is documented using docstrings, explaining its purpose, inputs, and outputs. Comments within the code provide additional explanations about specific code sections and their functionality. Various sections of the code are explained in detail to provide better understanding. Comments and explanations are provided for context variables and calculations.","title":"Documentation"},{"location":"accounts.html#usage_recommendations","text":"This view function should be used within a Django application where user profiles and reports are managed. Developers should ensure that the required models and utilities are imported and configured properly before using this function. To maintain security, ensure that the @login_required decorator is applied to this view function to restrict access to authenticated users only. Developers can modify the context variables and calculations to customize the content and presentation of the user profile page as per their project requirements.","title":"Usage Recommendations"},{"location":"accounts.html#note","text":"This documentation is provided as an explanatory guide and may need to be adapted based on the specific use case and context of the project.","title":"Note"},{"location":"accounts.html#username_check_function","text":"Check the availability and validity of a username in a signup form. This function takes a POST request containing a 'username' parameter and checks if the provided username is valid and available for registration.","title":"Username Check Function"},{"location":"accounts.html#function_signature","text":".. code-block:: python def check_username(request): \"\"\" Check the availability and validity of a username in a signup form. Args: request (HttpRequest): A POST request containing the 'username' parameter. Returns: HttpResponse: A response indicating whether the username is valid and available. - If the username contains spaces, returns a danger message. - If the username already exists in the User model, returns a danger message. - If the username is valid and available, returns a success message. \"\"\"","title":"Function Signature"},{"location":"accounts.html#function_parameters","text":"request (HttpRequest): A POST request containing the 'username' parameter.","title":"Function Parameters"},{"location":"accounts.html#function_behavior","text":"Retrieve the username from the POST request. Check for spaces in the username. If spaces are found, return a danger message. Check if the username already exists in the User model. If the username already exists, return a danger message. If the username is valid and available, return a success message.","title":"Function Behavior"},{"location":"accounts.html#usage_example","text":".. code-block:: python from django.http import HttpRequest, HttpResponse from myapp.models import User # Replace with actual import def check_username(request): # Your implementation here","title":"Usage Example"},{"location":"accounts.html#check_email_view_function","text":"Checks the validity and availability of an email address provided in a sign-up form. This function takes a POST request containing an email address from a sign-up form and performs the following checks: Validates the email format using Django's django.core.validators.validate_email function. Checks if the email address already exists in the User model. If the email is valid and not already taken, it returns a success message. If the email is invalid, already taken, or an exception occurs during validation, it returns an appropriate error message. :param HttpRequest request: The HTTP request containing the email in the POST data. :return: A response indicating the validity and availability of the email. :rtype: HttpResponse :raises: None Example:: from django.core.validators import validate_email email = request.POST.get('email') try: validate_email(email) if User.objects.filter(email=email).exists(): return HttpResponse('<span class=\"text-danger\">This email already exists!</span>') else: return HttpResponse('<span class=\"text-success\">This email available!</span>') except: return HttpResponse('<span class=\"text-danger\">Type a valid email address!</span>')","title":"check_email View Function"},{"location":"accounts.html#partner_service_view_function","text":".. code-block:: python @login_required @cache_control(no_cache=True, must_revalidate=True, no_store=True) def partner_service(request, pk): \"\"\" Display the personalized service page for a partner user. This view displays the personalized service page for a visiting partner user. It retrieves the necessary information such as next activities and selected activities to be displayed on the page. It also handles visibility permissions based on the user's role (expert, staff, superuser). Additionally, it generates meta data for SEO purposes. Args: request (HttpRequest): The HTTP request object. pk (int): The primary key of the visiting user. Returns: HttpResponse: Rendered HTML template displaying the service page. \"\"\" # To avoid circular reference from evaluation.models import NextActivities","title":"partner_service View Function"},{"location":"accounts.html#description","text":"The partner_service view function is responsible for displaying a personalized service page for visiting partner users. It retrieves essential information such as next activities and selected activities to be shown on the page. This view also handles visibility permissions based on the user's role (expert, staff, superuser) and generates metadata for SEO purposes.","title":"Description"},{"location":"accounts.html#parameters","text":"request (HttpRequest): The HTTP request object. pk (int): The primary key of the visiting user.","title":"Parameters"},{"location":"accounts.html#returns","text":"HttpResponse: Rendered HTML template displaying the service page.","title":"Returns"},{"location":"accounts.html#functionality_1","text":"Retrieves the visiting user based on the provided primary key. Retrieves the currently logged-in user. Retrieves all next activities with prefetch for related 'quotnextactivity'. Gets the selected activities of the visiting user. Notifies the admin if there are no next activities and the current user is an expert. Determines whether the visiting user's role allows visibility of certain blocks. Creates a dictionary containing context data to be passed to the template. Generates metadata for SEO and page information. Updates the context with the generated metadata. Renders the template with the provided context.","title":"Functionality"},{"location":"accounts.html#usage_11","text":"Apply @login_required and caching decorators to the view function. Call the partner_service function with the request and pk parameters to display the personalized service page for a partner user. Note: Make sure to handle imports, mail sending, and any other dependencies properly for the view to work correctly in your project.","title":"Usage"},{"location":"accounts.html#commit_service_view","text":"The commit_service view function is responsible for handling the process of users committing to a service, specifically related to next activities. This view enforces user authentication and certain permissions to ensure the ethical use of the application.","title":"Commit Service View"},{"location":"accounts.html#functionality_2","text":"The commit_service view follows a step-by-step process to achieve its goals: User Authentication and Permissions The user is required to be logged in. If not, an error message is returned indicating the unauthenticated operation as unethical. Fetching Data The function retrieves a list of active next activities, along with their associated details. This data is fetched using the NextActivities model. Verification of User and Next Activity The function verifies that the provided user_id corresponds to the currently logged-in user. If not, an error message is returned as the operation would be considered unethical. It also verifies the existence and validity of the provided na_id by querying the NextActivities model. If the next activity doesn't exist, an error message is returned. Recording User's Commitment The function checks whether the user has already committed to the specified next activity. If not, a new record is created in the UsersNextActivity model to associate the user with the next activity. Preparing Data for Rendering Based on the user's permissions, the block_visible flag is determined. If the user is an expert, staff, or superuser, the flag is set to True to indicate that certain blocks should be visible. Data including the visiting user, current user, list of next activities, next activities in which the user has already committed, and the block_visible flag are organized to be passed to the template. Rendering the Template The final step involves rendering the commit_service.html template with the prepared context data.","title":"Functionality"},{"location":"accounts.html#permissions","text":"The function enforces the following permissions: - The user must be logged in. - The user must have the expert_required decorator, indicating they have a certain level of expertise to perform the action.","title":"Permissions"},{"location":"accounts.html#ethical_operation","text":"The view ensures ethical operation by checking user authentication, permissions, and the validity of the provided data. Any deviation from these criteria results in error messages that indicate an unethical operation.","title":"Ethical Operation"},{"location":"accounts.html#usage_12","text":"To use the commit_service view, provide the user_id and na_id as URL parameters. For instance, to commit a service for user with ID 123 and next activity ID 456: Make sure to include the required URL patterns in your project's URL configuration to map to the commit_service view.","title":"Usage"},{"location":"accounts.html#requirements","text":"Django: This view relies on the Django framework for web application development. Models and Decorators: This view assumes the existence of models such as NextActivities , UsersNextActivity , and decorators like login_required and expert_required . Please note that this documentation assumes familiarity with Django concepts and practices. If you encounter any issues or have questions, consult the Django documentation or seek assistance from experienced developers.","title":"Requirements"},{"location":"accounts.html#delete_service_view","text":"This view function enables expert users to delete a specific Next Activity associated with a visiting user.","title":"Delete Service View"},{"location":"accounts.html#usage_13","text":"To use this view, ensure that the user is logged in and has expert privileges. The function is decorated with the @login_required and @expert_required decorators to ensure the required permissions are met.","title":"Usage"},{"location":"accounts.html#parameters_1","text":"request (HttpRequest): The HTTP request object. user_id (str): The ID of the visiting user. na_id (str): The ID of the Next Activity to be deleted.","title":"Parameters"},{"location":"accounts.html#returns_1","text":"HttpResponse : A rendered HTML response displaying the result of the operation.","title":"Returns"},{"location":"accounts.html#behavior","text":"If the user_id is 'None', a message is returned indicating unethical operation due to not being logged in. Otherwise, the function retrieves the visiting user's details and validates their access permissions. The function fetches the list of active Next Activities and their related quotnextactivity objects. It checks if the current user has the permission to delete Next Activities. If not, a message about unethical operation is returned. The target Next Activity to be deleted is fetched, and if not found, an unethical operation message is returned. The target Next Activity is deleted. The visibility of a certain block is determined based on the current user's role (expert, staff, or superuser). Data is prepared to be sent to the template, including visiting user details, current user details, available next activities, next activities associated with the visiting user, and block visibility status. The context is updated with the prepared data. The template registration/commit_service.html is rendered using the context, and the HTML response is returned. Please note that the decorators and exception handling are in place to ensure that only authorized users can perform this action, and the function takes care of various edge cases to prevent unethical operations.","title":"Behavior"},{"location":"accounts.html#example_usage_1","text":"Assuming a logged-in expert user with appropriate permissions, the URL might look like this:: /delete-service/<user_id>/<na_id>/ where <user_id> and <na_id> should be replaced with the appropriate values.","title":"Example Usage"},{"location":"accounts.html#dependencies","text":"This function depends on the Django framework and specific models and decorators within the application.","title":"Dependencies"},{"location":"accounts.html#see_also","text":"Django Documentation <https://docs.djangoproject.com/en/stable/> _ Django Login Required <https://docs.djangoproject.com/en/stable/topics/auth/default/#the-login-required-decorator> _ Custom Decorators in Django <https://djangocentral.com/creating-custom-decorators-in-django/> _","title":"See Also"},{"location":"accounts.html#expert_required_decorator","text":"The @expert_required decorator is a custom decorator that checks whether the current user is an expert or has appropriate permissions before allowing access to the view. It can be defined as follows: .. code-block:: python def expert_required(view_func): @wraps(view_func) def _wrapped_view(request, *args, **kwargs): if request.user.is_authenticated and (request.user.is_expert or request.user.is_staff or request.user.is_superuser): return view_func(request, *args, **kwargs) else: return HttpResponse('You do not have permission to access this page.') return _wrapped_view","title":"expert_required Decorator"},{"location":"accounts.html#contributions","text":"Contributions to enhance or expand this custom Django admin configuration are welcome. Feel free to submit pull requests with improvements, bug fixes, or additional features.","title":"Contributions"},{"location":"accounts.html#license","text":"This code is provided under the MIT License .","title":"License"},{"location":"accounts.html#credits","text":"This app is developed by Haradhan Sharma . For more information, visit the GF-VP website .","title":"Credits"},{"location":"blog.html","text":"GFVP Blog App \u00b6 Introduction \u00b6 The GFVP Blog App is a simple yet powerful application that provides the foundation for creating and managing blog posts. This app allows you to easily create, edit, publish, and manage blog posts, while also providing a user-friendly interface for the admin panel. Installation \u00b6 To use the Django Blog App in your project, follow these steps: Install the app using pip: .. code-block:: bash pip install .... Add 'blog' to the INSTALLED_APPS list in your project's settings.py : .. code-block:: python INSTALLED_APPS = [ # ... 'blog', # ... ] Include the app's URLs in your project's urls.py : .. code-block:: python from django.urls import path, include urlpatterns = [ # ... path('blog/', include('blog.urls')), # ... ] Usage \u00b6 Admin Panel: The Django Blog App provides an admin panel interface to manage blog posts easily. You can access the admin panel at /admin/ . In the admin panel, you can: Create, edit, and delete blog posts. Use the Summernote rich text editor to compose blog post content. Manage tags and categories associated with blog posts. Publish or draft blog posts. Filter and search for blog posts. Customization: The app is designed to be easily customizable to fit your project's specific needs. You can extend the BlogPost model or modify its behavior by creating your own customizations. For more information on how to customize and extend the app, refer to the official documentation. Models \u00b6 The Django Blog App includes two main models to manage blog posts and track actions on various objects. Action Model: The Action model tracks different actions performed on various objects. It's a generic model that can be used to record actions like views and likes on different content types. The key attributes of this model are: content_type : A ForeignKey to the ContentType model, representing the type of the content object. object_id : A PositiveIntegerField representing the ID of the content object. content_object : A GenericForeignKey that allows you to link to any object using the content_type and object_id . user : A ForeignKey to the user who performed the action (if authenticated), or None for anonymous users. ip_address : A GenericIPAddressField to store the IP address of the user performing the action. action_type : A CharField to store the type of action, such as 'view' or 'like'. timestamp : A DateTimeField representing the time the action was recorded. This model is designed to be versatile and can be easily extended to track other types of actions as well. BlogPost Model: The BlogPost model represents a blog post within the application. It includes fields to store information about the post's title, content, author, publishing status, and more. The main attributes of this model are: title : A CharField representing the title of the blog post. image : An ImageField to store the featured image of the post. slug : A SlugField to generate and store a URL-friendly slug for the post's URL. author : A ForeignKey to the user who authored the post. body : A TextField to store the content of the blog post. publish : A DateTimeField indicating the publication date and time of the post. created : A DateTimeField representing the creation date of the post. updated : A DateTimeField indicating the last update time of the post. status : A CharField indicating the publishing status of the post (draft or published). tags : A TaggableManager that allows you to associate tags with the post. actions : A GenericRelation to the Action model, enabling tracking of actions related to this post. Additionally, the BlogPost model includes custom methods to calculate the total number of views and record new views. The model also features a custom manager, PublishedManager , to retrieve only published posts. This combination of models provides a powerful foundation for creating and managing blog posts with customizable features and actions tracking. Signals \u00b6 The Django Blog App uses signals to automate certain actions and tasks related to blog posts. Signals allow the app to respond to events like creating, updating, or deleting a blog post, and perform additional actions as needed. send_to_mail_queue Signal: The send_to_mail_queue signal handler is triggered after a BlogPost instance is saved. This signal is responsible for creating or updating BlogMailQueue entries based on the status and changes to the blog post. The key functionality includes: When a new BlogPost is created and its status is 'published', a BlogMailQueue entry will be created for each subscribed lead. If a BlogPost is updated and its status is changed to 'draft', any unprocessed BlogMailQueue entries related to that post will be deleted. If the status of an updated BlogPost is changed to 'published' and there are no existing BlogMailQueue entries, new entries will be created for each subscribed lead. delete_mail_queues Signal: The delete_mail_queues signal handler is triggered after a BlogPost instance is deleted. This signal is responsible for deleting any unprocessed BlogMailQueue entries related to the deleted blog post. To ensure these signals work correctly, the following components must be present: Import the necessary models at the beginning of the signal.py file. Set up appropriate logging to track the actions of the signals. Please note that signals can greatly enhance the automation and logic within your app, but it's important to use them judiciously and ensure they're thoroughly tested to avoid unintended consequences. For more information on how signals work in Django and how to handle them effectively, refer to the official Django documentation on signals. URL Patterns \u00b6 The Django Blog App uses URL patterns to define how different URLs should be handled and routed to specific views. URL patterns play a crucial role in determining how users can access various parts of your application. URL Configuration: In the urls.py file of the blog app, you will find a list of URL patterns defined using the path function. Each pattern consists of a URL route and a corresponding view function. The app_name is set to 'blog' to create a namespace for these URL patterns. URL Patterns Explained: blog/ : URL Route: blog/ View Function: views.post_list Name: post_list Description: This URL pattern maps to the post_list view, which displays a list of all blog posts. blog/<slug:post>/ : URL Route: blog/<slug:post>/ View Function: views.post_detail Name: post_detail Description: This URL pattern includes a slug parameter, which is used to identify a specific blog post. It maps to the post_detail view, showing the detailed view of the selected blog post. blog/tag/<slug:tag_slug>/ : URL Route: blog/tag/<slug:tag_slug>/ View Function: views.post_list Name: post_tag Description: This URL pattern includes a slug parameter ( tag_slug ), allowing users to view blog posts filtered by a specific tag. It maps to the post_list view, displaying posts associated with the selected tag. Namespace and Reversing: The app_name is set to 'blog', creating a namespace for these URL patterns. This namespace helps avoid naming conflicts and makes it easier to reverse URLs in templates and code using the app_name:pattern_name syntax. For example, to generate the URL for the post_detail view for a blog post with the slug 'my-blog-post', you can use {% url 'blog:post_detail' post='my-blog-post' %} in templates or reverse('blog:post_detail', args=['my-blog-post']) in Python code. Understanding and utilizing these URL patterns is crucial for ensuring smooth navigation and interaction within the Django Blog App. For more information on Django URL routing and reversing, refer to the official Django documentation on URL dispatch and URL reversing. View: post_list \u00b6 The post_list view function is responsible for displaying a list of blog posts on the website. This view supports various scenarios, such as showing all published posts, filtering posts by a specific tag, and providing search functionality. View Details \u00b6 Function Signature: .. code-block:: python def post_list(request, tag_slug=None): Parameters: request (:class: ~django.http.request.HttpRequest ): The HTTP request object. tag_slug (:class: ~str , optional): An optional tag slug to filter posts by a specific tag. Functionality: This view handles the display of blog posts and supports filtering by tag and searching by query. It constructs a context for rendering the template, including the list of blog posts and other necessary data. If a tag_slug is provided in the URL, it filters posts tagged with the specified tag. If a search query ( q ) is present in the GET parameters, it filters posts based on the search query using Q objects for more advanced searches. The resulting list of posts is ordered by their update date and supports pagination. Stored Search Query: If a search query is provided, the view stores it in the user's session to pre-fill the search box when displaying the search results. The stored query is cleared from the session if there is no active search. Meta Information: The view also sets up meta information for the page, such as title, description, tags, and robot indexing instructions. Usage Examples \u00b6 To display all published blog posts, access the URL: /blog/ To view posts with a specific tag, access the URL: /blog/tag/tag-slug/ To search for specific terms within blog posts, add a search query to the URL: /blog/?q=search-term This view plays a central role in providing users with a curated list of blog posts and facilitates easy navigation and discovery. For more information on how this view is utilized within the application and its interaction with templates, please refer to the comments and docstrings within the source code. View: post_detail \u00b6 The post_detail view function is responsible for displaying a detailed view of a specific blog post on the website. This view provides users with comprehensive information about a single blog post, including related posts and meta information. View Details \u00b6 Function Signature: .. code-block:: python def post_detail(request, post): Parameters: request (:class: ~django.http.request.HttpRequest ): The HTTP request object. post (:class: ~str ): The slug of the specific blog post to display. Functionality: This view handles the detailed display of a specific blog post. It clears any stored search term in the session to ensure a clean user experience. If a search query ( q ) is present in the GET parameters, it stores the query in the session and redirects to the post_list view to display search results. The view retrieves the specific published blog post based on the provided slug. It records the view action for the blog post using the post.view() method. The view fetches similar posts based on shared tags, excluding the current post. These similar posts are ordered by tag similarity and publishing date. The view constructs a context for rendering the template, including the detailed blog post and related/similar posts. Meta Information: The view sets up meta information for the page, including title, description, tags, and robot indexing instructions. It also sets an Open Graph (og) image for social media sharing. Usage Examples \u00b6 To view the details of a specific blog post, access the URL: /blog/my-blog-post/ The post_detail view provides users with a rich and engaging experience to explore the content of individual blog posts and discover related content. For more insights into how this view interacts with templates and how its features are utilized within the application, refer to the comments and docstrings within the source code. Contributing \u00b6 If you find any issues or have suggestions for improvements, feel free to open an issue or submit a pull request on the project's GitHub repository: https://github.com/yourusername/django-blog-app License \u00b6 This project is licensed under the MIT License - see the LICENSE file for details. Credits \u00b6 This app was developed with love by the Django community. Contact \u00b6 If you have any questions or need assistance, you can reach out to us at haradhan.sharma@gmail.com.","title":"Blog"},{"location":"blog.html#gfvp_blog_app","text":"","title":"GFVP Blog App"},{"location":"blog.html#introduction","text":"The GFVP Blog App is a simple yet powerful application that provides the foundation for creating and managing blog posts. This app allows you to easily create, edit, publish, and manage blog posts, while also providing a user-friendly interface for the admin panel.","title":"Introduction"},{"location":"blog.html#installation","text":"To use the Django Blog App in your project, follow these steps: Install the app using pip: .. code-block:: bash pip install .... Add 'blog' to the INSTALLED_APPS list in your project's settings.py : .. code-block:: python INSTALLED_APPS = [ # ... 'blog', # ... ] Include the app's URLs in your project's urls.py : .. code-block:: python from django.urls import path, include urlpatterns = [ # ... path('blog/', include('blog.urls')), # ... ]","title":"Installation"},{"location":"blog.html#usage","text":"Admin Panel: The Django Blog App provides an admin panel interface to manage blog posts easily. You can access the admin panel at /admin/ . In the admin panel, you can: Create, edit, and delete blog posts. Use the Summernote rich text editor to compose blog post content. Manage tags and categories associated with blog posts. Publish or draft blog posts. Filter and search for blog posts. Customization: The app is designed to be easily customizable to fit your project's specific needs. You can extend the BlogPost model or modify its behavior by creating your own customizations. For more information on how to customize and extend the app, refer to the official documentation.","title":"Usage"},{"location":"blog.html#models","text":"The Django Blog App includes two main models to manage blog posts and track actions on various objects. Action Model: The Action model tracks different actions performed on various objects. It's a generic model that can be used to record actions like views and likes on different content types. The key attributes of this model are: content_type : A ForeignKey to the ContentType model, representing the type of the content object. object_id : A PositiveIntegerField representing the ID of the content object. content_object : A GenericForeignKey that allows you to link to any object using the content_type and object_id . user : A ForeignKey to the user who performed the action (if authenticated), or None for anonymous users. ip_address : A GenericIPAddressField to store the IP address of the user performing the action. action_type : A CharField to store the type of action, such as 'view' or 'like'. timestamp : A DateTimeField representing the time the action was recorded. This model is designed to be versatile and can be easily extended to track other types of actions as well. BlogPost Model: The BlogPost model represents a blog post within the application. It includes fields to store information about the post's title, content, author, publishing status, and more. The main attributes of this model are: title : A CharField representing the title of the blog post. image : An ImageField to store the featured image of the post. slug : A SlugField to generate and store a URL-friendly slug for the post's URL. author : A ForeignKey to the user who authored the post. body : A TextField to store the content of the blog post. publish : A DateTimeField indicating the publication date and time of the post. created : A DateTimeField representing the creation date of the post. updated : A DateTimeField indicating the last update time of the post. status : A CharField indicating the publishing status of the post (draft or published). tags : A TaggableManager that allows you to associate tags with the post. actions : A GenericRelation to the Action model, enabling tracking of actions related to this post. Additionally, the BlogPost model includes custom methods to calculate the total number of views and record new views. The model also features a custom manager, PublishedManager , to retrieve only published posts. This combination of models provides a powerful foundation for creating and managing blog posts with customizable features and actions tracking.","title":"Models"},{"location":"blog.html#signals","text":"The Django Blog App uses signals to automate certain actions and tasks related to blog posts. Signals allow the app to respond to events like creating, updating, or deleting a blog post, and perform additional actions as needed. send_to_mail_queue Signal: The send_to_mail_queue signal handler is triggered after a BlogPost instance is saved. This signal is responsible for creating or updating BlogMailQueue entries based on the status and changes to the blog post. The key functionality includes: When a new BlogPost is created and its status is 'published', a BlogMailQueue entry will be created for each subscribed lead. If a BlogPost is updated and its status is changed to 'draft', any unprocessed BlogMailQueue entries related to that post will be deleted. If the status of an updated BlogPost is changed to 'published' and there are no existing BlogMailQueue entries, new entries will be created for each subscribed lead. delete_mail_queues Signal: The delete_mail_queues signal handler is triggered after a BlogPost instance is deleted. This signal is responsible for deleting any unprocessed BlogMailQueue entries related to the deleted blog post. To ensure these signals work correctly, the following components must be present: Import the necessary models at the beginning of the signal.py file. Set up appropriate logging to track the actions of the signals. Please note that signals can greatly enhance the automation and logic within your app, but it's important to use them judiciously and ensure they're thoroughly tested to avoid unintended consequences. For more information on how signals work in Django and how to handle them effectively, refer to the official Django documentation on signals.","title":"Signals"},{"location":"blog.html#url_patterns","text":"The Django Blog App uses URL patterns to define how different URLs should be handled and routed to specific views. URL patterns play a crucial role in determining how users can access various parts of your application. URL Configuration: In the urls.py file of the blog app, you will find a list of URL patterns defined using the path function. Each pattern consists of a URL route and a corresponding view function. The app_name is set to 'blog' to create a namespace for these URL patterns. URL Patterns Explained: blog/ : URL Route: blog/ View Function: views.post_list Name: post_list Description: This URL pattern maps to the post_list view, which displays a list of all blog posts. blog/<slug:post>/ : URL Route: blog/<slug:post>/ View Function: views.post_detail Name: post_detail Description: This URL pattern includes a slug parameter, which is used to identify a specific blog post. It maps to the post_detail view, showing the detailed view of the selected blog post. blog/tag/<slug:tag_slug>/ : URL Route: blog/tag/<slug:tag_slug>/ View Function: views.post_list Name: post_tag Description: This URL pattern includes a slug parameter ( tag_slug ), allowing users to view blog posts filtered by a specific tag. It maps to the post_list view, displaying posts associated with the selected tag. Namespace and Reversing: The app_name is set to 'blog', creating a namespace for these URL patterns. This namespace helps avoid naming conflicts and makes it easier to reverse URLs in templates and code using the app_name:pattern_name syntax. For example, to generate the URL for the post_detail view for a blog post with the slug 'my-blog-post', you can use {% url 'blog:post_detail' post='my-blog-post' %} in templates or reverse('blog:post_detail', args=['my-blog-post']) in Python code. Understanding and utilizing these URL patterns is crucial for ensuring smooth navigation and interaction within the Django Blog App. For more information on Django URL routing and reversing, refer to the official Django documentation on URL dispatch and URL reversing.","title":"URL Patterns"},{"location":"blog.html#view_post_list","text":"The post_list view function is responsible for displaying a list of blog posts on the website. This view supports various scenarios, such as showing all published posts, filtering posts by a specific tag, and providing search functionality.","title":"View: post_list"},{"location":"blog.html#view_details","text":"Function Signature: .. code-block:: python def post_list(request, tag_slug=None): Parameters: request (:class: ~django.http.request.HttpRequest ): The HTTP request object. tag_slug (:class: ~str , optional): An optional tag slug to filter posts by a specific tag. Functionality: This view handles the display of blog posts and supports filtering by tag and searching by query. It constructs a context for rendering the template, including the list of blog posts and other necessary data. If a tag_slug is provided in the URL, it filters posts tagged with the specified tag. If a search query ( q ) is present in the GET parameters, it filters posts based on the search query using Q objects for more advanced searches. The resulting list of posts is ordered by their update date and supports pagination. Stored Search Query: If a search query is provided, the view stores it in the user's session to pre-fill the search box when displaying the search results. The stored query is cleared from the session if there is no active search. Meta Information: The view also sets up meta information for the page, such as title, description, tags, and robot indexing instructions.","title":"View Details"},{"location":"blog.html#usage_examples","text":"To display all published blog posts, access the URL: /blog/ To view posts with a specific tag, access the URL: /blog/tag/tag-slug/ To search for specific terms within blog posts, add a search query to the URL: /blog/?q=search-term This view plays a central role in providing users with a curated list of blog posts and facilitates easy navigation and discovery. For more information on how this view is utilized within the application and its interaction with templates, please refer to the comments and docstrings within the source code.","title":"Usage Examples"},{"location":"blog.html#view_post_detail","text":"The post_detail view function is responsible for displaying a detailed view of a specific blog post on the website. This view provides users with comprehensive information about a single blog post, including related posts and meta information.","title":"View: post_detail"},{"location":"blog.html#view_details_1","text":"Function Signature: .. code-block:: python def post_detail(request, post): Parameters: request (:class: ~django.http.request.HttpRequest ): The HTTP request object. post (:class: ~str ): The slug of the specific blog post to display. Functionality: This view handles the detailed display of a specific blog post. It clears any stored search term in the session to ensure a clean user experience. If a search query ( q ) is present in the GET parameters, it stores the query in the session and redirects to the post_list view to display search results. The view retrieves the specific published blog post based on the provided slug. It records the view action for the blog post using the post.view() method. The view fetches similar posts based on shared tags, excluding the current post. These similar posts are ordered by tag similarity and publishing date. The view constructs a context for rendering the template, including the detailed blog post and related/similar posts. Meta Information: The view sets up meta information for the page, including title, description, tags, and robot indexing instructions. It also sets an Open Graph (og) image for social media sharing.","title":"View Details"},{"location":"blog.html#usage_examples_1","text":"To view the details of a specific blog post, access the URL: /blog/my-blog-post/ The post_detail view provides users with a rich and engaging experience to explore the content of individual blog posts and discover related content. For more insights into how this view interacts with templates and how its features are utilized within the application, refer to the comments and docstrings within the source code.","title":"Usage Examples"},{"location":"blog.html#contributing","text":"If you find any issues or have suggestions for improvements, feel free to open an issue or submit a pull request on the project's GitHub repository: https://github.com/yourusername/django-blog-app","title":"Contributing"},{"location":"blog.html#license","text":"This project is licensed under the MIT License - see the LICENSE file for details.","title":"License"},{"location":"blog.html#credits","text":"This app was developed with love by the Django community.","title":"Credits"},{"location":"blog.html#contact","text":"If you have any questions or need assistance, you can reach out to us at haradhan.sharma@gmail.com.","title":"Contact"},{"location":"crm.html","text":"============================= Django CRM App - admin.py ============================= Introduction \u00b6 Welcome to the Django CRM App! This README provides an overview of the admin.py file, explaining its role within the project. The admin.py file is an essential part of the app's functionality, as it customizes the Django admin interface for specific models. Purpose \u00b6 The admin.py File: ~~~~~~~~~~~~~~~~~~~~ The admin.py file in this app is responsible for configuring how certain models are displayed and managed within the Django admin panel. It leverages the Django admin site framework to provide an intuitive and user-friendly way for administrators to interact with the app's data. Contents \u00b6 The admin.py file contains the following sections: Model Registrations: The file uses the admin.site.register() function and decorator-based registration ( @admin.register(ModelName) ) to associate specific models with the admin site. Custom Admin Classes: Two custom admin classes, MailQueueAdmin and BlogMailQueueAdmin , are defined. These classes inherit from admin.ModelAdmin and customize the presentation and behavior of their respective models within the admin interface. list_display Attribute: Both custom admin classes define a list_display attribute. This attribute determines which fields of the model are shown in the list view of the admin interface. Usage \u00b6 To add or modify the behavior of models in the Django admin panel: Open the admin.py file located in your CRM app's directory. Locate the relevant model's admin class or create a new one if needed. Customize the list_display attribute to specify which fields should appear in the list view of the admin interface. Utilize other attributes and methods available in admin.ModelAdmin to further tailor the admin panel's behavior to your needs. The forms.py File: \u00b6 The forms.py file is responsible for defining custom form classes that facilitate user interactions with the Django CRM App. These forms are designed to collect and process data submitted by users through the app's interface. Contents \u00b6 The forms.py file contains the following form classes: UploadLead Form: Purpose: Allows users to upload lead data as a file. Form Field: lead_upload (FileField) for handling file uploads. Usage: Users can submit lead data files for processing within the app. SubscriberForm Form: Purpose: Collects information from users who wish to subscribe. Form Fields: name (CharField) for the subscriber's name, and email (EmailField) for the subscriber's email. Usage: Users can provide their name and email to subscribe to updates from the app. Usage \u00b6 To utilize the forms defined in forms.py within your Django CRM App: Open the forms.py file located in your app's directory. Review the available form classes, such as UploadLead and SubscriberForm . Integrate the desired form into your app's views or templates as needed. Leverage the fields and attributes provided by each form class to customize the form's appearance and behavior. The lead_mail_jobs.py File: \u00b6 Lead CRM App is a Django application designed to help manage customer leads and streamline email communication. Usage \u00b6 Email Queue Functions \u00b6 The lead_mail_jobs.py module provides several functions related to email queue management. These functions can be useful for handling email communication within your CRM app. last_process_time() Returns the time of the most recent email processing. ```python from lead_mail_jobs import last_process_time last_time = last_process_time() if last_time: print(\"Last email processing time:\", last_time) ``` total_mail_sent() Returns the total number of emails that have been processed. ```python from lead_mail_jobs import total_mail_sent total_sent = total_mail_sent() print(\"Total emails sent:\", total_sent) ``` pending_queue_count() Returns the number of emails pending in the queue. ```python from lead_mail_jobs import pending_queue_count pending_count = pending_queue_count() print(\"Pending emails in the queue:\", pending_count) ``` send_custom_mass_mail(datatuple, fail_silently=False, auth_user=None, auth_password=None, connection=None) Sends a batch of custom HTML emails using the provided data. Args: - datatuple : A list of tuples where each tuple contains subject, message, sender, and recipient information. - fail_silently : If True , exceptions during sending will be suppressed. Default is False . - auth_user : The username for email server authentication. Default is None . - auth_password : The password for email server authentication. Default is None . - connection : An existing email connection. If not provided, a new connection will be created. Returns: - int : The number of successfully sent emails. ```python from lead_mail_jobs import send_custom_mass_mail email_data = [ (\"Subject 1\", \" Message 1 \", \"sender@example.com\", \"recipient1@example.com\"), (\"Subject 2\", \" Message 2 \", \"sender@example.com\", \"recipient2@example.com\"), # ... ] sent_count = send_custom_mass_mail(email_data) print(\"Total emails sent:\", sent_count) ``` Sending Lead Emails \u00b6 The send_lead_mail() function in the lead_mail_jobs.py module is responsible for sending lead emails from the queue within the Lead CRM App. Function Overview \u00b6 This function performs the following tasks: Checks if it's time to send lead emails based on the last execution time. Retrieves a batch of pending emails from the MailQueue table. Constructs personalized email messages for each lead. Sends the emails in bulk to the corresponding recipients. Updates the queue for processed emails and handles problematic cases. Deletes emails that have been tried more than twice or are older than 90 days. Usage Example \u00b6 To use the send_lead_mail() function, follow these steps: Ensure you have imported necessary modules and models: python from lead_mail_jobs import send_lead_mail from lead.models import Lead, MailQueue from django.contrib.sites.models import Site from django.template.loader import render_to_string from django.utils import timezone from django.utils.safestring import mark_safe from django.conf import settings import logging Call the send_lead_mail() function: python total_sent = send_lead_mail() print(f\"Total lead emails sent: {total_sent}\") Configuration and Customization \u00b6 Before using the send_lead_mail() function, ensure you have the following set up correctly: Make sure your settings.py includes configurations for email sending, such as DEFAULT_FROM_EMAIL . Adjust the LEAD_MAIL_SEND_FROM_QUEUE_AT_A_TIME setting to control the number of emails sent in a batch. Customize the email content by modifying the template file emails/crm_initial_mail.html . Customize the subject line of the emails by modifying the subject variable. Cleanup and Error Handling \u00b6 The function handles cases where emails fail to send, and it removes emails from the queue if they have been tried more than twice or are older than 90 days. For any errors or exceptions encountered during the process, the function logs them using the logging module, ensuring you have appropriate logging configured. Remember to set up proper error handling and logging mechanisms in your project to handle unexpected scenarios. Feel free to adapt and integrate the send_lead_mail() function to your CRM app's requirements and workflows. If you encounter any issues or need further assistance, refer to the documentation or reach out to the development team for support. Sending Blog-related Emails \u00b6 The send_blog_mail() function within the lead_mail_jobs.py module is responsible for sending blog-related emails from the queue within the Lead CRM App. Function Overview \u00b6 This function handles the process of sending personalized emails to recipients based on blog posts. It performs the following tasks: Checks if it's time to send blog-related emails based on the last execution time. Retrieves a batch of pending emails from the BlogMailQueue table. Constructs personalized email messages for each recipient using blog post information. Sends the emails in bulk to the corresponding recipients. Updates the queue for processed emails and handles problematic cases. Deletes emails that have been tried more than twice or are older than 90 days. Usage Example \u00b6 To utilize the send_blog_mail() function, follow these steps: Ensure you have the necessary imports at the beginning of your script: python from lead_mail_jobs import send_blog_mail from lead.models import Lead, BlogMailQueue, BlogPost from lead.utils import site_info from django.core.mail import EmailMessage from django.template.loader import render_to_string from django.utils import timezone from django.utils.safestring import mark_safe from django.conf import settings from django.db.models import Count import logging Call the send_blog_mail() function: python total_sent = send_blog_mail() print(f\"Total blog-related emails sent: {total_sent}\") Configuration and Customization \u00b6 Before using the send_blog_mail() function, ensure you have the following configured correctly: Make sure your settings.py includes configurations for email sending, such as DEFAULT_FROM_EMAIL . Adjust the LEAD_MAIL_SEND_FROM_QUEUE_AT_A_TIME setting to control the number of emails sent in a batch. Customize the email content by modifying the template file emails/crm_blog_mail.html . Customize the subject line of the emails by modifying the subject variable. Adjust the logic inside the function to match your application's specific requirements. Cleanup and Error Handling \u00b6 The function handles cases where emails fail to send and removes emails from the queue if they have been tried more than twice or are older than 90 days. For any errors or exceptions encountered during the process, the function logs them using the logging module, ensuring you have appropriate logging configured. Remember to set up proper error handling and logging mechanisms in your project to handle unexpected scenarios. Feel free to adapt and integrate the send_blog_mail() function into your CRM app as needed. If you encounter any issues or need further assistance, refer to the documentation or reach out to the development team for support. Sending Report-related Emails \u00b6 The send_report_queue() function within the lead_mail_jobs.py module is responsible for sending report-related emails from the queue within the Lead CRM App. Function Overview \u00b6 This function handles the process of sending personalized emails to recipients based on report updates. It performs the following tasks: Checks if it's time to send report-related emails based on the last execution time. Retrieves a batch of pending emails from the ReportMailQueue table. Constructs personalized email messages for each recipient using report update information. Sends the emails in bulk to the corresponding recipients. Updates the queue for processed emails and handles problematic cases. Deletes emails that have been tried more than twice or are older than 90 days. Usage Example \u00b6 To utilize the send_report_queue() function, follow these steps: Ensure you have the necessary imports at the beginning of your script: python from lead_mail_jobs import send_report_queue from lead.models import ReportMailQueue from lead.utils import site_info from django.template.loader import render_to_string from django.utils import timezone from django.utils.safestring import mark_safe from django.conf import settings import logging Call the send_report_queue() function: python total_sent = send_report_queue() print(f\"Total report-related emails sent: {total_sent}\") Configuration and Customization \u00b6 Before using the send_report_queue() function, ensure you have the following configured correctly: Make sure your settings.py includes configurations for email sending, such as DEFAULT_FROM_EMAIL . Adjust the LEAD_MAIL_SEND_FROM_QUEUE_AT_A_TIME setting to control the number of emails sent in a batch. Customize the email content by modifying the template file emails/feedback_update.html . Adjust the logic inside the function to match your application's specific requirements. Cleanup and Error Handling \u00b6 The function handles cases where emails fail to send and removes emails from the queue if they have been tried more than twice or are older than 90 days. For any errors or exceptions encountered during the process, the function logs them using the logging module, ensuring you have appropriate logging configured. Remember to set up proper error handling and logging mechanisms in your project to handle unexpected scenarios. Feel free to adapt and integrate the send_report_queue() function into your CRM app as needed. If you encounter any issues or need further assistance, refer to the documentation or reach out to the development team for support. Sending New Fuel Report Notifications \u00b6 The send_new_report_notification() function is responsible for sending notifications to consumers for new fuel reports within the Lead CRM App. Function Overview \u00b6 This function handles the process of sending personalized email notifications to consumers based on new fuel report submissions. It performs the following tasks: Retrieves a batch of pending email notifications from the ConsumerMailQueue table. Constructs personalized notification messages for each recipient with information about the new fuel report. Sends the notification emails in bulk to the corresponding recipients. Updates the queue for processed notifications and handles cases where emails fail to send. Deletes old queue entries that have been tried more than twice or are older than 90 days. Usage Example \u00b6 To utilize the send_new_report_notification() function, follow these steps: Ensure you have the necessary imports at the beginning of your script: python from lead.models import ConsumerMailQueue from lead.utils import site_info, build_full_url from django.utils import timezone from django.conf import settings import logging from django.db.models import Q from lead.utils import send_custom_mass_mail Call the send_new_report_notification() function: python total_sent = send_new_report_notification() print(f\"Total new fuel report notifications sent: {total_sent}\") Configuration and Customization \u00b6 Before using the send_new_report_notification() function, ensure you have the following configured correctly: Make sure your settings.py includes configurations for email sending, such as DEFAULT_FROM_EMAIL . Adjust the LEAD_MAIL_SEND_FROM_QUEUE_AT_A_TIME setting to control the number of notifications sent in a batch. Customize the notification content within the function as needed. Adjust the logic inside the function to match your application's specific requirements. Cleanup and Error Handling \u00b6 The function handles cases where notifications fail to send and removes notifications from the queue if they have been tried more than twice or are older than 90 days. For any errors or exceptions encountered during the process, the function logs them using the logging module, ensuring you have appropriate logging configured. Remember to set up proper error handling and logging mechanisms in your project to handle unexpected scenarios. \u00b6 Sending Queued Mails in Bulk using Cron Job \u00b6 The SendQueueMail class extends the CronJobBase class from Django's django_cron module. This cron job is responsible for sending various types of queued mails in bulk at scheduled intervals. Cron Job Overview \u00b6 The SendQueueMail cron job handles the bulk sending of different types of queued mails, including lead mails, blog mails, and report mails. It ensures that queued mails are efficiently dispatched to their recipients while minimizing load and potential issues. Usage Example \u00b6 To use the SendQueueMail cron job, follow these steps: Import the necessary modules at the beginning of your script: python from django_cron import CronJobBase, Schedule from .lead_mail_jobs import send_lead_mail from .lead_mail_jobs import send_blog_mail from .lead_mail_jobs import send_report_queue import logging Define your SendQueueMail class, ensuring it extends CronJobBase : ```python class SendQueueMail(CronJobBase): RUN_EVERY_MINS = 5 RETRY_AFTER_FAILURE_MINS = 1 MIN_NUM_FAILURES = 2 ALLOW_PARALLEL_RUNS = True schedule = Schedule(run_every_mins=RUN_EVERY_MINS, retry_after_failure_mins=RETRY_AFTER_FAILURE_MINS) code = 'crm.send_queue_mail' def do(self): try: # Send lead mails total_lead_mails_sent = send_lead_mail() log.info(f'{total_lead_mails_sent} lead mail(s) have been sent') # Send blog mails total_blog_mails_sent = send_blog_mail() log.info(f'{total_blog_mails_sent} blog mail(s) have been sent') # Send report mails total_report_mails_sent = send_report_queue() log.info(f'{total_report_mails_sent} report mail(s) have been sent') # Send new report mails to consumer total_consumer_mail_sent = send_new_report_notification() log.info(f'{total_consumer_mail_sent} report mail(s) have been sent') except Exception as e: log.exception(f'An error occurred while sending queued mails: {e}') ``` Ensure you have the required logging configured to handle exceptions and logs effectively. Configuration and Customization \u00b6 The SendQueueMail cron job class can be customized to suit your application's requirements. You can adjust the RUN_EVERY_MINS value to set the frequency of the cron job execution. Additionally, you can modify the do() method to include any other types of queued mails or additional processing logic. Error Handling \u00b6 The cron job employs robust error handling mechanisms. In case of any exceptions during the execution of the cron job, it logs the error and provides details for troubleshooting. Feel free to incorporate the SendQueueMail cron job class into your CRM app's workflow to ensure efficient and timely delivery of queued mails. If you encounter any issues or need further assistance, refer to the documentation or reach out to the development team for support. Sending New Report Notifications \u00b6 The send_new_report_notification() function within the your_module.py module is responsible for sending notifications to consumers about new fuel reports within your application. Function Overview \u00b6 This function retrieves pending email notifications from the queue, constructs notification messages, and sends them to consumers. It also handles updating the queue and deleting old queue entries. Here's a brief overview of what it does: Retrieve Pending Emails : The function fetches pending email notifications from the queue that haven't been processed yet. Construct Messages : It constructs individual notification messages for each pending email, including information about the new fuel report and a link to it. Update Queue : The function updates the pending email records by incrementing the \"tried\" count, marking them as processed, and recording the process time. Send Emails : It sends the constructed notification emails to the respective consumers. Delete Old Entries : The function identifies and deletes old queue entries that meet specific conditions (e.g., tried more than twice or older than 90 days). Usage \u00b6 You can call this function as needed within your Django project, typically as part of a scheduled task using Django's built-in cron-like scheduler or a third-party package like django-cron . It helps ensure that consumers are notified about new fuel reports efficiently. ```python from your_module import send_new_report_notification Call the function to send new report notifications \u00b6 total_sent = send_new_report_notification() Deleting Incomplete Reports using Cron Job \u00b6 The DeleteIncompleteReports class extends the CronJobBase class from Django's django_cron module. This cron job is responsible for periodically deleting incomplete reports from the system. Cron Job Overview \u00b6 The DeleteIncompleteReports cron job ensures that incomplete reports are regularly cleaned up from the system to maintain data accuracy and prevent unnecessary clutter. It uses the clear_evaluator utility function to identify and remove incomplete reports. Usage Example \u00b6 To use the DeleteIncompleteReports cron job, follow these steps: Import the necessary modules at the beginning of your script: python from django_cron import CronJobBase, Schedule from .report_utilities import clear_evaluator # Import the appropriate utility function import logging Define your DeleteIncompleteReports class, ensuring it extends CronJobBase : ```python class DeleteIncompleteReports(CronJobBase): RUN_EVERY_MINS = 5 RETRY_AFTER_FAILURE_MINS = 1 MIN_NUM_FAILURES = 2 ALLOW_PARALLEL_RUNS = True schedule = Schedule(run_every_mins=RUN_EVERY_MINS, retry_after_failure_mins=RETRY_AFTER_FAILURE_MINS) code = 'crm.delete_incomplete_reports' def do(self): try: deleted_count = clear_evaluator() log.info(f'{deleted_count} incomplete report(s) have been deleted') except Exception as e: log.exception(f'An error occurred while deleting incomplete reports: {e}') ``` Ensure you have the required logging configured to handle exceptions and logs effectively. Configuration and Customization \u00b6 The DeleteIncompleteReports cron job class can be customized to suit your application's requirements. You can adjust the RUN_EVERY_MINS value to set the frequency of the cron job execution. Additionally, you can modify the do() method to include any other cleanup logic. Error Handling \u00b6 The cron job employs robust error handling mechanisms. In case of any exceptions during the execution of the cron job, it logs the error and provides details for troubleshooting. Utilize the DeleteIncompleteReports cron job class to automatically maintain a clean and accurate system by regularly removing incomplete reports. If you encounter any issues or need further assistance, refer to the documentation or reach out to the development team for support. URL Patterns in the CRM App \u00b6 The urls.py file in the CRM app defines URL patterns that map specific URLs to their corresponding views. This allows users to access different parts of the CRM application through their web browser. URL Patterns Overview \u00b6 The URL patterns are defined using Django's path() function, which maps a URL to a view function. Each URL pattern has a unique identifier called the name , which can be used to generate URLs in templates. URL Definitions \u00b6 The urls.py file includes the following URL patterns: Leads View ( leads ): URL: /crm/leads View: leads function Purpose: Displays content related to leads in the CRM. Unsubscribe View ( unsubscrib ): URL: /crm/unsubscrib/<email>/<code> View: unsubscrib function Parameters: email (email address of the subscriber), code (unsubscribe code) Purpose: Handles email unsubscription for a specific email address. Subscribe View ( subscrib ): URL: /crm/subscrib/<str:email> View: subscrib function Parameter: email (email address of the subscriber) Purpose: Handles email subscription for a specific email address. Subscription View ( subscription ): URL: /crm/subscription View: subscription function Purpose: Displays content related to email subscription. Usage Example \u00b6 To access the different parts of the CRM application, users can use the defined URLs. For example: - To view leads: /crm/leads - To unsubscribe: /crm/unsubscrib/user@example.com/abcdef123456 - To subscribe: /crm/subscrib/user@example.com - To manage subscriptions: /crm/subscription Customization and Extension \u00b6 You can customize the URL patterns to match your application's requirements. Add new URL patterns and map them to appropriate views as needed. Make sure to update the views.py file with the corresponding view functions. URL Naming and Templates \u00b6 Utilize the name parameter in URL patterns to generate URLs dynamically in templates using the {% url %} template tag. This ensures consistent and accurate URL generation throughout your application. The URL patterns defined in the urls.py file enable users to access various features and functionalities of the CRM app. If you encounter any issues or need further assistance, refer to the documentation or reach out to the development team for support. Models in the CRM App \u00b6 The models.py file in the CRM app defines the database models used to store and manage various types of data within the application. These models represent key entities and relationships in the CRM system. Model Overview \u00b6 The models.py file includes the following models: Lead Model : Represents leads in the CRM. Fields: lead , email_address , phone , address_1 , address_2 , city , country , subscribed , confirm_code . Purpose: Stores lead information such as name, email address, contact details, address, and subscription status. MailQueue Model : Represents queued emails in the CRM. Fields: to , added_at , processed , process_time , tried . Purpose: Stores information about emails in the queue, including recipient, timestamp, processing status, and retry count. BlogMailQueue Model : Represents queued emails related to blog posts. Fields: to , blog , added_at , processed , process_time , tried . Purpose: Stores information about emails in the queue related to blog posts, including recipient, associated blog post, and processing details. Model Details \u00b6 Each model defines its fields, data types, and relationships. The models capture important information about leads, queued emails, and blog-related emails. Usage Example \u00b6 To work with the models, you can use Django's Object-Relational Mapping (ORM) features. Here's an example of how you might create a new lead: ```python from crm.models import Lead new_lead = Lead.objects.create( lead='John Doe', email_address='john@example.com', phone='123-456-7890', city='New York', country='US', subscribed=True ) ``` Customization and Extension \u00b6 You can customize the models to match your application's requirements. Add new fields or methods to capture additional data or functionality as needed. Database Synchronization \u00b6 After defining or modifying models, make sure to run database migrations using the makemigrations and migrate commands to keep your database schema up-to-date. The models defined in the models.py file enable structured storage and management of leads, queued emails, and blog-related email queues. Refer to the documentation for details on using and customizing these models, and feel free to reach out to the development team for assistance. Helper Function: get_ip(request) \u00b6 The get_ip function in the views.py file is a utility function designed to retrieve the IP address of a user from an incoming HTTP request. This function is particularly useful for tracking user IP addresses in your application for various purposes, such as analytics, security, and customization. Function Overview \u00b6 The get_ip function attempts to extract the user's IP address from various headers present in the HTTP request. It prioritizes headers known to contain the real client IP address, and if none of those headers are present, it falls back to using the REMOTE_ADDR field from the request's META dictionary. Function Signature \u00b6 ```python def get_ip(request: HttpRequest) -> str: \"\"\" Get the user's IP address from the request. Args: request (HttpRequest): The HTTP request object. Returns: str: The user's IP address. \"\"\" ``` Header Priority and Fallback \u00b6 The function iterates through multiple headers, including HTTP_X_FORWARDED_FOR , HTTP_CLIENT_IP , HTTP_X_REAL_IP , and more, to ensure it captures the actual client IP. If none of these headers contain a valid IP, the function resorts to using the REMOTE_ADDR field, which typically stores the user's IP address. Usage Example \u00b6 You can use the get_ip function in your views to track and record the IP addresses of users interacting with your application. For example: python def my_view(request): user_ip = get_ip(request) # Process and record user IP as neededr: The user's IP address. \"\"\" Customization and Extensions \u00b6 Feel free to modify the get_ip function to suit your application's specific requirements. You can add additional header checks or adapt the function to work with different proxy configurations if necessary. The get_ip function simplifies the process of obtaining the user's IP address from an HTTP request, offering flexibility and ease for IP-related operations within your CRM application. Refer to the documentation for more details on its implementation and usage. Function: get_location_info(request) \u00b6 The get_location_info function in the views.py file retrieves location information based on the user's IP address. This function utilizes the user's IP address, obtained through the get_ip function, to query the IPinfo database. The function then extracts details such as the user's city, region, country, and more. Function Overview \u00b6 The get_location_info function takes an HTTP request object as an argument. It uses the get_ip function to retrieve the user's IP address, and then constructs an API URL using the IP address and an API token provided in the settings. The function sends an HTTP request to the IPinfo API and processes the response JSON to extract relevant location data. Function Signature \u00b6 ```python def get_location_info(request: HttpRequest) -> dict: \"\"\" Get location information based on the user's IP address. Args: request (HttpRequest): The HTTP request object. Returns: dict: Location-related information obtained from the IPinfo database. \"\"\" ``` API Response Handling \u00b6 The function checks the HTTP response status code to ensure a successful API call (HTTP status code 200, IPINFO.io token is require). If the response code is 200, the function parses the JSON response and updates the data dictionary with location information. If the response code is not 200, the function logs an error. Usage Example \u00b6 You can use the get_location_info function to enhance user experiences based on their geographical location: python def my_view(request): location_data = get_location_info(request) # Process and utilize location data as needed Customization and Extensions \u00b6 The function relies on the get_ip function to retrieve IP addresses. To customize or extend functionality, consider modifying the API request URL or handling additional API response details. The get_location_info function provides a convenient way to obtain user location information based on their IP address, enabling personalized experiences and insights in your CRM application. Refer to the documentation for more details on its implementation and utilization. Function: subscription(request) \u00b6 The subscription function in the views.py file handles user subscription requests for newsletters. This function validates the provided name and email address, performs checks on existing subscriptions, sends confirmation emails, and returns appropriate responses to the user. Function Overview \u00b6 The subscription function takes an HTTP request object as an argument. It primarily processes POST requests containing subscription form data. The function follows these steps: 1. Validates the form data submitted by the user. 2. Checks if the provided email address already exists in the Lead database. 3. Sends a confirmation email for subscription or informs the user if the email is already subscribed. 4. Creates a new Lead entry and sends a confirmation email if the email is not found in the database. Function Signature \u00b6 ```python def subscription(request: HttpRequest) -> HttpResponse: \"\"\" Process subscription requests and send confirmation emails. Args: request (HttpRequest): The HTTP request object. Returns: HttpResponse: A response indicating the result of the subscription attempt. \"\"\" ``` Subscription Workflow \u00b6 When a user submits the subscription form, the function checks if the submitted data is valid. 1. If the email address already exists in the Lead database: 2. If the email is subscribed, an error message is returned, indicating that the email is already subscribed. 3. If the email is not subscribed, a confirmation email is sent to the user. 4. If the email address is not found in the database, a new Lead entry is created with the provided name, email address, and location information. A confirmation email is then sent. Usage Example \u00b6 You can use the subscription function to handle user subscription requests in your views: python def my_view(request): if request.method == 'POST': return subscription(request) else: # Handle GET requests or other logic Customization and Extensions \u00b6 This function relies on the Lead model and the SubscriberForm form for data management and validation. You can customize the email templates, modify the subscription workflow, or integrate additional functionality as per your application's requirements. The subscription function streamlines the subscription process for newsletters, providing a user-friendly experience by sending confirmation emails and managing user data. Refer to the documentation for more details on its implementation and utilization. Function: leads(request) \u00b6 The leads function in the views.py file handles the display and management of leads within the CRM system. It allows for lead deletion, adding leads to the mail queue for later sending, and uploading leads through a CSV file. The function also implements lead pagination and provides associated documentation. Function Overview \u00b6 The leads function requires user authentication and staff permissions to access. It processes both GET and POST requests and offers the following features: - Displaying and managing leads in the CRM system. - Deleting selected leads. - Adding selected leads to the mail queue for sending later. - Uploading leads through a CSV file. Function Signature \u00b6 ```python @login_required @staff_member_required def leads(request: HttpRequest) -> HttpResponse: \"\"\" Display and manage leads for the CRM. Args: request (HttpRequest): The HTTP request object. Returns: HttpResponse: A rendered HTML template with lead data and related information. \"\"\" ``` Lead Management Workflow \u00b6 Display the list of leads paginated in groups of 50 per page. Process POST requests: Delete selected leads using bulk delete. Add selected leads to the mail queue for later sending. Upload leads from a CSV file, processing and validating each entry. ##### Lead Management Features - Deleting Leads: Selecting leads and clicking the \"Delete\" button removes the selected leads from the CRM. - Adding to Mail Queue: Selecting leads and clicking the \"Mail Lead\" button adds them to the mail queue for later sending. Only subscribed leads are added. - Uploading Leads: Uploading a CSV file containing lead information adds the leads to the CRM. Errors during upload are reported. ##### Pagination and Meta Information The function uses pagination to display leads, with 50 leads per page. It also provides meta information for the page, such as title, description, tag, and robots directives. ##### Customization and Extensions This function interacts with the Lead model, supporting lead management and data storage. You can customize templates, modify lead management workflows, and integrate additional features based on your application's requirements. The leads function offers a comprehensive interface for lead management within the CRM. It empowers users to manage leads, perform bulk actions, and upload leads through CSV files. Refer to the documentation for more details on its implementation and utilization. Unsubscribe Function \u00b6 This function handles the process of unsubscribing a lead from receiving further CRM emails. When users click on the unsubscribe link sent in emails, they are directed to this view to complete the unsubscription process. Purpose \u00b6 The purpose of this view is to allow users to opt-out of receiving CRM emails by unsubscribing. It verifies the provided email and confirmation code against the Lead model to ensure the legitimacy of the unsubscription request. Functionality \u00b6 When a user accesses the unsubscribe link with their email and confirmation code, the function performs the following steps: Extracts the email and confirmation code from the URL parameters. Attempts to locate a lead in the Lead model with the provided email and code. If a valid lead is found, it sets the subscribed field of the lead to False , marking them as unsubscribed. Logs the action, indicating that the lead has been successfully unsubscribed. If the provided email or code is invalid, it displays a warning message and redirects the user to the home page. Usage \u00b6 To unsubscribe from CRM emails, users can click on the unsubscribe link provided in the emails they receive. They will be directed to this view, where the provided email and code will be verified, and their subscription status will be updated accordingly. Parameters \u00b6 request (HttpRequest): The HTTP request object. **kwargs : Keyword arguments containing 'email' and 'code' from the URL. Returns \u00b6 HttpResponse : A rendered HTML template confirming the unsubscribed status for the lead, or an error message if the email or code is invalid. Example \u00b6 ```python # Unsubscribe link in email: # http://example.com/crm/unsubscrib/john@example.com/abc123 # URL Parameters: email='john@example.com', code='abc123' def unsubscrib(request, **kwargs): # ... (Function implementation) ``` subscrib(request, **kwargs) \u00b6 This view handles the confirmation of a lead's subscription to the CRM system. It is accessed via a confirmation link sent in subscription emails. Arguments \u00b6 request (HttpRequest): The HTTP request object. **kwargs : Keyword arguments containing the 'email' parameter from the URL. Functionality \u00b6 When a lead clicks on the subscription confirmation link sent to their email, this function is triggered. It confirms their subscription to the CRM system by updating the 'subscribed' field of the lead's record in the database. If the lead's email is successfully confirmed, a success template is displayed to acknowledge the subscription. If the email is not found or any errors occur, an appropriate error message is displayed. Usage \u00b6 ```python def subscrib(request, **kwargs): \"\"\" Confirm Subscription Function This view handles the confirmation of a lead's subscription to the CRM. It is accessed via a confirmation link sent in emails. Args: request (HttpRequest): The HTTP request object. **kwargs: Keyword arguments containing 'email' from the URL. Returns: HttpResponse: A rendered HTML template confirming the subscription status for the lead or an error message if the email is invalid. \"\"\" # ... (implementation details) ``` Contributions \u00b6 If you're a developer working on this project, feel free to expand or modify the admin.py file to meet the evolving requirements of the CRM app. Don't forget to maintain clear code documentation, such as comments and docstrings, to help future developers understand your changes. By working collaboratively, we can enhance the app's functionality and user experience while maintaining code quality. For additional information or assistance, please refer to the project documentation or reach out to the development team. Happy coding!","title":"CRM"},{"location":"crm.html#introduction","text":"Welcome to the Django CRM App! This README provides an overview of the admin.py file, explaining its role within the project. The admin.py file is an essential part of the app's functionality, as it customizes the Django admin interface for specific models.","title":"Introduction"},{"location":"crm.html#purpose","text":"The admin.py File: ~~~~~~~~~~~~~~~~~~~~ The admin.py file in this app is responsible for configuring how certain models are displayed and managed within the Django admin panel. It leverages the Django admin site framework to provide an intuitive and user-friendly way for administrators to interact with the app's data.","title":"Purpose"},{"location":"crm.html#contents","text":"The admin.py file contains the following sections: Model Registrations: The file uses the admin.site.register() function and decorator-based registration ( @admin.register(ModelName) ) to associate specific models with the admin site. Custom Admin Classes: Two custom admin classes, MailQueueAdmin and BlogMailQueueAdmin , are defined. These classes inherit from admin.ModelAdmin and customize the presentation and behavior of their respective models within the admin interface. list_display Attribute: Both custom admin classes define a list_display attribute. This attribute determines which fields of the model are shown in the list view of the admin interface.","title":"Contents"},{"location":"crm.html#usage","text":"To add or modify the behavior of models in the Django admin panel: Open the admin.py file located in your CRM app's directory. Locate the relevant model's admin class or create a new one if needed. Customize the list_display attribute to specify which fields should appear in the list view of the admin interface. Utilize other attributes and methods available in admin.ModelAdmin to further tailor the admin panel's behavior to your needs.","title":"Usage"},{"location":"crm.html#the_formspy_file","text":"The forms.py file is responsible for defining custom form classes that facilitate user interactions with the Django CRM App. These forms are designed to collect and process data submitted by users through the app's interface.","title":"The forms.py File:"},{"location":"crm.html#contents_1","text":"The forms.py file contains the following form classes: UploadLead Form: Purpose: Allows users to upload lead data as a file. Form Field: lead_upload (FileField) for handling file uploads. Usage: Users can submit lead data files for processing within the app. SubscriberForm Form: Purpose: Collects information from users who wish to subscribe. Form Fields: name (CharField) for the subscriber's name, and email (EmailField) for the subscriber's email. Usage: Users can provide their name and email to subscribe to updates from the app.","title":"Contents"},{"location":"crm.html#usage_1","text":"To utilize the forms defined in forms.py within your Django CRM App: Open the forms.py file located in your app's directory. Review the available form classes, such as UploadLead and SubscriberForm . Integrate the desired form into your app's views or templates as needed. Leverage the fields and attributes provided by each form class to customize the form's appearance and behavior.","title":"Usage"},{"location":"crm.html#the_lead_mail_jobspy_file","text":"Lead CRM App is a Django application designed to help manage customer leads and streamline email communication.","title":"The lead_mail_jobs.py File:"},{"location":"crm.html#usage_2","text":"","title":"Usage"},{"location":"crm.html#email_queue_functions","text":"The lead_mail_jobs.py module provides several functions related to email queue management. These functions can be useful for handling email communication within your CRM app. last_process_time() Returns the time of the most recent email processing. ```python from lead_mail_jobs import last_process_time last_time = last_process_time() if last_time: print(\"Last email processing time:\", last_time) ``` total_mail_sent() Returns the total number of emails that have been processed. ```python from lead_mail_jobs import total_mail_sent total_sent = total_mail_sent() print(\"Total emails sent:\", total_sent) ``` pending_queue_count() Returns the number of emails pending in the queue. ```python from lead_mail_jobs import pending_queue_count pending_count = pending_queue_count() print(\"Pending emails in the queue:\", pending_count) ``` send_custom_mass_mail(datatuple, fail_silently=False, auth_user=None, auth_password=None, connection=None) Sends a batch of custom HTML emails using the provided data. Args: - datatuple : A list of tuples where each tuple contains subject, message, sender, and recipient information. - fail_silently : If True , exceptions during sending will be suppressed. Default is False . - auth_user : The username for email server authentication. Default is None . - auth_password : The password for email server authentication. Default is None . - connection : An existing email connection. If not provided, a new connection will be created. Returns: - int : The number of successfully sent emails. ```python from lead_mail_jobs import send_custom_mass_mail email_data = [ (\"Subject 1\", \" Message 1 \", \"sender@example.com\", \"recipient1@example.com\"), (\"Subject 2\", \" Message 2 \", \"sender@example.com\", \"recipient2@example.com\"), # ... ] sent_count = send_custom_mass_mail(email_data) print(\"Total emails sent:\", sent_count) ```","title":"Email Queue Functions"},{"location":"crm.html#sending_lead_emails","text":"The send_lead_mail() function in the lead_mail_jobs.py module is responsible for sending lead emails from the queue within the Lead CRM App.","title":"Sending Lead Emails"},{"location":"crm.html#function_overview","text":"This function performs the following tasks: Checks if it's time to send lead emails based on the last execution time. Retrieves a batch of pending emails from the MailQueue table. Constructs personalized email messages for each lead. Sends the emails in bulk to the corresponding recipients. Updates the queue for processed emails and handles problematic cases. Deletes emails that have been tried more than twice or are older than 90 days.","title":"Function Overview"},{"location":"crm.html#usage_example","text":"To use the send_lead_mail() function, follow these steps: Ensure you have imported necessary modules and models: python from lead_mail_jobs import send_lead_mail from lead.models import Lead, MailQueue from django.contrib.sites.models import Site from django.template.loader import render_to_string from django.utils import timezone from django.utils.safestring import mark_safe from django.conf import settings import logging Call the send_lead_mail() function: python total_sent = send_lead_mail() print(f\"Total lead emails sent: {total_sent}\")","title":"Usage Example"},{"location":"crm.html#configuration_and_customization","text":"Before using the send_lead_mail() function, ensure you have the following set up correctly: Make sure your settings.py includes configurations for email sending, such as DEFAULT_FROM_EMAIL . Adjust the LEAD_MAIL_SEND_FROM_QUEUE_AT_A_TIME setting to control the number of emails sent in a batch. Customize the email content by modifying the template file emails/crm_initial_mail.html . Customize the subject line of the emails by modifying the subject variable.","title":"Configuration and Customization"},{"location":"crm.html#cleanup_and_error_handling","text":"The function handles cases where emails fail to send, and it removes emails from the queue if they have been tried more than twice or are older than 90 days. For any errors or exceptions encountered during the process, the function logs them using the logging module, ensuring you have appropriate logging configured. Remember to set up proper error handling and logging mechanisms in your project to handle unexpected scenarios. Feel free to adapt and integrate the send_lead_mail() function to your CRM app's requirements and workflows. If you encounter any issues or need further assistance, refer to the documentation or reach out to the development team for support.","title":"Cleanup and Error Handling"},{"location":"crm.html#sending_blog-related_emails","text":"The send_blog_mail() function within the lead_mail_jobs.py module is responsible for sending blog-related emails from the queue within the Lead CRM App.","title":"Sending Blog-related Emails"},{"location":"crm.html#function_overview_1","text":"This function handles the process of sending personalized emails to recipients based on blog posts. It performs the following tasks: Checks if it's time to send blog-related emails based on the last execution time. Retrieves a batch of pending emails from the BlogMailQueue table. Constructs personalized email messages for each recipient using blog post information. Sends the emails in bulk to the corresponding recipients. Updates the queue for processed emails and handles problematic cases. Deletes emails that have been tried more than twice or are older than 90 days.","title":"Function Overview"},{"location":"crm.html#usage_example_1","text":"To utilize the send_blog_mail() function, follow these steps: Ensure you have the necessary imports at the beginning of your script: python from lead_mail_jobs import send_blog_mail from lead.models import Lead, BlogMailQueue, BlogPost from lead.utils import site_info from django.core.mail import EmailMessage from django.template.loader import render_to_string from django.utils import timezone from django.utils.safestring import mark_safe from django.conf import settings from django.db.models import Count import logging Call the send_blog_mail() function: python total_sent = send_blog_mail() print(f\"Total blog-related emails sent: {total_sent}\")","title":"Usage Example"},{"location":"crm.html#configuration_and_customization_1","text":"Before using the send_blog_mail() function, ensure you have the following configured correctly: Make sure your settings.py includes configurations for email sending, such as DEFAULT_FROM_EMAIL . Adjust the LEAD_MAIL_SEND_FROM_QUEUE_AT_A_TIME setting to control the number of emails sent in a batch. Customize the email content by modifying the template file emails/crm_blog_mail.html . Customize the subject line of the emails by modifying the subject variable. Adjust the logic inside the function to match your application's specific requirements.","title":"Configuration and Customization"},{"location":"crm.html#cleanup_and_error_handling_1","text":"The function handles cases where emails fail to send and removes emails from the queue if they have been tried more than twice or are older than 90 days. For any errors or exceptions encountered during the process, the function logs them using the logging module, ensuring you have appropriate logging configured. Remember to set up proper error handling and logging mechanisms in your project to handle unexpected scenarios. Feel free to adapt and integrate the send_blog_mail() function into your CRM app as needed. If you encounter any issues or need further assistance, refer to the documentation or reach out to the development team for support.","title":"Cleanup and Error Handling"},{"location":"crm.html#sending_report-related_emails","text":"The send_report_queue() function within the lead_mail_jobs.py module is responsible for sending report-related emails from the queue within the Lead CRM App.","title":"Sending Report-related Emails"},{"location":"crm.html#function_overview_2","text":"This function handles the process of sending personalized emails to recipients based on report updates. It performs the following tasks: Checks if it's time to send report-related emails based on the last execution time. Retrieves a batch of pending emails from the ReportMailQueue table. Constructs personalized email messages for each recipient using report update information. Sends the emails in bulk to the corresponding recipients. Updates the queue for processed emails and handles problematic cases. Deletes emails that have been tried more than twice or are older than 90 days.","title":"Function Overview"},{"location":"crm.html#usage_example_2","text":"To utilize the send_report_queue() function, follow these steps: Ensure you have the necessary imports at the beginning of your script: python from lead_mail_jobs import send_report_queue from lead.models import ReportMailQueue from lead.utils import site_info from django.template.loader import render_to_string from django.utils import timezone from django.utils.safestring import mark_safe from django.conf import settings import logging Call the send_report_queue() function: python total_sent = send_report_queue() print(f\"Total report-related emails sent: {total_sent}\")","title":"Usage Example"},{"location":"crm.html#configuration_and_customization_2","text":"Before using the send_report_queue() function, ensure you have the following configured correctly: Make sure your settings.py includes configurations for email sending, such as DEFAULT_FROM_EMAIL . Adjust the LEAD_MAIL_SEND_FROM_QUEUE_AT_A_TIME setting to control the number of emails sent in a batch. Customize the email content by modifying the template file emails/feedback_update.html . Adjust the logic inside the function to match your application's specific requirements.","title":"Configuration and Customization"},{"location":"crm.html#cleanup_and_error_handling_2","text":"The function handles cases where emails fail to send and removes emails from the queue if they have been tried more than twice or are older than 90 days. For any errors or exceptions encountered during the process, the function logs them using the logging module, ensuring you have appropriate logging configured. Remember to set up proper error handling and logging mechanisms in your project to handle unexpected scenarios. Feel free to adapt and integrate the send_report_queue() function into your CRM app as needed. If you encounter any issues or need further assistance, refer to the documentation or reach out to the development team for support.","title":"Cleanup and Error Handling"},{"location":"crm.html#sending_new_fuel_report_notifications","text":"The send_new_report_notification() function is responsible for sending notifications to consumers for new fuel reports within the Lead CRM App.","title":"Sending New Fuel Report Notifications"},{"location":"crm.html#function_overview_3","text":"This function handles the process of sending personalized email notifications to consumers based on new fuel report submissions. It performs the following tasks: Retrieves a batch of pending email notifications from the ConsumerMailQueue table. Constructs personalized notification messages for each recipient with information about the new fuel report. Sends the notification emails in bulk to the corresponding recipients. Updates the queue for processed notifications and handles cases where emails fail to send. Deletes old queue entries that have been tried more than twice or are older than 90 days.","title":"Function Overview"},{"location":"crm.html#usage_example_3","text":"To utilize the send_new_report_notification() function, follow these steps: Ensure you have the necessary imports at the beginning of your script: python from lead.models import ConsumerMailQueue from lead.utils import site_info, build_full_url from django.utils import timezone from django.conf import settings import logging from django.db.models import Q from lead.utils import send_custom_mass_mail Call the send_new_report_notification() function: python total_sent = send_new_report_notification() print(f\"Total new fuel report notifications sent: {total_sent}\")","title":"Usage Example"},{"location":"crm.html#configuration_and_customization_3","text":"Before using the send_new_report_notification() function, ensure you have the following configured correctly: Make sure your settings.py includes configurations for email sending, such as DEFAULT_FROM_EMAIL . Adjust the LEAD_MAIL_SEND_FROM_QUEUE_AT_A_TIME setting to control the number of notifications sent in a batch. Customize the notification content within the function as needed. Adjust the logic inside the function to match your application's specific requirements.","title":"Configuration and Customization"},{"location":"crm.html#cleanup_and_error_handling_3","text":"The function handles cases where notifications fail to send and removes notifications from the queue if they have been tried more than twice or are older than 90 days. For any errors or exceptions encountered during the process, the function logs them using the logging module, ensuring you have appropriate logging configured.","title":"Cleanup and Error Handling"},{"location":"crm.html#remember_to_set_up_proper_error_handling_and_logging_mechanisms_in_your_project_to_handle_unexpected_scenarios","text":"","title":"Remember to set up proper error handling and logging mechanisms in your project to handle unexpected scenarios."},{"location":"crm.html#sending_queued_mails_in_bulk_using_cron_job","text":"The SendQueueMail class extends the CronJobBase class from Django's django_cron module. This cron job is responsible for sending various types of queued mails in bulk at scheduled intervals.","title":"Sending Queued Mails in Bulk using Cron Job"},{"location":"crm.html#cron_job_overview","text":"The SendQueueMail cron job handles the bulk sending of different types of queued mails, including lead mails, blog mails, and report mails. It ensures that queued mails are efficiently dispatched to their recipients while minimizing load and potential issues.","title":"Cron Job Overview"},{"location":"crm.html#usage_example_4","text":"To use the SendQueueMail cron job, follow these steps: Import the necessary modules at the beginning of your script: python from django_cron import CronJobBase, Schedule from .lead_mail_jobs import send_lead_mail from .lead_mail_jobs import send_blog_mail from .lead_mail_jobs import send_report_queue import logging Define your SendQueueMail class, ensuring it extends CronJobBase : ```python class SendQueueMail(CronJobBase): RUN_EVERY_MINS = 5 RETRY_AFTER_FAILURE_MINS = 1 MIN_NUM_FAILURES = 2 ALLOW_PARALLEL_RUNS = True schedule = Schedule(run_every_mins=RUN_EVERY_MINS, retry_after_failure_mins=RETRY_AFTER_FAILURE_MINS) code = 'crm.send_queue_mail' def do(self): try: # Send lead mails total_lead_mails_sent = send_lead_mail() log.info(f'{total_lead_mails_sent} lead mail(s) have been sent') # Send blog mails total_blog_mails_sent = send_blog_mail() log.info(f'{total_blog_mails_sent} blog mail(s) have been sent') # Send report mails total_report_mails_sent = send_report_queue() log.info(f'{total_report_mails_sent} report mail(s) have been sent') # Send new report mails to consumer total_consumer_mail_sent = send_new_report_notification() log.info(f'{total_consumer_mail_sent} report mail(s) have been sent') except Exception as e: log.exception(f'An error occurred while sending queued mails: {e}') ``` Ensure you have the required logging configured to handle exceptions and logs effectively.","title":"Usage Example"},{"location":"crm.html#configuration_and_customization_4","text":"The SendQueueMail cron job class can be customized to suit your application's requirements. You can adjust the RUN_EVERY_MINS value to set the frequency of the cron job execution. Additionally, you can modify the do() method to include any other types of queued mails or additional processing logic.","title":"Configuration and Customization"},{"location":"crm.html#error_handling","text":"The cron job employs robust error handling mechanisms. In case of any exceptions during the execution of the cron job, it logs the error and provides details for troubleshooting. Feel free to incorporate the SendQueueMail cron job class into your CRM app's workflow to ensure efficient and timely delivery of queued mails. If you encounter any issues or need further assistance, refer to the documentation or reach out to the development team for support.","title":"Error Handling"},{"location":"crm.html#sending_new_report_notifications","text":"The send_new_report_notification() function within the your_module.py module is responsible for sending notifications to consumers about new fuel reports within your application.","title":"Sending New Report Notifications"},{"location":"crm.html#function_overview_4","text":"This function retrieves pending email notifications from the queue, constructs notification messages, and sends them to consumers. It also handles updating the queue and deleting old queue entries. Here's a brief overview of what it does: Retrieve Pending Emails : The function fetches pending email notifications from the queue that haven't been processed yet. Construct Messages : It constructs individual notification messages for each pending email, including information about the new fuel report and a link to it. Update Queue : The function updates the pending email records by incrementing the \"tried\" count, marking them as processed, and recording the process time. Send Emails : It sends the constructed notification emails to the respective consumers. Delete Old Entries : The function identifies and deletes old queue entries that meet specific conditions (e.g., tried more than twice or older than 90 days).","title":"Function Overview"},{"location":"crm.html#usage_3","text":"You can call this function as needed within your Django project, typically as part of a scheduled task using Django's built-in cron-like scheduler or a third-party package like django-cron . It helps ensure that consumers are notified about new fuel reports efficiently. ```python from your_module import send_new_report_notification","title":"Usage"},{"location":"crm.html#call_the_function_to_send_new_report_notifications","text":"total_sent = send_new_report_notification()","title":"Call the function to send new report notifications"},{"location":"crm.html#deleting_incomplete_reports_using_cron_job","text":"The DeleteIncompleteReports class extends the CronJobBase class from Django's django_cron module. This cron job is responsible for periodically deleting incomplete reports from the system.","title":"Deleting Incomplete Reports using Cron Job"},{"location":"crm.html#cron_job_overview_1","text":"The DeleteIncompleteReports cron job ensures that incomplete reports are regularly cleaned up from the system to maintain data accuracy and prevent unnecessary clutter. It uses the clear_evaluator utility function to identify and remove incomplete reports.","title":"Cron Job Overview"},{"location":"crm.html#usage_example_5","text":"To use the DeleteIncompleteReports cron job, follow these steps: Import the necessary modules at the beginning of your script: python from django_cron import CronJobBase, Schedule from .report_utilities import clear_evaluator # Import the appropriate utility function import logging Define your DeleteIncompleteReports class, ensuring it extends CronJobBase : ```python class DeleteIncompleteReports(CronJobBase): RUN_EVERY_MINS = 5 RETRY_AFTER_FAILURE_MINS = 1 MIN_NUM_FAILURES = 2 ALLOW_PARALLEL_RUNS = True schedule = Schedule(run_every_mins=RUN_EVERY_MINS, retry_after_failure_mins=RETRY_AFTER_FAILURE_MINS) code = 'crm.delete_incomplete_reports' def do(self): try: deleted_count = clear_evaluator() log.info(f'{deleted_count} incomplete report(s) have been deleted') except Exception as e: log.exception(f'An error occurred while deleting incomplete reports: {e}') ``` Ensure you have the required logging configured to handle exceptions and logs effectively.","title":"Usage Example"},{"location":"crm.html#configuration_and_customization_5","text":"The DeleteIncompleteReports cron job class can be customized to suit your application's requirements. You can adjust the RUN_EVERY_MINS value to set the frequency of the cron job execution. Additionally, you can modify the do() method to include any other cleanup logic.","title":"Configuration and Customization"},{"location":"crm.html#error_handling_1","text":"The cron job employs robust error handling mechanisms. In case of any exceptions during the execution of the cron job, it logs the error and provides details for troubleshooting. Utilize the DeleteIncompleteReports cron job class to automatically maintain a clean and accurate system by regularly removing incomplete reports. If you encounter any issues or need further assistance, refer to the documentation or reach out to the development team for support.","title":"Error Handling"},{"location":"crm.html#url_patterns_in_the_crm_app","text":"The urls.py file in the CRM app defines URL patterns that map specific URLs to their corresponding views. This allows users to access different parts of the CRM application through their web browser.","title":"URL Patterns in the CRM App"},{"location":"crm.html#url_patterns_overview","text":"The URL patterns are defined using Django's path() function, which maps a URL to a view function. Each URL pattern has a unique identifier called the name , which can be used to generate URLs in templates.","title":"URL Patterns Overview"},{"location":"crm.html#url_definitions","text":"The urls.py file includes the following URL patterns: Leads View ( leads ): URL: /crm/leads View: leads function Purpose: Displays content related to leads in the CRM. Unsubscribe View ( unsubscrib ): URL: /crm/unsubscrib/<email>/<code> View: unsubscrib function Parameters: email (email address of the subscriber), code (unsubscribe code) Purpose: Handles email unsubscription for a specific email address. Subscribe View ( subscrib ): URL: /crm/subscrib/<str:email> View: subscrib function Parameter: email (email address of the subscriber) Purpose: Handles email subscription for a specific email address. Subscription View ( subscription ): URL: /crm/subscription View: subscription function Purpose: Displays content related to email subscription.","title":"URL Definitions"},{"location":"crm.html#usage_example_6","text":"To access the different parts of the CRM application, users can use the defined URLs. For example: - To view leads: /crm/leads - To unsubscribe: /crm/unsubscrib/user@example.com/abcdef123456 - To subscribe: /crm/subscrib/user@example.com - To manage subscriptions: /crm/subscription","title":"Usage Example"},{"location":"crm.html#customization_and_extension","text":"You can customize the URL patterns to match your application's requirements. Add new URL patterns and map them to appropriate views as needed. Make sure to update the views.py file with the corresponding view functions.","title":"Customization and Extension"},{"location":"crm.html#url_naming_and_templates","text":"Utilize the name parameter in URL patterns to generate URLs dynamically in templates using the {% url %} template tag. This ensures consistent and accurate URL generation throughout your application. The URL patterns defined in the urls.py file enable users to access various features and functionalities of the CRM app. If you encounter any issues or need further assistance, refer to the documentation or reach out to the development team for support.","title":"URL Naming and Templates"},{"location":"crm.html#models_in_the_crm_app","text":"The models.py file in the CRM app defines the database models used to store and manage various types of data within the application. These models represent key entities and relationships in the CRM system.","title":"Models in the CRM App"},{"location":"crm.html#model_overview","text":"The models.py file includes the following models: Lead Model : Represents leads in the CRM. Fields: lead , email_address , phone , address_1 , address_2 , city , country , subscribed , confirm_code . Purpose: Stores lead information such as name, email address, contact details, address, and subscription status. MailQueue Model : Represents queued emails in the CRM. Fields: to , added_at , processed , process_time , tried . Purpose: Stores information about emails in the queue, including recipient, timestamp, processing status, and retry count. BlogMailQueue Model : Represents queued emails related to blog posts. Fields: to , blog , added_at , processed , process_time , tried . Purpose: Stores information about emails in the queue related to blog posts, including recipient, associated blog post, and processing details.","title":"Model Overview"},{"location":"crm.html#model_details","text":"Each model defines its fields, data types, and relationships. The models capture important information about leads, queued emails, and blog-related emails.","title":"Model Details"},{"location":"crm.html#usage_example_7","text":"To work with the models, you can use Django's Object-Relational Mapping (ORM) features. Here's an example of how you might create a new lead: ```python from crm.models import Lead new_lead = Lead.objects.create( lead='John Doe', email_address='john@example.com', phone='123-456-7890', city='New York', country='US', subscribed=True ) ```","title":"Usage Example"},{"location":"crm.html#customization_and_extension_1","text":"You can customize the models to match your application's requirements. Add new fields or methods to capture additional data or functionality as needed.","title":"Customization and Extension"},{"location":"crm.html#database_synchronization","text":"After defining or modifying models, make sure to run database migrations using the makemigrations and migrate commands to keep your database schema up-to-date. The models defined in the models.py file enable structured storage and management of leads, queued emails, and blog-related email queues. Refer to the documentation for details on using and customizing these models, and feel free to reach out to the development team for assistance.","title":"Database Synchronization"},{"location":"crm.html#helper_function_get_iprequest","text":"The get_ip function in the views.py file is a utility function designed to retrieve the IP address of a user from an incoming HTTP request. This function is particularly useful for tracking user IP addresses in your application for various purposes, such as analytics, security, and customization.","title":"Helper Function: get_ip(request)"},{"location":"crm.html#function_overview_5","text":"The get_ip function attempts to extract the user's IP address from various headers present in the HTTP request. It prioritizes headers known to contain the real client IP address, and if none of those headers are present, it falls back to using the REMOTE_ADDR field from the request's META dictionary.","title":"Function Overview"},{"location":"crm.html#function_signature","text":"```python def get_ip(request: HttpRequest) -> str: \"\"\" Get the user's IP address from the request. Args: request (HttpRequest): The HTTP request object. Returns: str: The user's IP address. \"\"\" ```","title":"Function Signature"},{"location":"crm.html#header_priority_and_fallback","text":"The function iterates through multiple headers, including HTTP_X_FORWARDED_FOR , HTTP_CLIENT_IP , HTTP_X_REAL_IP , and more, to ensure it captures the actual client IP. If none of these headers contain a valid IP, the function resorts to using the REMOTE_ADDR field, which typically stores the user's IP address.","title":"Header Priority and Fallback"},{"location":"crm.html#usage_example_8","text":"You can use the get_ip function in your views to track and record the IP addresses of users interacting with your application. For example: python def my_view(request): user_ip = get_ip(request) # Process and record user IP as neededr: The user's IP address. \"\"\"","title":"Usage Example"},{"location":"crm.html#customization_and_extensions","text":"Feel free to modify the get_ip function to suit your application's specific requirements. You can add additional header checks or adapt the function to work with different proxy configurations if necessary. The get_ip function simplifies the process of obtaining the user's IP address from an HTTP request, offering flexibility and ease for IP-related operations within your CRM application. Refer to the documentation for more details on its implementation and usage.","title":"Customization and Extensions"},{"location":"crm.html#function_get_location_inforequest","text":"The get_location_info function in the views.py file retrieves location information based on the user's IP address. This function utilizes the user's IP address, obtained through the get_ip function, to query the IPinfo database. The function then extracts details such as the user's city, region, country, and more.","title":"Function: get_location_info(request)"},{"location":"crm.html#function_overview_6","text":"The get_location_info function takes an HTTP request object as an argument. It uses the get_ip function to retrieve the user's IP address, and then constructs an API URL using the IP address and an API token provided in the settings. The function sends an HTTP request to the IPinfo API and processes the response JSON to extract relevant location data.","title":"Function Overview"},{"location":"crm.html#function_signature_1","text":"```python def get_location_info(request: HttpRequest) -> dict: \"\"\" Get location information based on the user's IP address. Args: request (HttpRequest): The HTTP request object. Returns: dict: Location-related information obtained from the IPinfo database. \"\"\" ```","title":"Function Signature"},{"location":"crm.html#api_response_handling","text":"The function checks the HTTP response status code to ensure a successful API call (HTTP status code 200, IPINFO.io token is require). If the response code is 200, the function parses the JSON response and updates the data dictionary with location information. If the response code is not 200, the function logs an error.","title":"API Response Handling"},{"location":"crm.html#usage_example_9","text":"You can use the get_location_info function to enhance user experiences based on their geographical location: python def my_view(request): location_data = get_location_info(request) # Process and utilize location data as needed","title":"Usage Example"},{"location":"crm.html#customization_and_extensions_1","text":"The function relies on the get_ip function to retrieve IP addresses. To customize or extend functionality, consider modifying the API request URL or handling additional API response details. The get_location_info function provides a convenient way to obtain user location information based on their IP address, enabling personalized experiences and insights in your CRM application. Refer to the documentation for more details on its implementation and utilization.","title":"Customization and Extensions"},{"location":"crm.html#function_subscriptionrequest","text":"The subscription function in the views.py file handles user subscription requests for newsletters. This function validates the provided name and email address, performs checks on existing subscriptions, sends confirmation emails, and returns appropriate responses to the user.","title":"Function: subscription(request)"},{"location":"crm.html#function_overview_7","text":"The subscription function takes an HTTP request object as an argument. It primarily processes POST requests containing subscription form data. The function follows these steps: 1. Validates the form data submitted by the user. 2. Checks if the provided email address already exists in the Lead database. 3. Sends a confirmation email for subscription or informs the user if the email is already subscribed. 4. Creates a new Lead entry and sends a confirmation email if the email is not found in the database.","title":"Function Overview"},{"location":"crm.html#function_signature_2","text":"```python def subscription(request: HttpRequest) -> HttpResponse: \"\"\" Process subscription requests and send confirmation emails. Args: request (HttpRequest): The HTTP request object. Returns: HttpResponse: A response indicating the result of the subscription attempt. \"\"\" ```","title":"Function Signature"},{"location":"crm.html#subscription_workflow","text":"When a user submits the subscription form, the function checks if the submitted data is valid. 1. If the email address already exists in the Lead database: 2. If the email is subscribed, an error message is returned, indicating that the email is already subscribed. 3. If the email is not subscribed, a confirmation email is sent to the user. 4. If the email address is not found in the database, a new Lead entry is created with the provided name, email address, and location information. A confirmation email is then sent.","title":"Subscription Workflow"},{"location":"crm.html#usage_example_10","text":"You can use the subscription function to handle user subscription requests in your views: python def my_view(request): if request.method == 'POST': return subscription(request) else: # Handle GET requests or other logic","title":"Usage Example"},{"location":"crm.html#customization_and_extensions_2","text":"This function relies on the Lead model and the SubscriberForm form for data management and validation. You can customize the email templates, modify the subscription workflow, or integrate additional functionality as per your application's requirements. The subscription function streamlines the subscription process for newsletters, providing a user-friendly experience by sending confirmation emails and managing user data. Refer to the documentation for more details on its implementation and utilization.","title":"Customization and Extensions"},{"location":"crm.html#function_leadsrequest","text":"The leads function in the views.py file handles the display and management of leads within the CRM system. It allows for lead deletion, adding leads to the mail queue for later sending, and uploading leads through a CSV file. The function also implements lead pagination and provides associated documentation.","title":"Function: leads(request)"},{"location":"crm.html#function_overview_8","text":"The leads function requires user authentication and staff permissions to access. It processes both GET and POST requests and offers the following features: - Displaying and managing leads in the CRM system. - Deleting selected leads. - Adding selected leads to the mail queue for sending later. - Uploading leads through a CSV file.","title":"Function Overview"},{"location":"crm.html#function_signature_3","text":"```python @login_required @staff_member_required def leads(request: HttpRequest) -> HttpResponse: \"\"\" Display and manage leads for the CRM. Args: request (HttpRequest): The HTTP request object. Returns: HttpResponse: A rendered HTML template with lead data and related information. \"\"\" ```","title":"Function Signature"},{"location":"crm.html#lead_management_workflow","text":"Display the list of leads paginated in groups of 50 per page. Process POST requests: Delete selected leads using bulk delete. Add selected leads to the mail queue for later sending. Upload leads from a CSV file, processing and validating each entry. ##### Lead Management Features - Deleting Leads: Selecting leads and clicking the \"Delete\" button removes the selected leads from the CRM. - Adding to Mail Queue: Selecting leads and clicking the \"Mail Lead\" button adds them to the mail queue for later sending. Only subscribed leads are added. - Uploading Leads: Uploading a CSV file containing lead information adds the leads to the CRM. Errors during upload are reported. ##### Pagination and Meta Information The function uses pagination to display leads, with 50 leads per page. It also provides meta information for the page, such as title, description, tag, and robots directives. ##### Customization and Extensions This function interacts with the Lead model, supporting lead management and data storage. You can customize templates, modify lead management workflows, and integrate additional features based on your application's requirements. The leads function offers a comprehensive interface for lead management within the CRM. It empowers users to manage leads, perform bulk actions, and upload leads through CSV files. Refer to the documentation for more details on its implementation and utilization.","title":"Lead Management Workflow"},{"location":"crm.html#unsubscribe_function","text":"This function handles the process of unsubscribing a lead from receiving further CRM emails. When users click on the unsubscribe link sent in emails, they are directed to this view to complete the unsubscription process.","title":"Unsubscribe Function"},{"location":"crm.html#purpose_1","text":"The purpose of this view is to allow users to opt-out of receiving CRM emails by unsubscribing. It verifies the provided email and confirmation code against the Lead model to ensure the legitimacy of the unsubscription request.","title":"Purpose"},{"location":"crm.html#functionality","text":"When a user accesses the unsubscribe link with their email and confirmation code, the function performs the following steps: Extracts the email and confirmation code from the URL parameters. Attempts to locate a lead in the Lead model with the provided email and code. If a valid lead is found, it sets the subscribed field of the lead to False , marking them as unsubscribed. Logs the action, indicating that the lead has been successfully unsubscribed. If the provided email or code is invalid, it displays a warning message and redirects the user to the home page.","title":"Functionality"},{"location":"crm.html#usage_4","text":"To unsubscribe from CRM emails, users can click on the unsubscribe link provided in the emails they receive. They will be directed to this view, where the provided email and code will be verified, and their subscription status will be updated accordingly.","title":"Usage"},{"location":"crm.html#parameters","text":"request (HttpRequest): The HTTP request object. **kwargs : Keyword arguments containing 'email' and 'code' from the URL.","title":"Parameters"},{"location":"crm.html#returns","text":"HttpResponse : A rendered HTML template confirming the unsubscribed status for the lead, or an error message if the email or code is invalid.","title":"Returns"},{"location":"crm.html#example","text":"```python # Unsubscribe link in email: # http://example.com/crm/unsubscrib/john@example.com/abc123 # URL Parameters: email='john@example.com', code='abc123' def unsubscrib(request, **kwargs): # ... (Function implementation) ```","title":"Example"},{"location":"crm.html#subscribrequest_kwargs","text":"This view handles the confirmation of a lead's subscription to the CRM system. It is accessed via a confirmation link sent in subscription emails.","title":"subscrib(request, **kwargs)"},{"location":"crm.html#arguments","text":"request (HttpRequest): The HTTP request object. **kwargs : Keyword arguments containing the 'email' parameter from the URL.","title":"Arguments"},{"location":"crm.html#functionality_1","text":"When a lead clicks on the subscription confirmation link sent to their email, this function is triggered. It confirms their subscription to the CRM system by updating the 'subscribed' field of the lead's record in the database. If the lead's email is successfully confirmed, a success template is displayed to acknowledge the subscription. If the email is not found or any errors occur, an appropriate error message is displayed.","title":"Functionality"},{"location":"crm.html#usage_5","text":"```python def subscrib(request, **kwargs): \"\"\" Confirm Subscription Function This view handles the confirmation of a lead's subscription to the CRM. It is accessed via a confirmation link sent in emails. Args: request (HttpRequest): The HTTP request object. **kwargs: Keyword arguments containing 'email' from the URL. Returns: HttpResponse: A rendered HTML template confirming the subscription status for the lead or an error message if the email is invalid. \"\"\" # ... (implementation details) ```","title":"Usage"},{"location":"crm.html#contributions","text":"If you're a developer working on this project, feel free to expand or modify the admin.py file to meet the evolving requirements of the CRM app. Don't forget to maintain clear code documentation, such as comments and docstrings, to help future developers understand your changes. By working collaboratively, we can enhance the app's functionality and user experience while maintaining code quality. For additional information or assistance, please refer to the project documentation or reach out to the development team. Happy coding!","title":"Contributions"},{"location":"doc.html","text":"======================================= README for the 'doc' Django App ======================================= Introduction \u00b6 The 'doc' app is a Django application designed to manage and organize documents and related content. This README provides an overview of the app and explains the structure and functionality of the admin.py file. admin.py Overview \u00b6 The admin.py file within the 'doc' app is essential for customizing the admin interface of the Django application. It extends the default admin behavior for models and provides a more tailored experience for managing content. Below is an explanation of the key components in admin.py : Model Registration : We register the 'Acordion' model with the admin site using admin.site.register(Acordion) . This enables administrators to manage 'Acordion' objects through the Django admin panel. Inline Admin Class : We define an inline admin class, ExtendSiteOfSite , which inherits from admin.StackedInline . This class allows for the management of 'ExSite' objects within the 'Site' admin page. The can_delete attribute is set to False , preventing the deletion of 'ExSite' instances from the 'Site' admin interface. Customized 'Site' Admin : The SiteAdmin class customizes the admin interface for the 'Site' model. It specifies the fields to be displayed in the list view using list_display and enables search functionality by defining the fields in search_fields . Additionally, it includes the ExtendSiteOfSite inline admin class, providing a comprehensive view of 'Site' and its related 'ExSite' instances. Unregister and Re-register : To apply the customizations, we unregister the default 'Site' admin using admin.site.unregister(Site) and then re-register it with our custom SiteAdmin class using admin.site.register(Site, SiteAdmin) . With these configurations in admin.py , administrators can efficiently manage 'Acordion', 'Site', and their related 'ExSite' objects, ensuring a smooth user experience while interacting with document-related content within the Django admin panel. Please refer to the respective model files and other parts of the application for more detailed information on their functionalities and relationships. Getting Started \u00b6 To get started with the 'doc' app, follow these steps: Install the app in your Django project. Configure the app's models, views, and templates as needed for your specific document management requirements. Customize the 'admin.py' file to suit your admin interface preferences, as demonstrated in this README. Run migrations to apply database changes: python manage.py makemigrations and python manage.py migrate . Create superuser accounts to access the admin panel: python manage.py createsuperuser . Start the development server: python manage.py runserver . Access the Django admin panel, where you can manage 'Acordion', 'Site', and 'ExSite' objects with the customizations provided in admin.py . ============================================== README for 'doc_processor.py' in the 'doc' App ============================================== Introduction \u00b6 The 'doc_processor.py' module in the 'doc' app is a crucial component responsible for processing common data and site information used throughout the application. This README provides an overview of the functions and their purposes within this module. Functions Overview \u00b6 site_info() : This function retrieves and caches site information such as name, domain, meta information, logos, contact details, and more. It enhances performance by caching the retrieved information. Usage: python site_information = site_info() get_pending_suggestion() : Retrieves and caches the count of pending suggestions from the 'Suggestions' model. This function is used to optimize performance by caching the count for future use. Usage: python pending_suggestion_count = get_pending_suggestion() common_doc(request) : Generates common data required for rendering templates, including text translations, site information, menus, and subscription forms. Accepts an HttpRequest object as input to cater to request-specific data. Usage: python common_data = common_doc(request) Usage Instructions \u00b6 To utilize the 'doc_processor.py' module in your 'doc' app, follow these steps: Import the necessary functions into your views or other modules where common data is required. Use the functions as outlined in their respective descriptions above. For example, to access site information and common data: ```python from doc_processor import site_info, common_doc # Access site information site_information = site_info() # Access common data for rendering templates common_data = common_doc(request) ``` ============================================ README for 'models.py' in the 'doc' App ============================================ Introduction \u00b6 The models.py module within the 'doc' app defines the database models used to store and manage data related to site information and accordion elements. This README provides an overview of the models and their attributes. Models Overview \u00b6 ExSite : Represents extended site information associated with a Django Site. Stores metadata, logos, contact details, and social media links for the site. Attributes: site (OneToOneField): Relationship with the Django Site model. site_meta (CharField): Meta information for the site. site_description (TextField): A longer description for the site. site_meta_tag (CharField): Meta tag for the site. site_favicon (ImageField): Site favicon image. site_logo (ImageField): Site logo image. slogan (CharField): A short slogan or tagline for the site. og_image (ImageField): Open Graph image for social sharing. mask_icon (FileField): SVG file for mask icon. phone (CharField): Contact phone number. email (EmailField): Contact email address. location (CharField): Physical location or address. facebook_link (URLField): Facebook profile URL. twitter_link (URLField): Twitter profile URL. linkedin_link (URLField): LinkedIn profile URL. qualified_ans_range (IntegerField): A numeric value representing a qualification range. Managers: objects (models.Manager): The default manager. on_site (CurrentSiteManager): Manager for filtering by the current site. Acordion : Represents an accordion element with a button and description. Contains a button with text and a description and allows associating the accordion with an installed app. Attributes: button_text (CharField): Text displayed on the button. button_des (TextField): Description or content associated with the accordion element. apps (CharField): Choice field for associating the accordion with an installed app. Usage Instructions \u00b6 To utilize the models defined in models.py within your 'doc' app, follow these steps: Create migrations and apply them to your database using the makemigrations and migrate management commands. Use the models in your application's views, forms, or other modules as needed. For example, you can create, retrieve, update, or delete instances of ExSite or Acordion in your views. Customize the models and their attributes as per your project's requirements. You can add new fields or methods to extend their functionality. For detailed information on working with Django models, please refer to the official Django documentation. For further information and detailed documentation, consult the project's documentation or the source code. Contributing \u00b6 Contributions to the 'doc' app are welcome! If you'd like to contribute, please review the contribution guidelines in the project's repository. License \u00b6 This app is distributed under the [Insert License Here] license. See the LICENSE file for more information.","title":"Doc"},{"location":"doc.html#introduction","text":"The 'doc' app is a Django application designed to manage and organize documents and related content. This README provides an overview of the app and explains the structure and functionality of the admin.py file.","title":"Introduction"},{"location":"doc.html#adminpy_overview","text":"The admin.py file within the 'doc' app is essential for customizing the admin interface of the Django application. It extends the default admin behavior for models and provides a more tailored experience for managing content. Below is an explanation of the key components in admin.py : Model Registration : We register the 'Acordion' model with the admin site using admin.site.register(Acordion) . This enables administrators to manage 'Acordion' objects through the Django admin panel. Inline Admin Class : We define an inline admin class, ExtendSiteOfSite , which inherits from admin.StackedInline . This class allows for the management of 'ExSite' objects within the 'Site' admin page. The can_delete attribute is set to False , preventing the deletion of 'ExSite' instances from the 'Site' admin interface. Customized 'Site' Admin : The SiteAdmin class customizes the admin interface for the 'Site' model. It specifies the fields to be displayed in the list view using list_display and enables search functionality by defining the fields in search_fields . Additionally, it includes the ExtendSiteOfSite inline admin class, providing a comprehensive view of 'Site' and its related 'ExSite' instances. Unregister and Re-register : To apply the customizations, we unregister the default 'Site' admin using admin.site.unregister(Site) and then re-register it with our custom SiteAdmin class using admin.site.register(Site, SiteAdmin) . With these configurations in admin.py , administrators can efficiently manage 'Acordion', 'Site', and their related 'ExSite' objects, ensuring a smooth user experience while interacting with document-related content within the Django admin panel. Please refer to the respective model files and other parts of the application for more detailed information on their functionalities and relationships.","title":"admin.py Overview"},{"location":"doc.html#getting_started","text":"To get started with the 'doc' app, follow these steps: Install the app in your Django project. Configure the app's models, views, and templates as needed for your specific document management requirements. Customize the 'admin.py' file to suit your admin interface preferences, as demonstrated in this README. Run migrations to apply database changes: python manage.py makemigrations and python manage.py migrate . Create superuser accounts to access the admin panel: python manage.py createsuperuser . Start the development server: python manage.py runserver . Access the Django admin panel, where you can manage 'Acordion', 'Site', and 'ExSite' objects with the customizations provided in admin.py . ============================================== README for 'doc_processor.py' in the 'doc' App ==============================================","title":"Getting Started"},{"location":"doc.html#introduction_1","text":"The 'doc_processor.py' module in the 'doc' app is a crucial component responsible for processing common data and site information used throughout the application. This README provides an overview of the functions and their purposes within this module.","title":"Introduction"},{"location":"doc.html#functions_overview","text":"site_info() : This function retrieves and caches site information such as name, domain, meta information, logos, contact details, and more. It enhances performance by caching the retrieved information. Usage: python site_information = site_info() get_pending_suggestion() : Retrieves and caches the count of pending suggestions from the 'Suggestions' model. This function is used to optimize performance by caching the count for future use. Usage: python pending_suggestion_count = get_pending_suggestion() common_doc(request) : Generates common data required for rendering templates, including text translations, site information, menus, and subscription forms. Accepts an HttpRequest object as input to cater to request-specific data. Usage: python common_data = common_doc(request)","title":"Functions Overview"},{"location":"doc.html#usage_instructions","text":"To utilize the 'doc_processor.py' module in your 'doc' app, follow these steps: Import the necessary functions into your views or other modules where common data is required. Use the functions as outlined in their respective descriptions above. For example, to access site information and common data: ```python from doc_processor import site_info, common_doc # Access site information site_information = site_info() # Access common data for rendering templates common_data = common_doc(request) ``` ============================================ README for 'models.py' in the 'doc' App ============================================","title":"Usage Instructions"},{"location":"doc.html#introduction_2","text":"The models.py module within the 'doc' app defines the database models used to store and manage data related to site information and accordion elements. This README provides an overview of the models and their attributes.","title":"Introduction"},{"location":"doc.html#models_overview","text":"ExSite : Represents extended site information associated with a Django Site. Stores metadata, logos, contact details, and social media links for the site. Attributes: site (OneToOneField): Relationship with the Django Site model. site_meta (CharField): Meta information for the site. site_description (TextField): A longer description for the site. site_meta_tag (CharField): Meta tag for the site. site_favicon (ImageField): Site favicon image. site_logo (ImageField): Site logo image. slogan (CharField): A short slogan or tagline for the site. og_image (ImageField): Open Graph image for social sharing. mask_icon (FileField): SVG file for mask icon. phone (CharField): Contact phone number. email (EmailField): Contact email address. location (CharField): Physical location or address. facebook_link (URLField): Facebook profile URL. twitter_link (URLField): Twitter profile URL. linkedin_link (URLField): LinkedIn profile URL. qualified_ans_range (IntegerField): A numeric value representing a qualification range. Managers: objects (models.Manager): The default manager. on_site (CurrentSiteManager): Manager for filtering by the current site. Acordion : Represents an accordion element with a button and description. Contains a button with text and a description and allows associating the accordion with an installed app. Attributes: button_text (CharField): Text displayed on the button. button_des (TextField): Description or content associated with the accordion element. apps (CharField): Choice field for associating the accordion with an installed app.","title":"Models Overview"},{"location":"doc.html#usage_instructions_1","text":"To utilize the models defined in models.py within your 'doc' app, follow these steps: Create migrations and apply them to your database using the makemigrations and migrate management commands. Use the models in your application's views, forms, or other modules as needed. For example, you can create, retrieve, update, or delete instances of ExSite or Acordion in your views. Customize the models and their attributes as per your project's requirements. You can add new fields or methods to extend their functionality. For detailed information on working with Django models, please refer to the official Django documentation. For further information and detailed documentation, consult the project's documentation or the source code.","title":"Usage Instructions"},{"location":"doc.html#contributing","text":"Contributions to the 'doc' app are welcome! If you'd like to contribute, please review the contribution guidelines in the project's repository.","title":"Contributing"},{"location":"doc.html#license","text":"This app is distributed under the [Insert License Here] license. See the LICENSE file for more information.","title":"License"},{"location":"evaluation.html","text":"====================================================== README for 'custom_tags.py' in the 'templatetags' Directory of the 'Evaluation' App ====================================================== Introduction \u00b6 The 'custom_tags.py' module in the 'templatetags' directory of the 'Evaluation' app contains custom template filters and tags that extend the functionality of Django templates. These filters and tags are designed to enhance template rendering and provide additional features for template-based operations. This README provides an overview of the custom filters and tags available in this module. Custom Filters and Tags Overview \u00b6 brek_after_two Filter : This custom filter inserts a line break into text after a specified number of characters. Usage Example: html {{ text|brek_after_two:10 }} get_verbose_name Tag : This custom template tag retrieves the verbose name of a field in a model. Usage Example: html {% get_verbose_name instance field_name %} in_quot Filter : This filter filters quotes based on a specific user, returning only quotes associated with that user. Usage Example: html {{ quotes|in_quot:user }} offchars Filter : This filter returns characters from the end of a string, excluding the specified number of characters from the beginning. Usage Example: html {{ text|offchars:5 }} onnchars Filter : This filter returns characters from the beginning of a string, excluding the specified number of characters from the end. Usage Example: html {{ text|onnchars:5 }} listobj_for_paginator Filter : This filter paginates a list of objects and returns a paginated Page object. Usage Example: html {{ object_list|listobj_for_paginator:request }} get_options Filter : This filter retrieves options associated with a question and returns them as a list. Usage Example: html {{ question|get_options }} get_quotations_user Filter : This filter retrieves quotations related to a question for a specific user and returns them as a list. Usage Example: html {{ question|get_quotations_user:user }} get_related_quotations_user Filter : This filter retrieves related quotations for a question for a specific user and returns them as a list. Usage Example: html {{ question|get_related_quotations_user:user }} get_merged_quotations_with_user Filter : This filter retrieves merged quotations for a question with a specific user and returns them as a list. Usage Example: html {{ question|get_merged_quotations_with_user:user }} get_types_slug Template Filter : The get_types_slug custom template filter is used to retrieve the slug of a UserType based on its type. It is designed to be used within Django templates to facilitate dynamic content rendering based on user types. This filter takes one argument: type (str): The type of UserType ('is_producer', 'is_expert', 'is_consumer', 'is_marine') for which you want to retrieve the slug. Usage Example: html <!-- In a Django template --> {{ 'is_producer'|get_types_slug }} This filter returns the slug of the UserType associated with the provided type, or None if the type is not recognized. Parameters : type (str): The type of UserType ('is_producer', 'is_expert', 'is_consumer', 'is_marine'). Returns : str or None : The slug of the UserType associated with the provided type, or None if not found. Note : This filter can be used in Django templates to conditionally display content or generate links based on user types. It checks the provided type and returns the corresponding slug for the UserType, allowing you to tailor the template output based on user roles. Usage Instructions \u00b6 To use the custom filters and tags defined in 'custom_tags.py' within your Django templates, follow these steps: Import the necessary tags and filters in your template using {% load custom_tags %} . Use the custom filters and tags as shown in the usage examples above within your template code. Ensure that you include appropriate error handling and context variables in your templates when using these custom filters and tags. ========================= Evaluation App - admin.py ========================= This README provides an overview of the admin.py file for the Evaluation app. The admin.py file contains the Django admin configurations for various models within the app. Admin Configurations QuestionAdmin Displays a list of questions with sorting and filtering options. Includes inlines for Labels and Options related to questions. Custom CSS styling is applied to the admin view. Custom change list template to display error notes about question configurations. Custom changelist_view method to add context data about questions with incomplete configurations. OptionAdmin Displays a list of options with filtering options. Inherits from ExportActionMixin to provide export functionality. BiofuelAdmin Provides inlines for StdOils. EvaLebelStatementAdmin Displays a list of evaluation label statements with filtering options. StdOilsAdmin Displays a list of standard oils with inlines for StandaredCharts. Custom CSS styling is applied to the admin view. SuggestionsAdmin Displays a list of suggestions with filtering and search options. Provides readonly_fields for certain fields. LogicalStringAdmin Displays a list of logical strings with inlines for LsLabels. Custom change list template to display error notes about logical string configurations. Custom changelist_view method to add context data about logical strings with incomplete configurations. EvaluatorAdmin Displays a list of evaluators with filtering options. Provides actions to generate updated reports and notify creators. Custom check_and_notify method to execute the custom action. Provides readonly_fields for certain fields. StandaredChartAdmin Displays a list of standard charts with filtering and editing options. Custom CSS styling is applied to the admin view. NextActivitiesAdmin Provides an action to duplicate selected activities. Provides readonly_fields for certain fields. Please Note : The code comments and docstrings in admin.py provide further details about the functionality and purpose of each admin class. If you have any questions or need additional information, please refer to the comments in the code or feel free to ask for assistance. ==================== Evaluation App - apps.py ==================== This README provides an overview of the apps.py file for the Evaluation app. The apps.py file contains the configuration settings for the 'evaluation' app. App Configuration default_auto_field : Specifies the name of the default auto-generated primary key field. name : Specifies the name of the app. ready() Method The ready() method is executed when the app is ready to function within the Django project. In this method, the evaluation.signals module is imported, allowing the app to utilize signals for event handling. Example Usage To use this AppConfig in your Django project, add it to the 'INSTALLED_APPS' list in your project's settings.py file. This configuration ensures that the 'evaluation' app is integrated into your project and that its signals are loaded and available for use. python INSTALLED_APPS = [ ... 'evaluation', ... ] ======================== Evaluation App - middleware.py ======================== This README provides an overview of the middleware.py file for the Evaluation app. The middleware.py file contains the EvaMiddleware class, which is responsible for handling specific requests and sessions within the app. Middleware Overview Middleware in Django is used to process requests and responses globally before they reach the view or after they leave the view. This custom middleware class, EvaMiddleware , performs specific actions based on conditions before allowing a request to proceed to the view. Middleware Functionality Initialization : The __init__ method initializes the middleware with the provided get_response function. Request Handling : The __call__ method is the main method of the middleware, called for each incoming request. It checks conditions and manages sessions before allowing the request to proceed to the view. Usage To use this middleware, add it to the MIDDLEWARE list in your Django project's settings.py file as follows: python MIDDLEWARE = [ ... 'evaluation.middleware.EvaMiddleware', ... ] Conditions Checked The middleware checks the following conditions before processing a request: If the 'evaluator' key is present in the request session. Whether a specific setting ('CNN') is enabled in the project's settings. Customization Do not customize the EvaMiddleware class. It can cause in the evaluation process and report genaration. ======================== Evaluation App - forms.py ======================== This README provides an overview of the forms.py file for the Evaluation app. The forms.py file contains the EvaluatorForm class, which is a Django form used for creating and updating Evaluator instances. Form Overview Forms in Django are used to handle user input and validation. The EvaluatorForm class is designed to work with the Evaluator model and provides a structured way to create and update Evaluator objects. Form Functionality Meta Class : The inner Meta class defines metadata for the form, including the model and form fields. It also customizes labels for form fields. Custom Validation : The clean method is a custom form validation method that ensures the 'biofuel' selection is mandatory. If 'biofuel' is not selected, a validation error is raised. Form Fields The EvaluatorForm includes the following fields: - 'name': Name of the evaluator. - 'email': Email address of the evaluator. - 'phone': Phone number of the evaluator. - 'organization': Organization to which the evaluator belongs. - 'biofuel': A dropdown field to select a fuel type. Form Widgets and Labels Form fields are customized with widgets to control their appearance in the HTML form. Custom labels are defined to provide clear field descriptions. Usage Developers can use this form in their views to create and update Evaluator instances. After binding the form to request data, validation can be performed, and Evaluator instances can be saved or updated based on user input. Customization Developers can customize this form to suit their app's specific needs by modifying form fields, widgets, labels, or adding additional validation logic. If you have any questions or need further clarification, please refer to the comments in the code or feel free to ask for assistance. ======================== Evaluation App - helper.py ======================== This README provides an overview of the helper.py file in the Evaluation app. The helper.py file contains various functions that retrieve and cache data from the database to improve performance on subsequent calls. Function Overview The helper functions in helper.py are designed to efficiently fetch and cache specific data from the database. Each function focuses on retrieving a specific set of data related to Questions, StdOils, or Glossary. Function Details get_all_questions() : This function retrieves and caches all Question instances from the database. It first checks the cache for the presence of cached questions to avoid unnecessary database queries. If the cached data is not available, it fetches all Question instances, including related data, and caches the result for future use. The cached data is stored for 3600 seconds (1 hour) to balance data freshness and query performance. get_all_stdoils() : This function retrieves and caches all StdOils instances from the database. Similar to get_all_questions() , it checks for cached data and fetches StdOils instances with related data if not already cached. The cached data is also stored for 3600 seconds. get_all_glossaries() : This function retrieves and caches all Glossary instances from the database. Like the previous functions, it checks the cache for existing data and fetches Glossary instances if needed. Cached data is stored for 3600 seconds. get_all_definedlabel() : This function retrieves and caches all DifinedLabel instances from the database. It follows a similar pattern as previous functions, checking for cached data and fetching DifinedLabel instances if not already cached. Cached data is stored for 3600 seconds. get_all_reports_with_last_answer(request, first_of_parent) : This function retrieves and caches reports (evaluators) with their last answered questions. It accepts two arguments: request (the HTTP request object) and first_of_parent (the first question of the parent questionnaire). The function distinguishes between superusers or staff and regular users when fetching reports. For each report, it determines the last answered question and stores its slug. Cached data is stored for 3600 seconds. get_biofuel() : This function retrieves and caches all Biofuel instances from the database. Similar to other functions, it checks for cached data and fetches Biofuel instances if needed. Cached data is stored for 3600 seconds. get_options_of_ques(question) : This function retrieves and caches all options related to a specific question. It accepts a question argument (the question for which options are retrieved). Cached data is stored using a key based on the question's ID and is stored for 3600 seconds. get_sugestions_of_ques(question) : This function retrieves and caches all suggestions related to a specific question. It accepts a question argument (the question for which suggestions are retrieved). Suggestions are ordered by creation date. Cached data is stored using a key based on the question's ID and is stored for 3600 seconds. active_sessions() : This function retrieves evaluator IDs from active sessions in the past 24 hours. It uses Django's Session model to fetch sessions that have not expired within the last 24 hours. Active evaluator IDs are stored in a set to ensure uniqueness. The function returns a list of evaluator IDs. clear_evaluator() : This function clears incomplete evaluators and their related data from the database. It is designed to run as a scheduled background task (e.g., via a CRON job) to maintain a clean database. Incomplete evaluators are those that were initialized but have no associated data and have not generated a report. The function fetches incomplete evaluators, checks if they are active in sessions, and deletes them along with their related data. The deletion sequence is carefully managed to avoid foreign key constraints. The function returns the total number of incomplete evaluators deleted during the process. get_current_evaluator(request, evaluator_id=None) : This function retrieves the current evaluator object based on the provided evaluator_id or the evaluator_id stored in the user's session. It is assumed that the middleware ensures 'evaluator' exists in the session. Developers can use this function to retrieve the current evaluator or a specific evaluator by ID. If no evaluator is found, it logs a debug message indicating the issue. Below provides detailed information on the EvaLebelStatementAnalyzer class in the Evaluation app's helper.py file. The class is responsible for analyzing evaluation statements related to EvaLebel and generating assessment statements based on various criteria related to EvaLebel evaluations. Class Details EvaLebelStatementAnalyzer : A class for analyzing evaluation statements related to EvaLebel. Provides methods for generating assessment statements based on various criteria. Accepts two arguments during initialization: evalebel (an instance of EvaLebel representing the evaluation label) and evaluator (an instance representing the evaluator). Methods get_statement_count(values_key, **filter_kwargs) : Get the count of distinct statements based on filtering criteria. Accepts a values_key for grouping and counting and additional filter criteria as keyword arguments. Returns the count of distinct statements based on the filter criteria. get_dont_know_statement(label_name, value_count) : Generate a statement based on the value count for \"don't know\" evaluations. Accepts label_name (the name of the evaluation label) and value_count (the count of \"don't know\" evaluations). Returns a statement describing the assessment based on the value count. get_positive_statement(label_name, value_count) : Generate a statement based on the value count for positive evaluations. Accepts label_name (the name of the evaluation label) and value_count (the count of positive evaluations). Returns a statement describing the assessment based on the value count. ans_to_the_label() : Get the count of answers related to the evaluation label. Returns the count of answers related to the evaluation label. calculate_percentage(ans_to_the_lavel) : Calculate the percentage based on answers related to the evaluation label. Accepts ans_to_the_label (the count of answers related to the evaluation label). Returns the percentage calculated based on the given count. label_assessment_for_donot_know() : Generate an assessment statement for \"don't know\" evaluations related to the label. Returns an assessment statement based on \"don't know\" evaluations. label_assessment_for_positive() : Generate an assessment statement for positive evaluations related to the label. Returns an assessment statement based on positive evaluations. ans_ques() : Get the count of answerable questions. Returns the count of answerable questions. calculate_overall_percent(ans) : Calculate the overall percentage based on the given count. Accepts ans (the count used to calculate the overall percentage). Returns the overall percentage calculated based on the given count. overall_assessment_for_donot_know() : Generate an overall assessment statement for \"don't know\" evaluations. Returns an overall assessment statement based on \"don't know\" evaluations. overall_assessment_for_positive() : Generate an overall assessment statement for positive evaluations. Returns an overall assessment statement based on positive evaluations. Usage and Customization The EvaLebelStatementAnalyzer class is designed to analyze and generate assessment statements for EvaLebel evaluations. Developers can use its methods to provide valuable insights and feedback to evaluators. Each method has specific functionality and can be customized as needed to tailor assessment statements based on different criteria and scenarios. For more information about the usage of these methods and customizations, please refer to the code comments or reach out for further assistance. Below README focusing on a class named LabelWiseData . This class is designed to handle various data calculations and retrievals related to label-wise evaluation. Class Details LabelWiseData : This class is designed to perform label-wise data calculations and retrievals. The class is initialized with an evaluator , which can be obtained from the session or URL. Properties : answered_question_id_list : Gets a list of unique answered question IDs. total_active_questions : Gets the total count of active questions with four labels. answered_percent : Calculates the percentage of answered questions out of total active questions. total_positive_answer : Gets the total count of positive answers. total_nagetive_answer : Gets the total count of negative answers. overview_green : Calculates the percentage of positive answers out of total active questions. overview_red : Calculates the percentage of negative answers out of total active questions. overview_grey : Calculates the percentage of answers that are neither positive nor negative out of total active questions. Methods : total_result() : Gets the overall results in a dictionary format, considering green, grey, and red as stackable bars. label_wise_positive_answered(label) : Gets the count of positive answers for a specific label. label_wise_nagetive_answered(label) : Gets the count of negative answers for a specific label. label_wise_result() : Gets label-wise results in a dictionary format. picked_labels_dict() : Gets a dictionary containing picked labels' results and the overall result. packed_labels() : Creates a DataFrame from the picked labels' results. It's used to extract rows for use in JS's series. label_data_history() : Gets historical label data as a list of dictionaries. Usage and Customization The LabelWiseData class is a powerful tool for calculating and retrieving label-wise evaluation data. Developers can use the properties and methods provided by this class to perform various data calculations, such as percentages, counts, and historical data. While the class is designed for general use, developers can customize its behavior or extend its functionality to meet specific requirements. This flexibility allows for a wide range of data analysis and reporting possibilities. For more details about how to use these properties and methods effectively, please refer to the code comments or reach out for further assistance. Below README focusing on the nreport_context function and its purpose in generating comprehensive PDF report contexts for evaluators. Function Details nreport_context(request, slug) : This function generates a comprehensive PDF report context for a given evaluator. It accepts two arguments: request (the HTTP request object) and slug (the unique identifier of the evaluator). The function performs various tasks to prepare the context for generating a report PDF: Clears the evaluator session variable to allow editing the report. Clears unnecessary session variables for completed reports. Retrieves the evaluator report using the provided slug. Creates a LabelWiseData instance for the evaluator. Generates data for the PDF report, including label data and label data history. Retrieves evaluation data for the evaluator. Retrieves evaluator labels and statements. Retrieves ordered next activities for the evaluator. Calculates the percentage of answered questions for the report. Determines the status of next activities (completed, not completed, not started, or unknown). Prepares the report context dictionary, including evaluation data, labels, statements, next activities, and more. Usage and Customization The nreport_context function is a critical component for generating PDF reports for evaluators in the Evaluation app. Developers can use this function to create comprehensive report contexts tailored to their specific requirements. The function is designed to retrieve data, perform calculations, and organize it into a context dictionary that can be passed to PDF generation functions or templates. While the provided code is a substantial part of the PDF report generation process, developers can further customize and extend it to meet their specific reporting needs. The code includes comments to help developers understand each step of the process. For more details about how this function works, please refer to the code comments or reach out for further assistance. This README provides an overview of the last two functions in the helper.py file of the Evaluation app. Function Details get_sugested_questions(request) : This function retrieves suggested questions submitted by the current user. It accepts a request argument, which contains user information. The function filters Suggestions objects based on the current user, type 'question,' and no associated question. The resulting QuerySet contains suggested questions submitted by the user. get_picked_na(question) : This function retrieves active next activities that involve a specific question. It accepts a question argument (the Question object to check for inclusion in next activities). The function first retrieves all active NextActivities objects. It then iterates through these next activities and checks if the specified question is involved. The function returns a list of active NextActivities objects that include the specified question. Usage and Customization Developers can use these functions to retrieve and work with suggested questions and active next activities involving specific questions. get_sugested_questions(request) : Developers can call this function to retrieve suggested questions submitted by the current user. It is useful for managing user-generated content. get_picked_na(question) : This function helps developers find active next activities related to a particular question. It can be useful for determining the flow of activities based on user responses. Customization of these functions may be required to meet specific project requirements. Developers can refer to code comments for more details on how these functions work. For any further assistance or information on using these functions, please consult the code comments or contact the development team. ======================= Evaluation App - signals.py ======================= This README provides comprehensive information about the signals.py module in the Evaluation app, including the purpose of the signals, their usage, and customization options. Signals Overview The signals.py module contains custom signals and signal handlers used to perform specific actions during database transactions. Signals are a way to allow certain senders to notify a set of receivers that an action has taken place. In this context, the signals are used for database-related actions and provide flexibility in managing data changes. Signal: on_transaction_commit(func) This custom signal is implemented as a decorator ( on_transaction_commit ) that wraps a function. Purpose: To execute a function after a database transaction is committed, ensuring that the function runs only when changes to the database are finalized. Args: func (callable): The function to be executed after the transaction is committed. Usage: The decorator @on_transaction_commit can be applied to functions that need to run after database transactions. Customization: Developers can use this decorator to create functions that respond to specific database changes once they are confirmed. Signal: delete_option_sets(sender, instance, kwargs)** This signal handler is executed when a LogicalString instance is deleted. Purpose: To delete associated OptionSet objects when a LogicalString is deleted, ensuring proper data cleanup. Args: sender : The sender of the signal ( LogicalString ). instance : The instance of the LogicalString being deleted. **kwargs : Additional keyword arguments. Usage: This signal handler is automatically triggered when a LogicalString is deleted, and it takes care of deleting related OptionSet instances. Customization: Developers can customize this signal handler to perform additional actions or validations during LogicalString deletion. Signal: recreate_option_sets(sender, instance, kwargs)** This signal handler is executed when a LogicalString instance is saved or updated. Purpose: To recreate OptionSet objects based on changes in LogicalString , ensuring that the two are synchronized. Args: sender : The sender of the signal ( LogicalString ). instance : The instance of the LogicalString being saved. **kwargs : Additional keyword arguments. Usage: This signal handler is automatically triggered when a LogicalString is saved or updated. It collects saved logical strings, compares them with existing OptionSet instances, and ensures synchronization. Customization: Developers can modify this signal handler to include additional logic or conditions based on project requirements. Signal: add_question_to_the_oil(sender, instance, created, kwargs)** This signal handler is executed when a new OliList instance is created. Purpose: To assign all active questions to the newly created oil, ensuring that questions are associated with the oil from the beginning. Args: sender : The sender of the signal ( OliList ). instance : The instance of the OliList being saved. created (bool): True if a new object is created, False if an existing one is saved. **kwargs : Additional keyword arguments. Usage: This signal handler is triggered when a new oil is created. It fetches all active questions and associates them with the oil using StandaredChart instances. Customization: Developers can customize this signal handler to include additional logic or conditions when associating questions with oils. Signal: on_option_change(sender, instance, kwargs)** This signal handler is executed before saving an Option instance. Purpose: To detect changes in Option objects and notify evaluators accordingly. Args: sender : The sender of the signal ( Option ). instance : The instance of the Option being saved. **kwargs : Additional keyword arguments. Usage: This signal handler is triggered when an Option is about to be saved. It checks for changes in the Option fields and updates the feedback_updated status for relevant evaluators. Customization: Developers can modify this signal handler to include additional checks, notifications, or conditions based on project requirements. Signal: add_to_the_user_next(sender, instance, created, kwargs)** This signal handler is executed when a new NextActivities instance is created. Purpose: To add a NextActivity to a user's list of upcoming activities and send email notifications. Args: sender : The sender of the signal ( NextActivities ). instance : The instance of the NextActivities being saved. created (bool): True if a new object is created, False if an existing one is saved. **kwargs : Additional keyword arguments. Usage: This signal handler is triggered when a new NextActivities instance is created. It adds the activity to the user's list of upcoming activities and sends email notifications to the creator and other users involved. Customization: Developers can customize this signal handler to include additional notification methods, content, or recipients as needed. Signal Usage and Customization Developers can use these signals and signal handlers to automate actions, maintain data consistency, and respond to database changes effectively. By understanding the purpose and behavior of each signal, developers can customize them to meet specific project needs. For further details on the usage, customization, and integration of these signals in your project, consult the code comments or reach out to the development team for assistance. ======================= Evaluation App - models.py ======================= This README provides comprehensive information about the models.py module in the Evaluation app, including the purpose of the defined models and any custom validators used. Custom Validator: get_common_status(value) This custom validator is used to ensure that there is only one common status entry in DefinedLabel objects. Purpose: To validate that only one DefinedLabel object can have the common_status field set to True . Args: value : The value to check (usually 1 for common status). Raises: ValidationError : Raised if there is already a common status defined. Usage: This validator is applied to the common_status field of DefinedLabel models to prevent the creation of multiple common status entries. Customization: Developers can use this validator to enforce specific constraints on the common_status field as needed. Model: DefinedLabel This model serves as a database connector for labels used site-wide. Labels are used in reports and question settings in the admin. Only one common status can exist. Fields: name : A character field for the label's name (max length: 252). label : A character field for additional label information (max length: 252, default: ''). adj : A character field for label adjustments (max length: 252, default: ''). common_status : A boolean field indicating whether this label is a common status, with a custom validator to ensure uniqueness. sort_order : A character field for sorting the labels (max length: 3, default: 0). Usage: This model is used to define labels that are used throughout the application. It enforces the uniqueness of common status labels. Customization: Developers can extend this model or modify its fields to suit specific project requirements. Function: generate_uuid() This function generates a hexadecimal code for slug URLs, currently used only on questions. Purpose: To generate a unique identifier for slug URLs. Usage: This function can be used wherever unique slugs are required, such as in question URLs. Customization: Developers can customize this function or its usage based on project needs. For further details on the usage, customization, and integration of these models and validators in your project, consult the code comments or reach out to the development team for assistance. Model: Question This model serves as a database connection for questions within the Evaluation app. Key Features: slug : A unique character field (max length: 40) generated using generate_uuid() for slug URLs. Not editable. name : A character field for the question's name (max length: 252). chapter_name : A character field for the chapter name associated with the question (max length: 252, nullable). parent_question : A foreign key reference to another Question instance, representing the parent question (self-referential, nullable). sort_order : An integer field used for sorting questions (default: 1). description : A text field for the question's description. is_active : A boolean field indicating the question's active status (default: False). is_door : A boolean field indicating whether the question is a \"door\" question (default: False). chart_title : A character field for the chart title associated with the question (max length: 252, nullable). create_date : A datetime field indicating the creation date (auto-generated, nullable). update_date : A datetime field indicating the last update date (auto-generated, nullable). Model Functions and Properties: get_absolute_url() : Get the URL for browsing an individual question for editing (not used in the evaluation procedure). add_quatation : Get the URL for adding a quotation to the question. labels : Get labels related to this question. get_related_quotations : Get related quotations for this question. get_quotations : Get quotations associated with this question. get_merged_quotations : Get merged quotations, including related and associated quotations. get_options : Get options for this question. get_stdoils : Get standard oils associated with this question. have_4labels() : Check if the question has at least 4 labels. problem_in_option : Check for problems in question options. not_is_door_nor_have_parent : Check if the question is neither a door nor has a parent. get_sugestions() : Get suggestions related to this question. Additional Notes: The Question model is used to represent questions and their properties within the Evaluation app. It provides various methods and properties to access related data and perform checks on question attributes. For further details on the usage, customization, and integration of this model and its associated functions in your project, consult the code comments or reach out to the development team for assistance. Model: Label This model serves as a database connection for labels. Key Features: name : A foreign key reference to a DifinedLabel instance using on_delete=models.PROTECT , limiting choices to those with common_status set to False . question : A foreign key reference to a Question instance using on_delete=models.CASCADE . value : A character field (max length: 1) that follows business logic. Model: Option This model serves as a database connection for options. Key Features: name : A character field (max length: 252) for the option's name. yes_status : A boolean field indicating whether the option represents 'Yes' (default: False). dont_know : A boolean field indicating whether the option represents 'Don't Know' (default: False). question : A foreign key reference to a Question instance using on_delete=models.CASCADE . next_question : A foreign key reference to a Question instance (nullable) representing the next question during the evaluation process. statement : A text field (nullable) for a statement printed under the label in the report and question page. next_step : A text field (nullable) for the next step printed under the label based on business logic in report and question forms. overall : A character field (max length: 1, default: 0) used to determine if the statement should be added to the summary. positive : A character field (max length: 1, default: 0) used to calculate assessment under the label in the report and question form. Model: LogicalString This model serves as a database connection for logical statements based on selected options. Key Features: options : A many-to-many relationship with Option instances. text : A text field (nullable) that acts as the statement. overall : A character field (max length: 1, default: 0) used to determine if the statement should be added to the summary. positive : A character field (max length: 1, default: 0) used to calculate assessment under the label in reports and question forms. Additional Notes: The Label , Option , and LogicalString models are used to manage labels, options, and logical statements within the Evaluation app. These models have various fields and properties that are used to configure how labels, options, and statements are used in the evaluation process. For further details on the usage, customization, and integration of these models in your project, consult the code comments or reach out to the development team for assistance. Model: OptionSet This model is automatically generated during evaluation by the user and is not displayed in the admin side. Key Features: option_list : A character field (max length: 252) that is unique and indexed, representing a list of options. text : A text field for additional information. positive : A character field (max length: 1, default: 0) used for positive assessments. overall : A character field (max length: 1, default: 0) used for overall assessments. ls_id : A character field (max length: 252, default: 0) for logical string identification. create_date : A datetime field indicating the creation date (auto-generated, nullable). update_date : A datetime field indicating the last update date (auto-generated, nullable). Model: Lslabel This model represents labels for logical strings to be selected during the setup of logical strings. Key Features: name : A foreign key reference to a DifinedLabel instance using on_delete=models.PROTECT , limiting choices to those with common_status set to False . logical_string : A foreign key reference to a LogicalString instance using on_delete=models.CASCADE . value : A character field (max length: 1, default: 0) following business logic. Model: Biofuel This model represents the biofuel selected by the user on the initial page of evaluation. Key Features: name : A character field (max length: 252) representing the biofuel name. Model: Evaluator This model is automatically generated during evaluation by the user and should not be edited or modified from the admin side. Key Features: slug : A UUID field (auto-generated, unique, not editable, indexed) used for identification. creator : A foreign key reference to a user using on_delete=models.SET_NULL (nullable). name : A character field (max length: 252) representing the evaluator's name. email : An email field for the evaluator's email address. phone : A character field (max length: 16, nullable) for the evaluator's phone number. organization : A character field (max length: 252, nullable) for the evaluator's organization. biofuel : A foreign key reference to a Biofuel instance using on_delete=models.SET_NULL (nullable). stdoil_key : A character field (max length: 20, nullable, indexed) representing a standard oil key. create_date : A datetime field indicating the creation date (auto-generated, nullable). update_date : A datetime field indicating the last update date (auto-generated, nullable). report_generated : A boolean field (default: False) indicating whether a report has been generated. feedback_updated : A boolean field (default: False) indicating whether feedback has been updated. Model: Evaluation This model is automatically generated during evaluation by the user and is not displayed in the admin side. Key Features: evaluator : A foreign key reference to an Evaluator instance using on_delete=models.RESTRICT . option : A foreign key reference to an Option instance using on_delete=models.RESTRICT . question : A foreign key reference to a Question instance using on_delete=models.RESTRICT (nullable). Model: EvaComments This model is automatically generated during evaluation by the user and is not displayed in the admin side. Key Features: evaluator : A foreign key reference to an Evaluator instance using on_delete=models.RESTRICT . question : A foreign key reference to a Question instance using on_delete=models.RESTRICT . comments : A text field (max length: 600) for comments. Additional Notes: These models are used for various aspects of the evaluation process within the Evaluation app. They are automatically generated during the evaluation and should not be modified directly through the admin interface. For further details on the usage, customization, and integration of these models in your project, consult the code comments or reach out to the development team for assistance. Model: EvaLabel This model is automatically generated during evaluation by the user and is not displayed in the admin side. Key Features: label : A foreign key reference to a DifinedLabel instance using on_delete=models.PROTECT . evaluator : A foreign key reference to an Evaluator instance using on_delete=models.RESTRICT . sort_order : A character field (max length: 3, default: 0). create_date : A datetime field indicating the creation date (auto-generated, nullable). Model: EvaLabelStatement This model is automatically generated during evaluation by the user and is not displayed in the admin side. Key Features: evalebel : A foreign key reference to an EvaLabel instance using on_delete=models.PROTECT . question : A foreign key reference to a Question instance using on_delete=models.PROTECT (nullable). option_id : A character field (max length: 252, nullable). statement : A text field for statements (nullable). next_step : A text field for the next step (nullable). positive : A character field (max length: 1, default: 0) for positive assessments. dont_know : A boolean field (default: False) indicating 'Don't Know'. assessment : A boolean field (default: False). next_activity : A boolean field (default: False). evaluator : A foreign key reference to an Evaluator instance using on_delete=models.RESTRICT (nullable). create_date : A datetime field indicating the creation date (auto-generated, nullable). update_date : A datetime field indicating the last update date (auto-generated, nullable). Model: NextActivities This model represents the main parameters for next activities. Key Features: name_and_standard : A character field (max length: 250) representing the name and standard. short_description : A text field (max length: 152) for a brief description. descriptions : A text field for detailed descriptions. url : A URL field (nullable). priority : A character field (max length: 2) for specifying the sort order. related_questions : A many-to-many relationship with Question instances for related questions (limit choices to those with is_active set to True ). compulsory_questions : A many-to-many relationship with Question instances for compulsory questions (limit choices to those with is_active set to True ). related_percent : An integer field (default: 90). compulsory_percent : An integer field (default: 100). is_active : A boolean field (default: True) for publishing. same_tried_by : A JSON field (nullable). created_by : A foreign key reference to the user who created this instance using on_delete=models.CASCADE . create_date : A datetime field indicating the creation date (auto-generated, nullable). update_date : A datetime field indicating the last update date (auto-generated, nullable). Additional Notes: These models are used for various aspects of the evaluation process within the Evaluation app. They are automatically generated during the evaluation and should not be modified directly through the admin interface. For further details on the usage, customization, and integration of these models in your project, consult the code comments or reach out to the development team for assistance. Model: EvaluatorActivities This model represents Evaluator Activities. Attributes: evaluator (ForeignKey): A reference to the associated evaluator using on_delete=models.CASCADE . next_activity (ForeignKey): A reference to the next activity related to the evaluator using on_delete=models.CASCADE . related_percent (IntegerField): Related percentage. compulsory_percent (IntegerField): Compulsory percentage. is_active (BooleanField): Indicates whether the activity is active or not. create_date (DateTimeField): Date and time of creation (auto-generated, nullable). update_date (DateTimeField): Date and time of the last update (auto-generated, nullable). Methods: __str__() : Returns a string representation of the next activity's name and standard. Model: OliList This model represents Defined Oils. Attributes: name (CharField): The name of the defined oil (unique). key (CharField): A unique key generated based on the name. Methods: __str__() : Returns the name of the defined oil. save() : Overrides the default save method to generate and save the key based on the name. Model: StdOils This model represents Standard Oils. Attributes: select_oil (ForeignKey): A reference to the selected oil from OliList using on_delete=models.CASCADE . biofuel (ForeignKey): A reference to the associated biofuel (nullable). Methods: __str__() : Returns the name of the selected oil. Model: StandaredChart This model represents Standard Charts. Attributes: oil (ForeignKey): A reference to the associated standard oil using on_delete=models.CASCADE . question (ForeignKey): A reference to the associated question using on_delete=models.CASCADE (limit choices to those with is_active set to True ). unit (ForeignKey): A reference to the associated weight unit (nullable). value (CharField): The value for the chart (nullable). link (URLField): A URL link (nullable). option (ChainedForeignKey): A reference to the associated option (nullable). Methods: oil_key() : Returns the lowercase key of the associated standard oil. __str__() : Returns the name of the associated standard oil. Additional Notes: These models are used to represent various aspects of the evaluation process and standard chart information within the Evaluation app. Ensure that you follow the specific constraints and relationships defined in these models to maintain data integrity and functionality. Refer to the model methods for additional functionality and customization options. Model: Youtube_data This model is used to store YouTube data for specific search terms. Attributes: term (TextField): The search term for YouTube data. urls (TextField): URLs related to the search term. create_date (DateTimeField): Date and time of creation (auto-generated, nullable). update_date (DateTimeField): Date and time of the last update (auto-generated, nullable). Methods: __str__() : Returns the search term as a string. Model: LabelDataHistory This model is used to store Label Data History. Attributes: evaluator (ForeignKey): A reference to the associated evaluator using on_delete=models.CASCADE . items (TextField): History of labeled items (limited to 250 characters). created (DateTimeField): Date and time of creation (auto-generated, nullable). Methods: __str__() : Returns the items history as a string. Meta: verbose_name : 'Label Data History' verbose_name_plural : 'Label Data Histories' Model: ReportMailQueue This model is used to queue report mail sending tasks. Attributes: to (CharField): Email address of the recipient. from_report (ForeignKey): The sender (Evaluator) of the report using on_delete=models.CASCADE . new_report (ForeignKey): The report being sent using on_delete=models.CASCADE . added_at (DateTimeField): Date and time when the report was added to the queue (auto-generated). processed (BooleanField): Indicates whether the task has been processed. process_time (DateTimeField): Date and time of processing (auto-generated). tried (IntegerField): Number of attempts to send the report. Methods: __str__() : Returns the recipient's email address as a string. Note: The mail queues will be executed by crontab and are created during the saving of BlogPost. Model: Suggestions This model is used to store user suggestions. Attributes: question (ForeignKey): A reference to the associated question (nullable). su_type (CharField): Type of suggestion ('question' or 'option'). title (CharField): Title of the suggestion. statement (TextField): The suggestion statement. suggested_by (ForeignKey to User): The user who suggested the idea. parent (ForeignKey to self): The parent suggestion (nullable, used for replies). related_qs (ForeignKey to self): Related suggestion (nullable, for cross-reference). comitted (BooleanField): Indicates whether the suggestion has been committed. created (DateTimeField): Date and time of creation (auto-generated). updated (DateTimeField): Date and time of the last update (auto-generated). Methods: __str__() : Returns the title of the suggestion. Meta: verbose_name : 'Suggestion' Note: The 'question' field is nullable, allowing suggestions without an associated question. ========================================================= ReportPDFData Class of nreport_class.py of EVALUATION APP ========================================================= The ReportPDFData class is an essential part of the Evaluation APP, responsible for generating PDF reports based on evaluation data. This class initializes various styles and settings for formatting the PDF report, draws images and content on the pages, and organizes different sections of the report. Initialization \u00b6 To create a ReportPDFData object, you need to provide two parameters: request and slug . These parameters are required for constructing the report. request : The Django request object. slug : The slug for the Evaluator object. Attributes \u00b6 This class has several attributes used for styling and formatting the report: pagesize : The page size (A4 by default). PH and PW : Page height and width. M : Margin size. styles : Sample styles for text formatting. title , t_additional , author , creator , and producer : Information about the report. stylesN , stylesH1 , stylesH2 , stylesH3 , stylesH4 , stylesH5 , stylesH6 , stylesT , stylesB : Styles for different text elements. stylesB.alignment : Text alignment. Custom paragraph styles like TitleR , SectionT , LeftIndent , and Footer . stylesTR , SectionT , LeftIndent , Footer : References to the custom paragraph styles. title_font_size : Font size for report titles. Methods \u00b6 This class contains various methods to generate different parts of the PDF report, including: report_initial(c, doc) : Draws an initial image on the report's first page. top_string(c, doc) : Adds a top string with the project title to the report. Methods to create horizontal lines with different widths: uline , uline34 , uline100 , ulineDG100 , and ulineG100 . first_page(c, doc) : Generates the content for the first page of the report. later_page(c, doc) : Generates the content for pages after the first page of the report. wrapped_pdf() : Generates the content of the wrapped PDF report. basic_summary() : Generates the basic summary section of the report. desclimar_and_content() : Generates the disclaimer and content section of the report. grape_status() : Generates the grape status section of the report. points_status() : Generates the points status section of the report. todos() : Generates the list of todos section of the report. summary_statement() : Generates the summary statement section of the report. question_specific_feedback() : Generates the question-specific feedback section of the report. details_of_activities() : Generates the details of activities section of the report. biofuel_history() : Generates the biofuel history section of the report. Usage \u00b6 To use the ReportPDFData class, you need to initialize an instance with the required parameters and then call the appropriate methods to generate the report content. The resulting content can be added to a PDF document. Example Usage \u00b6 ```python # Initialize the ReportPDFData object report_data = ReportPDFData(request, slug) # Create a PDF document pdf_doc = SimpleDocTemplate(\"evaluation_report.pdf\") # Generate the report content report_content = report_data.wrapped_pdf() # Build the PDF document with the report content pdf_doc.build(report_content) ``` ===================================== sitemaps.py - Evaluation APP Sitemaps ===================================== This module defines sitemaps for the Evaluation APP within the GFVP (Green Fuel Validation Platform) website. Sitemaps are used to inform search engines about the structure and hierarchy of your site's URLs, helping improve SEO and discoverability. GfvpSitemap \u00b6 :class: GfvpSitemap is the main sitemap for the GFVP website. It includes various important URLs for the website. Attributes: - priority (float): The priority of this sitemap in relation to others (0.0 to 1.0). - changefreq (str): The expected change frequency of URLs in this sitemap. Methods: - items() : Define the list of URLs to include in the sitemap. - location(item) : Generate the URL for a given item using its name. UserSitemap \u00b6 :class: UserSitemap is responsible for sitemapping user profiles on the GFVP website. It includes user profiles who are active and have verified email addresses. Attributes: - changefreq (str): The expected change frequency of URLs in this sitemap. - priority (float): The priority of this sitemap in relation to others (0.0 to 1.0). Methods: - items() : Retrieve the list of active users with verified email addresses. - lastmod(obj) : Determine the last modification date for a user profile. - location(obj) : Generate the URL for a user's profile. UserTypeSitemap \u00b6 :class: UserTypeSitemap is responsible for sitemapping user types on the GFVP website. It includes active user types. Attributes: - changefreq (str): The expected change frequency of URLs in this sitemap. - priority (float): The priority of this sitemap in relation to others (0.0 to 1.0). Methods: - items() : Retrieve the list of active user types. - lastmod(obj) : Determine the last modification date for a user type. - location(obj) : Generate the URL for a user type page. BlogSitemap \u00b6 :class: BlogSitemap is responsible for sitemapping blog posts on the GFVP website. It includes published blog posts. Attributes: - changefreq (str): The expected change frequency of URLs in this sitemap. - priority (float): The priority of this sitemap in relation to others (0.0 to 1.0). Methods: - items() : Retrieve the list of published blog posts. - lastmod(obj) : Determine the last modification date for a blog post. - location(obj) : Generate the URL for a blog post. HtmlReportSitemap \u00b6 :class: HtmlReportSitemap is responsible for sitemapping generated evaluation reports on the GFVP website. It includes evaluation reports with verified email addresses. Attributes: - changefreq (str): The expected change frequency of URLs in this sitemap. - priority (float): The priority of this sitemap in relation to others (0.0 to 1.0). Methods: - items() : Retrieve the list of generated evaluation reports. - lastmod(obj) : Determine the last modification date for an evaluation report. - location(obj) : Generate the URL for an evaluation report. For detailed information on each sitemap class, their methods, and attributes, please refer to the code comments and docstrings provided within sitemaps.py . ============================= urls.py - Evaluation APP URLs ============================= This module defines the URL patterns for the Evaluation APP within the GFVP (Green Fuel Validation Platform) website. It also includes the configuration of sitemaps for various sections of the website. Sitemaps Configuration \u00b6 The following sitemaps are configured for different sections of the website: static : Sitemap for static URLs active_users : Sitemap for active user profiles user_types : Sitemap for user types blog_list : Sitemap for blog posts HtmlReportitemap : Sitemap for HTML reports URL Patterns \u00b6 The URL patterns are organized into two main sections: core patterns and additional patterns for the 'evaluation' app. Core URL Patterns: \u00b6 evaluation/thanks/ : URL for the 'thanks' view. evaluation/report/<str:slug> : URL for the 'report' view with a dynamic slug parameter. evaluation/nreport/<str:slug> : URL for the 'nreport' view with a dynamic slug parameter. evaluation/nreport_pdf/<str:slug> : URL for the 'nreport_pdf' view with a dynamic slug parameter. get-glossary/ : URL for the 'get_glossary' view. sitemap.xml/ : URL for the sitemap view, which uses Django's sitemap framework to generate sitemaps for search engines. Additional URL Patterns for the 'evaluation' App: \u00b6 evaluation2/ : URL for the 'eva_index2' view. evaluation2/option_add/ : URL for the 'option_add2' view. evaluation2/<int:evaluator_id>/<str:slug> : URL for the 'eva_question' view with dynamic parameters. evaluation/stdoils/ : URL for the 'stdoils' view. vedio_urls/<str:search_term> : URL for the 'vedio_urls' view with a dynamic search_term parameter. std_oils_block/<str:slug> : URL for the 'std_oils_block' view with a dynamic slug parameter. quotation_block/<str:slug> : URL for the 'quotation_block' view with a dynamic slug parameter. traficlighthori/<str:last_reports> : URL for the 'trafic_light_hori' view with a dynamic last_reports parameter. fuel-history/<str:last_reports> : URL for the 'fuel_history' view with a dynamic last_reports parameter. For more details on each URL pattern and its corresponding view, please refer to the code and comments provided within urls.py . ========================= Evaluation App Views (views.py) ========================= This module contains view functions for handling various aspects of the evaluation process within the evaluation app. .. note:: This documentation provides an overview of the functions and their purposes, but it's recommended to refer to the source code for detailed implementation and usage. 1. set_evaluation Function \u00b6 Set the evaluation for a given question and evaluator. Args: question (Question): The question being evaluated. selected_option (Option): The option selected by the evaluator. evaluator (User): The user performing the evaluation. Returns: None Comments: This function first attempts to remove any existing evaluation entry for the specified question and evaluator combination. If no prior evaluation entry is found, it logs a message to indicate this. Subsequently, it creates a new evaluation entry with the provided information and saves it to the database. Example Usage: python set_evaluation(question, selected_option, evaluator) 2. set_eva_comments Function \u00b6 Set or update an evaluation comment for a given question and evaluator. Args: question (Question): The question for which the comment is provided. comment (str): The comment provided by the evaluator. evaluator (User): The user providing the comment. Returns: None Comments: Check if an evaluation comment entry already exists for the same question and evaluator. Ensure that a new comment is provided (non-empty). If a previous comment entry exists, update it with the new comment. If no previous comment entry exists, create a new one with the provided information and save it to the database. Example Usage: python set_eva_comments(question, comment, evaluator) 3. set_evastatment Function \u00b6 Set evaluation statements for a given selected option and evaluator. Args: request : The request object. selected_option (Option): The selected option being evaluated. evaluator (User): The user performing the evaluation. Returns: None Comments: Extract the question associated with the selected option. Delete previous records of non-assessment statements for the same option and evaluator. Retrieve labels associated with the question. For each label, create a new EvaLebelStatement entry for non-assessment. Delete previous records of assessment statements for the same label and evaluator. Calculate assessment statements based on answers and save them. Example Usage: python set_evastatment(request, selected_option, evaluator) 4. get_eoi Function \u00b6 Get a list of option IDs from a given list of evaluation statements. Args: eva_statement (list of EvaLebelStatement): A list of evaluation statements. Returns: list of int: A sorted list of unique option IDs found in the evaluation statements. Comments: Iterate through the list of evaluation statements. Check if each statement has a valid option ID and add it to the 'es_option_id' set. Return a sorted list of unique option IDs found in the evaluation statements. Example Usage: python eva_statements = get_evaluation_statements() eoi = get_eoi(eva_statements) 5. set_evastatement_of_logical_string Function \u00b6 Set evaluation statements based on logical strings for a given selected option and evaluator. Args: request : The request object. selected_option (Option): The selected option being evaluated. evaluator (User): The user performing the evaluation. Returns: None Comments: Review and revise the logical string. Collect saved logical strings from the admin backend. Create a list of selected options for each logical string. Get the common label for the evaluator. Delete any previous assessment records for the common label. Calculate assessment statements based on answers and save them. Example Usage: python set_evastatement_of_logical_string(request, selected_option, evaluator) 6. option_add2 Function \u00b6 Handle the submission of evaluation options and comments by authenticated users. Args: request : The HTTP request object. Returns: HttpResponseRedirect: Redirects the user to the appropriate page based on the evaluation progress. Comments: Check if the user is authenticated and has an associated evaluator session. Clear the session data to ensure a fresh start for the evaluation. Process the POST request containing the selected option, comments, and other parameters. Check if an option has been selected; otherwise, redirect with a warning. Set evaluation data for the selected option, including comments and assessment. Handle logic for requesting feedback, updating comments, and performing assessments. Determine the next question in the evaluation sequence and set it in the session. If there's no next question, mark the report as generated, create a history, and redirect to a thank-you page. Example Usage: The function is typically used as a view for handling POST requests when users submit their evaluation choices and comments. question_dataset(request) Build a dataset of questions for display in the evaluation question form. This view function prepares a dataset of questions to be displayed in the evaluation question form. It marks questions with specific colors based on their status in the current report. Args: request: The HTTP request object. Returns: dict: A dictionary representing the dataset of questions organized by their parent questions. Comments: - Get sorted questions of the current report. - Mark all questions that are part of the current report. - Identify the last question in the current report. - Check for any unanswered questions before and after the last question. - Mark questions as \"Do Not Know\" or \"No\" if applicable. - Handle the status of parent questions and their child questions. Example Usage: The function is typically used to prepare the question dataset for rendering in the evaluation question form. get_vedio_urls(search_term) Retrieve YouTube video URLs related to a search term using the YouTube Data API. Args: search_term (str): The search term to query for videos. Returns: list: A list of YouTube video URLs as embed URLs. Comments: - Constructs a search URL for the YouTube Data API. - Sends a GET request to the API with the specified parameters. - Parses the JSON response to extract video information. - Constructs embed URLs for each video and adds them to the result list. Example Usage: video_urls = get_vedio_urls(\"Python programming tutorials\") for url in video_urls: print(url) vedio_urls(request, search_term) Retrieve YouTube video URLs related to a search term and store them in the database if not already saved. Args: request: The HTTP request object. search_term (str): The search term to query for videos. Returns: HttpResponse: A rendered HTML template with the video URLs as context data. Comments: - Check if video URLs for the given search term are already saved in the database. - If saved URLs exist and are less than 7 days old, use them. Otherwise, update and save new URLs. - If no saved URLs are found, fetch video URLs using the get_vedio_urls function and save them. - Return the video URLs as context data for rendering in the 'eva_youtube.html' template. Example Usage: In a Django view, you can call this function to retrieve and display YouTube video URLs. std_oils_block(request, slug) Render a template for displaying standardized oils block for a specific question. Args: request: The HTTP request object. slug (str): The unique slug identifying the question. Returns: HttpResponse: A rendered HTML template with the question as context data. Comments: - Retrieve a specific question based on its unique slug. - Render the 'std_oils_block.html' template with the question as context data. Example Usage: Use this function as a view to display standardized oils blocks for specific questions. quotation_block(request, slug) Render a template for displaying a quotation block for a specific question. Args: request: The HTTP request object. slug (str): The unique slug identifying the question. Returns: HttpResponse: A rendered HTML template with the question and related information as context data. Comments: - Retrieve a specific question based on its unique slug using the get_all_questions function. - Determine the next activities (picked_na) related to the question using the get_picked_na function. - Render the 'quotation_block.html' template with the question and next activities as context data. Example Usage: Use this function as a view to display a quotation block for a specific question. eva_question(request, evaluator_id, slug) Render the main interface for the evaluation process. Args: request: The HTTP request object. evaluator_id: The ID of the evaluator/report being evaluated. slug: The unique slug identifying the question. Returns: HttpResponse: A rendered HTML template with the evaluation interface. Comments: - Ensure that the report generator is coming from the initial page. - Check if there is an active, unfinished report for the user. - Validate access permissions for editing reports. - Verify if the parent question has been answered as \"Yes\" to allow access to child questions. - Set the default selected option for the question. - Prepare context data for rendering the evaluation interface. Example Usage: Use this function as a view to display the main evaluation interface during the evaluation process. eva_index2 View \u00b6 This view renders the initial interface for data collection during the evaluation process. Args: - request: The HTTP request object. Returns: - HttpResponse: A rendered HTML template with the initial evaluation interface. Comments: - Essential part of the evaluation process, where login is required. - Collect initial data for the evaluation report. - Redirect users to a previously submitted question or gather initial data. - Check if a first question has been set by the admin. - Handle form submissions for initializing a new evaluation report. - Set labels for the new report. - Handle meta data for SEO purposes. Example Usage: Use this function as a view to display the initial interface for data collection during the evaluation process. thanks View \u00b6 This view renders the thank you page after completing the evaluation process. Args: - request: The HTTP request object. Returns: - HttpResponse: A rendered HTML template for the thank you page. Comments: - Essential part where login is required. - Check for the user's user type and last reports. - Calculate and display results on the thank you page. - Build report editing URLs for parents selected by the admin. - Paginate and display reports. - Handle meta data for SEO purposes. Example Usage: Use this function as a view to display the thank you page after completing the evaluation process. trafic_light_hori View \u00b6 This view renders a horizontal traffic light evaluation page based on the last available report. Args: - request: The HTTP request object. - last_reports: The ID of the last report to be used for rendering. Returns: - HttpResponse: A rendered HTML page displaying the horizontal traffic light evaluation. Note: This function retrieves data from the database, prepares it for rendering, and returns an HTML page with the evaluation results. fuel_history View \u00b6 This view renders a fuel history chart based on the data from the last available report. Args: - request: The HTTP request object. - last_reports: The ID of the last report to be used for rendering. Returns: - HttpResponse: A rendered HTML page displaying the fuel history chart. Note: This function retrieves historical fuel data from the database, prepares it for rendering, and returns an HTML page with the fuel history chart. report View \u00b6 This view renders a report page based on the provided report slug. Args: - request (HttpRequest): The HTTP request object. - slug (str): The unique slug identifier for the report. Returns: - HttpResponse: A rendered HTML page or PDF report displaying the report details. Comments: - Essential part where login is required. - Clears session data, as the report may have been marked as completed in the thank you page. - Generates a PDF report, if applicable. - Determines the status of next activities. Example Usage: Use this function as a view to display a report page based on the provided report slug. create_notification_to_consumer Function \u00b6 This function creates notifications for consumers regarding a report. Args: - report: The report for which notifications are to be created. Returns: - None Comments: - Retrieves a list of consumer emails. - Creates ConsumerMailQueue instances. - Bulk inserts the instances into the database. Example Usage: Call this function to create notifications for consumers regarding a report. nreport View \u00b6 This view renders a new report creation/editing page based on the provided report slug. Args: - request (HttpRequest): The HTTP request object. - slug (str): The unique slug identifier for the report. Returns: - HttpResponse: A rendered HTML page displaying the report creation/editing form. Comments: - Essential part where login is required. - Clears session data. - Handles report creation or editing. - Generates notifications for consumers when the 'confirm' parameter is present in the request. - Sets metadata for the page. Example Usage: Use this function as a view to display a new report creation/editing page based on the provided report slug. nreport_pdf View \u00b6 This view generates a PDF report based on ReportLab for a new evaluation report. Args: - request (HttpRequest): The HTTP request object. - slug (str): The unique slug identifier for the report. Returns: - FileResponse: An HTTP response with the generated PDF report. Comments: - Uses the ReportLab library to create a PDF report. - Sets document metadata, margins, and page size. - Generates the content (Story) for the PDF report. Example Usage: Use this function as a view to generate a PDF report for a new evaluation report. stdoils View \u00b6 This view renders a list of standard oils based on the selected biofuel. Args: - request (HttpRequest): The HTTP request object. Returns: - HttpResponse: A rendered HTML page displaying a list of standard oils. Comments: - Retrieves a list of standard oils filtered by the selected biofuel ID. - Renders the list in the 'std_oils.html' template. Example Usage: Use this function as a view to display a list of standard oils based on the selected biofuel. get_glossary View \u00b6 This view renders the glossary page with a list of glossary items. Args: - request (HttpRequest): The HTTP request object. Returns: - HttpResponse: A rendered HTML page displaying a glossary with a list of glossary items. Comments: - Retrieves a list of glossary items using 'get_all_glosaries()'. - Renders the list in the 'glossary_template.html' template. Example Usage: Use this function as a view to display a glossary page with a list of glossary items. edit_report View \u00b6 This view allows the creator of a report to edit its details. Args: - request (HttpRequest): The HTTP request object. - slug (str): The unique slug identifier for the report to be edited. Returns: - HttpResponse: A rendered HTML page displaying the report edit form. Comments: - Restricted to report creators. - Allows report creators to edit the details of a specific report. - Uses the 'EvaluatorEditForm' to handle form submission and update the report's information. Example Usage: Use this function as a view to allow report creators to edit report details. Contributing \u00b6 Contributions to the 'Evaluation' app are welcome! If you'd like to contribute, please review the contribution guidelines in the project's repository. License \u00b6 This module is distributed under the [Insert License Here] license. See the LICENSE file for more information.","title":"Evaluation"},{"location":"evaluation.html#introduction","text":"The 'custom_tags.py' module in the 'templatetags' directory of the 'Evaluation' app contains custom template filters and tags that extend the functionality of Django templates. These filters and tags are designed to enhance template rendering and provide additional features for template-based operations. This README provides an overview of the custom filters and tags available in this module.","title":"Introduction"},{"location":"evaluation.html#custom_filters_and_tags_overview","text":"brek_after_two Filter : This custom filter inserts a line break into text after a specified number of characters. Usage Example: html {{ text|brek_after_two:10 }} get_verbose_name Tag : This custom template tag retrieves the verbose name of a field in a model. Usage Example: html {% get_verbose_name instance field_name %} in_quot Filter : This filter filters quotes based on a specific user, returning only quotes associated with that user. Usage Example: html {{ quotes|in_quot:user }} offchars Filter : This filter returns characters from the end of a string, excluding the specified number of characters from the beginning. Usage Example: html {{ text|offchars:5 }} onnchars Filter : This filter returns characters from the beginning of a string, excluding the specified number of characters from the end. Usage Example: html {{ text|onnchars:5 }} listobj_for_paginator Filter : This filter paginates a list of objects and returns a paginated Page object. Usage Example: html {{ object_list|listobj_for_paginator:request }} get_options Filter : This filter retrieves options associated with a question and returns them as a list. Usage Example: html {{ question|get_options }} get_quotations_user Filter : This filter retrieves quotations related to a question for a specific user and returns them as a list. Usage Example: html {{ question|get_quotations_user:user }} get_related_quotations_user Filter : This filter retrieves related quotations for a question for a specific user and returns them as a list. Usage Example: html {{ question|get_related_quotations_user:user }} get_merged_quotations_with_user Filter : This filter retrieves merged quotations for a question with a specific user and returns them as a list. Usage Example: html {{ question|get_merged_quotations_with_user:user }} get_types_slug Template Filter : The get_types_slug custom template filter is used to retrieve the slug of a UserType based on its type. It is designed to be used within Django templates to facilitate dynamic content rendering based on user types. This filter takes one argument: type (str): The type of UserType ('is_producer', 'is_expert', 'is_consumer', 'is_marine') for which you want to retrieve the slug. Usage Example: html <!-- In a Django template --> {{ 'is_producer'|get_types_slug }} This filter returns the slug of the UserType associated with the provided type, or None if the type is not recognized. Parameters : type (str): The type of UserType ('is_producer', 'is_expert', 'is_consumer', 'is_marine'). Returns : str or None : The slug of the UserType associated with the provided type, or None if not found. Note : This filter can be used in Django templates to conditionally display content or generate links based on user types. It checks the provided type and returns the corresponding slug for the UserType, allowing you to tailor the template output based on user roles.","title":"Custom Filters and Tags Overview"},{"location":"evaluation.html#usage_instructions","text":"To use the custom filters and tags defined in 'custom_tags.py' within your Django templates, follow these steps: Import the necessary tags and filters in your template using {% load custom_tags %} . Use the custom filters and tags as shown in the usage examples above within your template code. Ensure that you include appropriate error handling and context variables in your templates when using these custom filters and tags. ========================= Evaluation App - admin.py ========================= This README provides an overview of the admin.py file for the Evaluation app. The admin.py file contains the Django admin configurations for various models within the app. Admin Configurations QuestionAdmin Displays a list of questions with sorting and filtering options. Includes inlines for Labels and Options related to questions. Custom CSS styling is applied to the admin view. Custom change list template to display error notes about question configurations. Custom changelist_view method to add context data about questions with incomplete configurations. OptionAdmin Displays a list of options with filtering options. Inherits from ExportActionMixin to provide export functionality. BiofuelAdmin Provides inlines for StdOils. EvaLebelStatementAdmin Displays a list of evaluation label statements with filtering options. StdOilsAdmin Displays a list of standard oils with inlines for StandaredCharts. Custom CSS styling is applied to the admin view. SuggestionsAdmin Displays a list of suggestions with filtering and search options. Provides readonly_fields for certain fields. LogicalStringAdmin Displays a list of logical strings with inlines for LsLabels. Custom change list template to display error notes about logical string configurations. Custom changelist_view method to add context data about logical strings with incomplete configurations. EvaluatorAdmin Displays a list of evaluators with filtering options. Provides actions to generate updated reports and notify creators. Custom check_and_notify method to execute the custom action. Provides readonly_fields for certain fields. StandaredChartAdmin Displays a list of standard charts with filtering and editing options. Custom CSS styling is applied to the admin view. NextActivitiesAdmin Provides an action to duplicate selected activities. Provides readonly_fields for certain fields. Please Note : The code comments and docstrings in admin.py provide further details about the functionality and purpose of each admin class. If you have any questions or need additional information, please refer to the comments in the code or feel free to ask for assistance. ==================== Evaluation App - apps.py ==================== This README provides an overview of the apps.py file for the Evaluation app. The apps.py file contains the configuration settings for the 'evaluation' app. App Configuration default_auto_field : Specifies the name of the default auto-generated primary key field. name : Specifies the name of the app. ready() Method The ready() method is executed when the app is ready to function within the Django project. In this method, the evaluation.signals module is imported, allowing the app to utilize signals for event handling. Example Usage To use this AppConfig in your Django project, add it to the 'INSTALLED_APPS' list in your project's settings.py file. This configuration ensures that the 'evaluation' app is integrated into your project and that its signals are loaded and available for use. python INSTALLED_APPS = [ ... 'evaluation', ... ] ======================== Evaluation App - middleware.py ======================== This README provides an overview of the middleware.py file for the Evaluation app. The middleware.py file contains the EvaMiddleware class, which is responsible for handling specific requests and sessions within the app. Middleware Overview Middleware in Django is used to process requests and responses globally before they reach the view or after they leave the view. This custom middleware class, EvaMiddleware , performs specific actions based on conditions before allowing a request to proceed to the view. Middleware Functionality Initialization : The __init__ method initializes the middleware with the provided get_response function. Request Handling : The __call__ method is the main method of the middleware, called for each incoming request. It checks conditions and manages sessions before allowing the request to proceed to the view. Usage To use this middleware, add it to the MIDDLEWARE list in your Django project's settings.py file as follows: python MIDDLEWARE = [ ... 'evaluation.middleware.EvaMiddleware', ... ] Conditions Checked The middleware checks the following conditions before processing a request: If the 'evaluator' key is present in the request session. Whether a specific setting ('CNN') is enabled in the project's settings. Customization Do not customize the EvaMiddleware class. It can cause in the evaluation process and report genaration. ======================== Evaluation App - forms.py ======================== This README provides an overview of the forms.py file for the Evaluation app. The forms.py file contains the EvaluatorForm class, which is a Django form used for creating and updating Evaluator instances. Form Overview Forms in Django are used to handle user input and validation. The EvaluatorForm class is designed to work with the Evaluator model and provides a structured way to create and update Evaluator objects. Form Functionality Meta Class : The inner Meta class defines metadata for the form, including the model and form fields. It also customizes labels for form fields. Custom Validation : The clean method is a custom form validation method that ensures the 'biofuel' selection is mandatory. If 'biofuel' is not selected, a validation error is raised. Form Fields The EvaluatorForm includes the following fields: - 'name': Name of the evaluator. - 'email': Email address of the evaluator. - 'phone': Phone number of the evaluator. - 'organization': Organization to which the evaluator belongs. - 'biofuel': A dropdown field to select a fuel type. Form Widgets and Labels Form fields are customized with widgets to control their appearance in the HTML form. Custom labels are defined to provide clear field descriptions. Usage Developers can use this form in their views to create and update Evaluator instances. After binding the form to request data, validation can be performed, and Evaluator instances can be saved or updated based on user input. Customization Developers can customize this form to suit their app's specific needs by modifying form fields, widgets, labels, or adding additional validation logic. If you have any questions or need further clarification, please refer to the comments in the code or feel free to ask for assistance. ======================== Evaluation App - helper.py ======================== This README provides an overview of the helper.py file in the Evaluation app. The helper.py file contains various functions that retrieve and cache data from the database to improve performance on subsequent calls. Function Overview The helper functions in helper.py are designed to efficiently fetch and cache specific data from the database. Each function focuses on retrieving a specific set of data related to Questions, StdOils, or Glossary. Function Details get_all_questions() : This function retrieves and caches all Question instances from the database. It first checks the cache for the presence of cached questions to avoid unnecessary database queries. If the cached data is not available, it fetches all Question instances, including related data, and caches the result for future use. The cached data is stored for 3600 seconds (1 hour) to balance data freshness and query performance. get_all_stdoils() : This function retrieves and caches all StdOils instances from the database. Similar to get_all_questions() , it checks for cached data and fetches StdOils instances with related data if not already cached. The cached data is also stored for 3600 seconds. get_all_glossaries() : This function retrieves and caches all Glossary instances from the database. Like the previous functions, it checks the cache for existing data and fetches Glossary instances if needed. Cached data is stored for 3600 seconds. get_all_definedlabel() : This function retrieves and caches all DifinedLabel instances from the database. It follows a similar pattern as previous functions, checking for cached data and fetching DifinedLabel instances if not already cached. Cached data is stored for 3600 seconds. get_all_reports_with_last_answer(request, first_of_parent) : This function retrieves and caches reports (evaluators) with their last answered questions. It accepts two arguments: request (the HTTP request object) and first_of_parent (the first question of the parent questionnaire). The function distinguishes between superusers or staff and regular users when fetching reports. For each report, it determines the last answered question and stores its slug. Cached data is stored for 3600 seconds. get_biofuel() : This function retrieves and caches all Biofuel instances from the database. Similar to other functions, it checks for cached data and fetches Biofuel instances if needed. Cached data is stored for 3600 seconds. get_options_of_ques(question) : This function retrieves and caches all options related to a specific question. It accepts a question argument (the question for which options are retrieved). Cached data is stored using a key based on the question's ID and is stored for 3600 seconds. get_sugestions_of_ques(question) : This function retrieves and caches all suggestions related to a specific question. It accepts a question argument (the question for which suggestions are retrieved). Suggestions are ordered by creation date. Cached data is stored using a key based on the question's ID and is stored for 3600 seconds. active_sessions() : This function retrieves evaluator IDs from active sessions in the past 24 hours. It uses Django's Session model to fetch sessions that have not expired within the last 24 hours. Active evaluator IDs are stored in a set to ensure uniqueness. The function returns a list of evaluator IDs. clear_evaluator() : This function clears incomplete evaluators and their related data from the database. It is designed to run as a scheduled background task (e.g., via a CRON job) to maintain a clean database. Incomplete evaluators are those that were initialized but have no associated data and have not generated a report. The function fetches incomplete evaluators, checks if they are active in sessions, and deletes them along with their related data. The deletion sequence is carefully managed to avoid foreign key constraints. The function returns the total number of incomplete evaluators deleted during the process. get_current_evaluator(request, evaluator_id=None) : This function retrieves the current evaluator object based on the provided evaluator_id or the evaluator_id stored in the user's session. It is assumed that the middleware ensures 'evaluator' exists in the session. Developers can use this function to retrieve the current evaluator or a specific evaluator by ID. If no evaluator is found, it logs a debug message indicating the issue. Below provides detailed information on the EvaLebelStatementAnalyzer class in the Evaluation app's helper.py file. The class is responsible for analyzing evaluation statements related to EvaLebel and generating assessment statements based on various criteria related to EvaLebel evaluations. Class Details EvaLebelStatementAnalyzer : A class for analyzing evaluation statements related to EvaLebel. Provides methods for generating assessment statements based on various criteria. Accepts two arguments during initialization: evalebel (an instance of EvaLebel representing the evaluation label) and evaluator (an instance representing the evaluator). Methods get_statement_count(values_key, **filter_kwargs) : Get the count of distinct statements based on filtering criteria. Accepts a values_key for grouping and counting and additional filter criteria as keyword arguments. Returns the count of distinct statements based on the filter criteria. get_dont_know_statement(label_name, value_count) : Generate a statement based on the value count for \"don't know\" evaluations. Accepts label_name (the name of the evaluation label) and value_count (the count of \"don't know\" evaluations). Returns a statement describing the assessment based on the value count. get_positive_statement(label_name, value_count) : Generate a statement based on the value count for positive evaluations. Accepts label_name (the name of the evaluation label) and value_count (the count of positive evaluations). Returns a statement describing the assessment based on the value count. ans_to_the_label() : Get the count of answers related to the evaluation label. Returns the count of answers related to the evaluation label. calculate_percentage(ans_to_the_lavel) : Calculate the percentage based on answers related to the evaluation label. Accepts ans_to_the_label (the count of answers related to the evaluation label). Returns the percentage calculated based on the given count. label_assessment_for_donot_know() : Generate an assessment statement for \"don't know\" evaluations related to the label. Returns an assessment statement based on \"don't know\" evaluations. label_assessment_for_positive() : Generate an assessment statement for positive evaluations related to the label. Returns an assessment statement based on positive evaluations. ans_ques() : Get the count of answerable questions. Returns the count of answerable questions. calculate_overall_percent(ans) : Calculate the overall percentage based on the given count. Accepts ans (the count used to calculate the overall percentage). Returns the overall percentage calculated based on the given count. overall_assessment_for_donot_know() : Generate an overall assessment statement for \"don't know\" evaluations. Returns an overall assessment statement based on \"don't know\" evaluations. overall_assessment_for_positive() : Generate an overall assessment statement for positive evaluations. Returns an overall assessment statement based on positive evaluations. Usage and Customization The EvaLebelStatementAnalyzer class is designed to analyze and generate assessment statements for EvaLebel evaluations. Developers can use its methods to provide valuable insights and feedback to evaluators. Each method has specific functionality and can be customized as needed to tailor assessment statements based on different criteria and scenarios. For more information about the usage of these methods and customizations, please refer to the code comments or reach out for further assistance. Below README focusing on a class named LabelWiseData . This class is designed to handle various data calculations and retrievals related to label-wise evaluation. Class Details LabelWiseData : This class is designed to perform label-wise data calculations and retrievals. The class is initialized with an evaluator , which can be obtained from the session or URL. Properties : answered_question_id_list : Gets a list of unique answered question IDs. total_active_questions : Gets the total count of active questions with four labels. answered_percent : Calculates the percentage of answered questions out of total active questions. total_positive_answer : Gets the total count of positive answers. total_nagetive_answer : Gets the total count of negative answers. overview_green : Calculates the percentage of positive answers out of total active questions. overview_red : Calculates the percentage of negative answers out of total active questions. overview_grey : Calculates the percentage of answers that are neither positive nor negative out of total active questions. Methods : total_result() : Gets the overall results in a dictionary format, considering green, grey, and red as stackable bars. label_wise_positive_answered(label) : Gets the count of positive answers for a specific label. label_wise_nagetive_answered(label) : Gets the count of negative answers for a specific label. label_wise_result() : Gets label-wise results in a dictionary format. picked_labels_dict() : Gets a dictionary containing picked labels' results and the overall result. packed_labels() : Creates a DataFrame from the picked labels' results. It's used to extract rows for use in JS's series. label_data_history() : Gets historical label data as a list of dictionaries. Usage and Customization The LabelWiseData class is a powerful tool for calculating and retrieving label-wise evaluation data. Developers can use the properties and methods provided by this class to perform various data calculations, such as percentages, counts, and historical data. While the class is designed for general use, developers can customize its behavior or extend its functionality to meet specific requirements. This flexibility allows for a wide range of data analysis and reporting possibilities. For more details about how to use these properties and methods effectively, please refer to the code comments or reach out for further assistance. Below README focusing on the nreport_context function and its purpose in generating comprehensive PDF report contexts for evaluators. Function Details nreport_context(request, slug) : This function generates a comprehensive PDF report context for a given evaluator. It accepts two arguments: request (the HTTP request object) and slug (the unique identifier of the evaluator). The function performs various tasks to prepare the context for generating a report PDF: Clears the evaluator session variable to allow editing the report. Clears unnecessary session variables for completed reports. Retrieves the evaluator report using the provided slug. Creates a LabelWiseData instance for the evaluator. Generates data for the PDF report, including label data and label data history. Retrieves evaluation data for the evaluator. Retrieves evaluator labels and statements. Retrieves ordered next activities for the evaluator. Calculates the percentage of answered questions for the report. Determines the status of next activities (completed, not completed, not started, or unknown). Prepares the report context dictionary, including evaluation data, labels, statements, next activities, and more. Usage and Customization The nreport_context function is a critical component for generating PDF reports for evaluators in the Evaluation app. Developers can use this function to create comprehensive report contexts tailored to their specific requirements. The function is designed to retrieve data, perform calculations, and organize it into a context dictionary that can be passed to PDF generation functions or templates. While the provided code is a substantial part of the PDF report generation process, developers can further customize and extend it to meet their specific reporting needs. The code includes comments to help developers understand each step of the process. For more details about how this function works, please refer to the code comments or reach out for further assistance. This README provides an overview of the last two functions in the helper.py file of the Evaluation app. Function Details get_sugested_questions(request) : This function retrieves suggested questions submitted by the current user. It accepts a request argument, which contains user information. The function filters Suggestions objects based on the current user, type 'question,' and no associated question. The resulting QuerySet contains suggested questions submitted by the user. get_picked_na(question) : This function retrieves active next activities that involve a specific question. It accepts a question argument (the Question object to check for inclusion in next activities). The function first retrieves all active NextActivities objects. It then iterates through these next activities and checks if the specified question is involved. The function returns a list of active NextActivities objects that include the specified question. Usage and Customization Developers can use these functions to retrieve and work with suggested questions and active next activities involving specific questions. get_sugested_questions(request) : Developers can call this function to retrieve suggested questions submitted by the current user. It is useful for managing user-generated content. get_picked_na(question) : This function helps developers find active next activities related to a particular question. It can be useful for determining the flow of activities based on user responses. Customization of these functions may be required to meet specific project requirements. Developers can refer to code comments for more details on how these functions work. For any further assistance or information on using these functions, please consult the code comments or contact the development team. ======================= Evaluation App - signals.py ======================= This README provides comprehensive information about the signals.py module in the Evaluation app, including the purpose of the signals, their usage, and customization options. Signals Overview The signals.py module contains custom signals and signal handlers used to perform specific actions during database transactions. Signals are a way to allow certain senders to notify a set of receivers that an action has taken place. In this context, the signals are used for database-related actions and provide flexibility in managing data changes. Signal: on_transaction_commit(func) This custom signal is implemented as a decorator ( on_transaction_commit ) that wraps a function. Purpose: To execute a function after a database transaction is committed, ensuring that the function runs only when changes to the database are finalized. Args: func (callable): The function to be executed after the transaction is committed. Usage: The decorator @on_transaction_commit can be applied to functions that need to run after database transactions. Customization: Developers can use this decorator to create functions that respond to specific database changes once they are confirmed. Signal: delete_option_sets(sender, instance, kwargs)** This signal handler is executed when a LogicalString instance is deleted. Purpose: To delete associated OptionSet objects when a LogicalString is deleted, ensuring proper data cleanup. Args: sender : The sender of the signal ( LogicalString ). instance : The instance of the LogicalString being deleted. **kwargs : Additional keyword arguments. Usage: This signal handler is automatically triggered when a LogicalString is deleted, and it takes care of deleting related OptionSet instances. Customization: Developers can customize this signal handler to perform additional actions or validations during LogicalString deletion. Signal: recreate_option_sets(sender, instance, kwargs)** This signal handler is executed when a LogicalString instance is saved or updated. Purpose: To recreate OptionSet objects based on changes in LogicalString , ensuring that the two are synchronized. Args: sender : The sender of the signal ( LogicalString ). instance : The instance of the LogicalString being saved. **kwargs : Additional keyword arguments. Usage: This signal handler is automatically triggered when a LogicalString is saved or updated. It collects saved logical strings, compares them with existing OptionSet instances, and ensures synchronization. Customization: Developers can modify this signal handler to include additional logic or conditions based on project requirements. Signal: add_question_to_the_oil(sender, instance, created, kwargs)** This signal handler is executed when a new OliList instance is created. Purpose: To assign all active questions to the newly created oil, ensuring that questions are associated with the oil from the beginning. Args: sender : The sender of the signal ( OliList ). instance : The instance of the OliList being saved. created (bool): True if a new object is created, False if an existing one is saved. **kwargs : Additional keyword arguments. Usage: This signal handler is triggered when a new oil is created. It fetches all active questions and associates them with the oil using StandaredChart instances. Customization: Developers can customize this signal handler to include additional logic or conditions when associating questions with oils. Signal: on_option_change(sender, instance, kwargs)** This signal handler is executed before saving an Option instance. Purpose: To detect changes in Option objects and notify evaluators accordingly. Args: sender : The sender of the signal ( Option ). instance : The instance of the Option being saved. **kwargs : Additional keyword arguments. Usage: This signal handler is triggered when an Option is about to be saved. It checks for changes in the Option fields and updates the feedback_updated status for relevant evaluators. Customization: Developers can modify this signal handler to include additional checks, notifications, or conditions based on project requirements. Signal: add_to_the_user_next(sender, instance, created, kwargs)** This signal handler is executed when a new NextActivities instance is created. Purpose: To add a NextActivity to a user's list of upcoming activities and send email notifications. Args: sender : The sender of the signal ( NextActivities ). instance : The instance of the NextActivities being saved. created (bool): True if a new object is created, False if an existing one is saved. **kwargs : Additional keyword arguments. Usage: This signal handler is triggered when a new NextActivities instance is created. It adds the activity to the user's list of upcoming activities and sends email notifications to the creator and other users involved. Customization: Developers can customize this signal handler to include additional notification methods, content, or recipients as needed. Signal Usage and Customization Developers can use these signals and signal handlers to automate actions, maintain data consistency, and respond to database changes effectively. By understanding the purpose and behavior of each signal, developers can customize them to meet specific project needs. For further details on the usage, customization, and integration of these signals in your project, consult the code comments or reach out to the development team for assistance. ======================= Evaluation App - models.py ======================= This README provides comprehensive information about the models.py module in the Evaluation app, including the purpose of the defined models and any custom validators used. Custom Validator: get_common_status(value) This custom validator is used to ensure that there is only one common status entry in DefinedLabel objects. Purpose: To validate that only one DefinedLabel object can have the common_status field set to True . Args: value : The value to check (usually 1 for common status). Raises: ValidationError : Raised if there is already a common status defined. Usage: This validator is applied to the common_status field of DefinedLabel models to prevent the creation of multiple common status entries. Customization: Developers can use this validator to enforce specific constraints on the common_status field as needed. Model: DefinedLabel This model serves as a database connector for labels used site-wide. Labels are used in reports and question settings in the admin. Only one common status can exist. Fields: name : A character field for the label's name (max length: 252). label : A character field for additional label information (max length: 252, default: ''). adj : A character field for label adjustments (max length: 252, default: ''). common_status : A boolean field indicating whether this label is a common status, with a custom validator to ensure uniqueness. sort_order : A character field for sorting the labels (max length: 3, default: 0). Usage: This model is used to define labels that are used throughout the application. It enforces the uniqueness of common status labels. Customization: Developers can extend this model or modify its fields to suit specific project requirements. Function: generate_uuid() This function generates a hexadecimal code for slug URLs, currently used only on questions. Purpose: To generate a unique identifier for slug URLs. Usage: This function can be used wherever unique slugs are required, such as in question URLs. Customization: Developers can customize this function or its usage based on project needs. For further details on the usage, customization, and integration of these models and validators in your project, consult the code comments or reach out to the development team for assistance. Model: Question This model serves as a database connection for questions within the Evaluation app. Key Features: slug : A unique character field (max length: 40) generated using generate_uuid() for slug URLs. Not editable. name : A character field for the question's name (max length: 252). chapter_name : A character field for the chapter name associated with the question (max length: 252, nullable). parent_question : A foreign key reference to another Question instance, representing the parent question (self-referential, nullable). sort_order : An integer field used for sorting questions (default: 1). description : A text field for the question's description. is_active : A boolean field indicating the question's active status (default: False). is_door : A boolean field indicating whether the question is a \"door\" question (default: False). chart_title : A character field for the chart title associated with the question (max length: 252, nullable). create_date : A datetime field indicating the creation date (auto-generated, nullable). update_date : A datetime field indicating the last update date (auto-generated, nullable). Model Functions and Properties: get_absolute_url() : Get the URL for browsing an individual question for editing (not used in the evaluation procedure). add_quatation : Get the URL for adding a quotation to the question. labels : Get labels related to this question. get_related_quotations : Get related quotations for this question. get_quotations : Get quotations associated with this question. get_merged_quotations : Get merged quotations, including related and associated quotations. get_options : Get options for this question. get_stdoils : Get standard oils associated with this question. have_4labels() : Check if the question has at least 4 labels. problem_in_option : Check for problems in question options. not_is_door_nor_have_parent : Check if the question is neither a door nor has a parent. get_sugestions() : Get suggestions related to this question. Additional Notes: The Question model is used to represent questions and their properties within the Evaluation app. It provides various methods and properties to access related data and perform checks on question attributes. For further details on the usage, customization, and integration of this model and its associated functions in your project, consult the code comments or reach out to the development team for assistance. Model: Label This model serves as a database connection for labels. Key Features: name : A foreign key reference to a DifinedLabel instance using on_delete=models.PROTECT , limiting choices to those with common_status set to False . question : A foreign key reference to a Question instance using on_delete=models.CASCADE . value : A character field (max length: 1) that follows business logic. Model: Option This model serves as a database connection for options. Key Features: name : A character field (max length: 252) for the option's name. yes_status : A boolean field indicating whether the option represents 'Yes' (default: False). dont_know : A boolean field indicating whether the option represents 'Don't Know' (default: False). question : A foreign key reference to a Question instance using on_delete=models.CASCADE . next_question : A foreign key reference to a Question instance (nullable) representing the next question during the evaluation process. statement : A text field (nullable) for a statement printed under the label in the report and question page. next_step : A text field (nullable) for the next step printed under the label based on business logic in report and question forms. overall : A character field (max length: 1, default: 0) used to determine if the statement should be added to the summary. positive : A character field (max length: 1, default: 0) used to calculate assessment under the label in the report and question form. Model: LogicalString This model serves as a database connection for logical statements based on selected options. Key Features: options : A many-to-many relationship with Option instances. text : A text field (nullable) that acts as the statement. overall : A character field (max length: 1, default: 0) used to determine if the statement should be added to the summary. positive : A character field (max length: 1, default: 0) used to calculate assessment under the label in reports and question forms. Additional Notes: The Label , Option , and LogicalString models are used to manage labels, options, and logical statements within the Evaluation app. These models have various fields and properties that are used to configure how labels, options, and statements are used in the evaluation process. For further details on the usage, customization, and integration of these models in your project, consult the code comments or reach out to the development team for assistance. Model: OptionSet This model is automatically generated during evaluation by the user and is not displayed in the admin side. Key Features: option_list : A character field (max length: 252) that is unique and indexed, representing a list of options. text : A text field for additional information. positive : A character field (max length: 1, default: 0) used for positive assessments. overall : A character field (max length: 1, default: 0) used for overall assessments. ls_id : A character field (max length: 252, default: 0) for logical string identification. create_date : A datetime field indicating the creation date (auto-generated, nullable). update_date : A datetime field indicating the last update date (auto-generated, nullable). Model: Lslabel This model represents labels for logical strings to be selected during the setup of logical strings. Key Features: name : A foreign key reference to a DifinedLabel instance using on_delete=models.PROTECT , limiting choices to those with common_status set to False . logical_string : A foreign key reference to a LogicalString instance using on_delete=models.CASCADE . value : A character field (max length: 1, default: 0) following business logic. Model: Biofuel This model represents the biofuel selected by the user on the initial page of evaluation. Key Features: name : A character field (max length: 252) representing the biofuel name. Model: Evaluator This model is automatically generated during evaluation by the user and should not be edited or modified from the admin side. Key Features: slug : A UUID field (auto-generated, unique, not editable, indexed) used for identification. creator : A foreign key reference to a user using on_delete=models.SET_NULL (nullable). name : A character field (max length: 252) representing the evaluator's name. email : An email field for the evaluator's email address. phone : A character field (max length: 16, nullable) for the evaluator's phone number. organization : A character field (max length: 252, nullable) for the evaluator's organization. biofuel : A foreign key reference to a Biofuel instance using on_delete=models.SET_NULL (nullable). stdoil_key : A character field (max length: 20, nullable, indexed) representing a standard oil key. create_date : A datetime field indicating the creation date (auto-generated, nullable). update_date : A datetime field indicating the last update date (auto-generated, nullable). report_generated : A boolean field (default: False) indicating whether a report has been generated. feedback_updated : A boolean field (default: False) indicating whether feedback has been updated. Model: Evaluation This model is automatically generated during evaluation by the user and is not displayed in the admin side. Key Features: evaluator : A foreign key reference to an Evaluator instance using on_delete=models.RESTRICT . option : A foreign key reference to an Option instance using on_delete=models.RESTRICT . question : A foreign key reference to a Question instance using on_delete=models.RESTRICT (nullable). Model: EvaComments This model is automatically generated during evaluation by the user and is not displayed in the admin side. Key Features: evaluator : A foreign key reference to an Evaluator instance using on_delete=models.RESTRICT . question : A foreign key reference to a Question instance using on_delete=models.RESTRICT . comments : A text field (max length: 600) for comments. Additional Notes: These models are used for various aspects of the evaluation process within the Evaluation app. They are automatically generated during the evaluation and should not be modified directly through the admin interface. For further details on the usage, customization, and integration of these models in your project, consult the code comments or reach out to the development team for assistance. Model: EvaLabel This model is automatically generated during evaluation by the user and is not displayed in the admin side. Key Features: label : A foreign key reference to a DifinedLabel instance using on_delete=models.PROTECT . evaluator : A foreign key reference to an Evaluator instance using on_delete=models.RESTRICT . sort_order : A character field (max length: 3, default: 0). create_date : A datetime field indicating the creation date (auto-generated, nullable). Model: EvaLabelStatement This model is automatically generated during evaluation by the user and is not displayed in the admin side. Key Features: evalebel : A foreign key reference to an EvaLabel instance using on_delete=models.PROTECT . question : A foreign key reference to a Question instance using on_delete=models.PROTECT (nullable). option_id : A character field (max length: 252, nullable). statement : A text field for statements (nullable). next_step : A text field for the next step (nullable). positive : A character field (max length: 1, default: 0) for positive assessments. dont_know : A boolean field (default: False) indicating 'Don't Know'. assessment : A boolean field (default: False). next_activity : A boolean field (default: False). evaluator : A foreign key reference to an Evaluator instance using on_delete=models.RESTRICT (nullable). create_date : A datetime field indicating the creation date (auto-generated, nullable). update_date : A datetime field indicating the last update date (auto-generated, nullable). Model: NextActivities This model represents the main parameters for next activities. Key Features: name_and_standard : A character field (max length: 250) representing the name and standard. short_description : A text field (max length: 152) for a brief description. descriptions : A text field for detailed descriptions. url : A URL field (nullable). priority : A character field (max length: 2) for specifying the sort order. related_questions : A many-to-many relationship with Question instances for related questions (limit choices to those with is_active set to True ). compulsory_questions : A many-to-many relationship with Question instances for compulsory questions (limit choices to those with is_active set to True ). related_percent : An integer field (default: 90). compulsory_percent : An integer field (default: 100). is_active : A boolean field (default: True) for publishing. same_tried_by : A JSON field (nullable). created_by : A foreign key reference to the user who created this instance using on_delete=models.CASCADE . create_date : A datetime field indicating the creation date (auto-generated, nullable). update_date : A datetime field indicating the last update date (auto-generated, nullable). Additional Notes: These models are used for various aspects of the evaluation process within the Evaluation app. They are automatically generated during the evaluation and should not be modified directly through the admin interface. For further details on the usage, customization, and integration of these models in your project, consult the code comments or reach out to the development team for assistance. Model: EvaluatorActivities This model represents Evaluator Activities. Attributes: evaluator (ForeignKey): A reference to the associated evaluator using on_delete=models.CASCADE . next_activity (ForeignKey): A reference to the next activity related to the evaluator using on_delete=models.CASCADE . related_percent (IntegerField): Related percentage. compulsory_percent (IntegerField): Compulsory percentage. is_active (BooleanField): Indicates whether the activity is active or not. create_date (DateTimeField): Date and time of creation (auto-generated, nullable). update_date (DateTimeField): Date and time of the last update (auto-generated, nullable). Methods: __str__() : Returns a string representation of the next activity's name and standard. Model: OliList This model represents Defined Oils. Attributes: name (CharField): The name of the defined oil (unique). key (CharField): A unique key generated based on the name. Methods: __str__() : Returns the name of the defined oil. save() : Overrides the default save method to generate and save the key based on the name. Model: StdOils This model represents Standard Oils. Attributes: select_oil (ForeignKey): A reference to the selected oil from OliList using on_delete=models.CASCADE . biofuel (ForeignKey): A reference to the associated biofuel (nullable). Methods: __str__() : Returns the name of the selected oil. Model: StandaredChart This model represents Standard Charts. Attributes: oil (ForeignKey): A reference to the associated standard oil using on_delete=models.CASCADE . question (ForeignKey): A reference to the associated question using on_delete=models.CASCADE (limit choices to those with is_active set to True ). unit (ForeignKey): A reference to the associated weight unit (nullable). value (CharField): The value for the chart (nullable). link (URLField): A URL link (nullable). option (ChainedForeignKey): A reference to the associated option (nullable). Methods: oil_key() : Returns the lowercase key of the associated standard oil. __str__() : Returns the name of the associated standard oil. Additional Notes: These models are used to represent various aspects of the evaluation process and standard chart information within the Evaluation app. Ensure that you follow the specific constraints and relationships defined in these models to maintain data integrity and functionality. Refer to the model methods for additional functionality and customization options. Model: Youtube_data This model is used to store YouTube data for specific search terms. Attributes: term (TextField): The search term for YouTube data. urls (TextField): URLs related to the search term. create_date (DateTimeField): Date and time of creation (auto-generated, nullable). update_date (DateTimeField): Date and time of the last update (auto-generated, nullable). Methods: __str__() : Returns the search term as a string. Model: LabelDataHistory This model is used to store Label Data History. Attributes: evaluator (ForeignKey): A reference to the associated evaluator using on_delete=models.CASCADE . items (TextField): History of labeled items (limited to 250 characters). created (DateTimeField): Date and time of creation (auto-generated, nullable). Methods: __str__() : Returns the items history as a string. Meta: verbose_name : 'Label Data History' verbose_name_plural : 'Label Data Histories' Model: ReportMailQueue This model is used to queue report mail sending tasks. Attributes: to (CharField): Email address of the recipient. from_report (ForeignKey): The sender (Evaluator) of the report using on_delete=models.CASCADE . new_report (ForeignKey): The report being sent using on_delete=models.CASCADE . added_at (DateTimeField): Date and time when the report was added to the queue (auto-generated). processed (BooleanField): Indicates whether the task has been processed. process_time (DateTimeField): Date and time of processing (auto-generated). tried (IntegerField): Number of attempts to send the report. Methods: __str__() : Returns the recipient's email address as a string. Note: The mail queues will be executed by crontab and are created during the saving of BlogPost. Model: Suggestions This model is used to store user suggestions. Attributes: question (ForeignKey): A reference to the associated question (nullable). su_type (CharField): Type of suggestion ('question' or 'option'). title (CharField): Title of the suggestion. statement (TextField): The suggestion statement. suggested_by (ForeignKey to User): The user who suggested the idea. parent (ForeignKey to self): The parent suggestion (nullable, used for replies). related_qs (ForeignKey to self): Related suggestion (nullable, for cross-reference). comitted (BooleanField): Indicates whether the suggestion has been committed. created (DateTimeField): Date and time of creation (auto-generated). updated (DateTimeField): Date and time of the last update (auto-generated). Methods: __str__() : Returns the title of the suggestion. Meta: verbose_name : 'Suggestion' Note: The 'question' field is nullable, allowing suggestions without an associated question. ========================================================= ReportPDFData Class of nreport_class.py of EVALUATION APP ========================================================= The ReportPDFData class is an essential part of the Evaluation APP, responsible for generating PDF reports based on evaluation data. This class initializes various styles and settings for formatting the PDF report, draws images and content on the pages, and organizes different sections of the report.","title":"Usage Instructions"},{"location":"evaluation.html#initialization","text":"To create a ReportPDFData object, you need to provide two parameters: request and slug . These parameters are required for constructing the report. request : The Django request object. slug : The slug for the Evaluator object.","title":"Initialization"},{"location":"evaluation.html#attributes","text":"This class has several attributes used for styling and formatting the report: pagesize : The page size (A4 by default). PH and PW : Page height and width. M : Margin size. styles : Sample styles for text formatting. title , t_additional , author , creator , and producer : Information about the report. stylesN , stylesH1 , stylesH2 , stylesH3 , stylesH4 , stylesH5 , stylesH6 , stylesT , stylesB : Styles for different text elements. stylesB.alignment : Text alignment. Custom paragraph styles like TitleR , SectionT , LeftIndent , and Footer . stylesTR , SectionT , LeftIndent , Footer : References to the custom paragraph styles. title_font_size : Font size for report titles.","title":"Attributes"},{"location":"evaluation.html#methods","text":"This class contains various methods to generate different parts of the PDF report, including: report_initial(c, doc) : Draws an initial image on the report's first page. top_string(c, doc) : Adds a top string with the project title to the report. Methods to create horizontal lines with different widths: uline , uline34 , uline100 , ulineDG100 , and ulineG100 . first_page(c, doc) : Generates the content for the first page of the report. later_page(c, doc) : Generates the content for pages after the first page of the report. wrapped_pdf() : Generates the content of the wrapped PDF report. basic_summary() : Generates the basic summary section of the report. desclimar_and_content() : Generates the disclaimer and content section of the report. grape_status() : Generates the grape status section of the report. points_status() : Generates the points status section of the report. todos() : Generates the list of todos section of the report. summary_statement() : Generates the summary statement section of the report. question_specific_feedback() : Generates the question-specific feedback section of the report. details_of_activities() : Generates the details of activities section of the report. biofuel_history() : Generates the biofuel history section of the report.","title":"Methods"},{"location":"evaluation.html#usage","text":"To use the ReportPDFData class, you need to initialize an instance with the required parameters and then call the appropriate methods to generate the report content. The resulting content can be added to a PDF document.","title":"Usage"},{"location":"evaluation.html#example_usage","text":"```python # Initialize the ReportPDFData object report_data = ReportPDFData(request, slug) # Create a PDF document pdf_doc = SimpleDocTemplate(\"evaluation_report.pdf\") # Generate the report content report_content = report_data.wrapped_pdf() # Build the PDF document with the report content pdf_doc.build(report_content) ``` ===================================== sitemaps.py - Evaluation APP Sitemaps ===================================== This module defines sitemaps for the Evaluation APP within the GFVP (Green Fuel Validation Platform) website. Sitemaps are used to inform search engines about the structure and hierarchy of your site's URLs, helping improve SEO and discoverability.","title":"Example Usage"},{"location":"evaluation.html#gfvpsitemap","text":":class: GfvpSitemap is the main sitemap for the GFVP website. It includes various important URLs for the website. Attributes: - priority (float): The priority of this sitemap in relation to others (0.0 to 1.0). - changefreq (str): The expected change frequency of URLs in this sitemap. Methods: - items() : Define the list of URLs to include in the sitemap. - location(item) : Generate the URL for a given item using its name.","title":"GfvpSitemap"},{"location":"evaluation.html#usersitemap","text":":class: UserSitemap is responsible for sitemapping user profiles on the GFVP website. It includes user profiles who are active and have verified email addresses. Attributes: - changefreq (str): The expected change frequency of URLs in this sitemap. - priority (float): The priority of this sitemap in relation to others (0.0 to 1.0). Methods: - items() : Retrieve the list of active users with verified email addresses. - lastmod(obj) : Determine the last modification date for a user profile. - location(obj) : Generate the URL for a user's profile.","title":"UserSitemap"},{"location":"evaluation.html#usertypesitemap","text":":class: UserTypeSitemap is responsible for sitemapping user types on the GFVP website. It includes active user types. Attributes: - changefreq (str): The expected change frequency of URLs in this sitemap. - priority (float): The priority of this sitemap in relation to others (0.0 to 1.0). Methods: - items() : Retrieve the list of active user types. - lastmod(obj) : Determine the last modification date for a user type. - location(obj) : Generate the URL for a user type page.","title":"UserTypeSitemap"},{"location":"evaluation.html#blogsitemap","text":":class: BlogSitemap is responsible for sitemapping blog posts on the GFVP website. It includes published blog posts. Attributes: - changefreq (str): The expected change frequency of URLs in this sitemap. - priority (float): The priority of this sitemap in relation to others (0.0 to 1.0). Methods: - items() : Retrieve the list of published blog posts. - lastmod(obj) : Determine the last modification date for a blog post. - location(obj) : Generate the URL for a blog post.","title":"BlogSitemap"},{"location":"evaluation.html#htmlreportsitemap","text":":class: HtmlReportSitemap is responsible for sitemapping generated evaluation reports on the GFVP website. It includes evaluation reports with verified email addresses. Attributes: - changefreq (str): The expected change frequency of URLs in this sitemap. - priority (float): The priority of this sitemap in relation to others (0.0 to 1.0). Methods: - items() : Retrieve the list of generated evaluation reports. - lastmod(obj) : Determine the last modification date for an evaluation report. - location(obj) : Generate the URL for an evaluation report. For detailed information on each sitemap class, their methods, and attributes, please refer to the code comments and docstrings provided within sitemaps.py . ============================= urls.py - Evaluation APP URLs ============================= This module defines the URL patterns for the Evaluation APP within the GFVP (Green Fuel Validation Platform) website. It also includes the configuration of sitemaps for various sections of the website.","title":"HtmlReportSitemap"},{"location":"evaluation.html#sitemaps_configuration","text":"The following sitemaps are configured for different sections of the website: static : Sitemap for static URLs active_users : Sitemap for active user profiles user_types : Sitemap for user types blog_list : Sitemap for blog posts HtmlReportitemap : Sitemap for HTML reports","title":"Sitemaps Configuration"},{"location":"evaluation.html#url_patterns","text":"The URL patterns are organized into two main sections: core patterns and additional patterns for the 'evaluation' app.","title":"URL Patterns"},{"location":"evaluation.html#core_url_patterns","text":"evaluation/thanks/ : URL for the 'thanks' view. evaluation/report/<str:slug> : URL for the 'report' view with a dynamic slug parameter. evaluation/nreport/<str:slug> : URL for the 'nreport' view with a dynamic slug parameter. evaluation/nreport_pdf/<str:slug> : URL for the 'nreport_pdf' view with a dynamic slug parameter. get-glossary/ : URL for the 'get_glossary' view. sitemap.xml/ : URL for the sitemap view, which uses Django's sitemap framework to generate sitemaps for search engines.","title":"Core URL Patterns:"},{"location":"evaluation.html#additional_url_patterns_for_the_evaluation_app","text":"evaluation2/ : URL for the 'eva_index2' view. evaluation2/option_add/ : URL for the 'option_add2' view. evaluation2/<int:evaluator_id>/<str:slug> : URL for the 'eva_question' view with dynamic parameters. evaluation/stdoils/ : URL for the 'stdoils' view. vedio_urls/<str:search_term> : URL for the 'vedio_urls' view with a dynamic search_term parameter. std_oils_block/<str:slug> : URL for the 'std_oils_block' view with a dynamic slug parameter. quotation_block/<str:slug> : URL for the 'quotation_block' view with a dynamic slug parameter. traficlighthori/<str:last_reports> : URL for the 'trafic_light_hori' view with a dynamic last_reports parameter. fuel-history/<str:last_reports> : URL for the 'fuel_history' view with a dynamic last_reports parameter. For more details on each URL pattern and its corresponding view, please refer to the code and comments provided within urls.py . ========================= Evaluation App Views (views.py) ========================= This module contains view functions for handling various aspects of the evaluation process within the evaluation app. .. note:: This documentation provides an overview of the functions and their purposes, but it's recommended to refer to the source code for detailed implementation and usage.","title":"Additional URL Patterns for the 'evaluation' App:"},{"location":"evaluation.html#1_set_evaluation_function","text":"Set the evaluation for a given question and evaluator. Args: question (Question): The question being evaluated. selected_option (Option): The option selected by the evaluator. evaluator (User): The user performing the evaluation. Returns: None Comments: This function first attempts to remove any existing evaluation entry for the specified question and evaluator combination. If no prior evaluation entry is found, it logs a message to indicate this. Subsequently, it creates a new evaluation entry with the provided information and saves it to the database. Example Usage: python set_evaluation(question, selected_option, evaluator)","title":"1. set_evaluation Function"},{"location":"evaluation.html#2_set_eva_comments_function","text":"Set or update an evaluation comment for a given question and evaluator. Args: question (Question): The question for which the comment is provided. comment (str): The comment provided by the evaluator. evaluator (User): The user providing the comment. Returns: None Comments: Check if an evaluation comment entry already exists for the same question and evaluator. Ensure that a new comment is provided (non-empty). If a previous comment entry exists, update it with the new comment. If no previous comment entry exists, create a new one with the provided information and save it to the database. Example Usage: python set_eva_comments(question, comment, evaluator)","title":"2. set_eva_comments Function"},{"location":"evaluation.html#3_set_evastatment_function","text":"Set evaluation statements for a given selected option and evaluator. Args: request : The request object. selected_option (Option): The selected option being evaluated. evaluator (User): The user performing the evaluation. Returns: None Comments: Extract the question associated with the selected option. Delete previous records of non-assessment statements for the same option and evaluator. Retrieve labels associated with the question. For each label, create a new EvaLebelStatement entry for non-assessment. Delete previous records of assessment statements for the same label and evaluator. Calculate assessment statements based on answers and save them. Example Usage: python set_evastatment(request, selected_option, evaluator)","title":"3. set_evastatment Function"},{"location":"evaluation.html#4_get_eoi_function","text":"Get a list of option IDs from a given list of evaluation statements. Args: eva_statement (list of EvaLebelStatement): A list of evaluation statements. Returns: list of int: A sorted list of unique option IDs found in the evaluation statements. Comments: Iterate through the list of evaluation statements. Check if each statement has a valid option ID and add it to the 'es_option_id' set. Return a sorted list of unique option IDs found in the evaluation statements. Example Usage: python eva_statements = get_evaluation_statements() eoi = get_eoi(eva_statements)","title":"4. get_eoi Function"},{"location":"evaluation.html#5_set_evastatement_of_logical_string_function","text":"Set evaluation statements based on logical strings for a given selected option and evaluator. Args: request : The request object. selected_option (Option): The selected option being evaluated. evaluator (User): The user performing the evaluation. Returns: None Comments: Review and revise the logical string. Collect saved logical strings from the admin backend. Create a list of selected options for each logical string. Get the common label for the evaluator. Delete any previous assessment records for the common label. Calculate assessment statements based on answers and save them. Example Usage: python set_evastatement_of_logical_string(request, selected_option, evaluator)","title":"5. set_evastatement_of_logical_string Function"},{"location":"evaluation.html#6_option_add2_function","text":"Handle the submission of evaluation options and comments by authenticated users. Args: request : The HTTP request object. Returns: HttpResponseRedirect: Redirects the user to the appropriate page based on the evaluation progress. Comments: Check if the user is authenticated and has an associated evaluator session. Clear the session data to ensure a fresh start for the evaluation. Process the POST request containing the selected option, comments, and other parameters. Check if an option has been selected; otherwise, redirect with a warning. Set evaluation data for the selected option, including comments and assessment. Handle logic for requesting feedback, updating comments, and performing assessments. Determine the next question in the evaluation sequence and set it in the session. If there's no next question, mark the report as generated, create a history, and redirect to a thank-you page. Example Usage: The function is typically used as a view for handling POST requests when users submit their evaluation choices and comments. question_dataset(request) Build a dataset of questions for display in the evaluation question form. This view function prepares a dataset of questions to be displayed in the evaluation question form. It marks questions with specific colors based on their status in the current report. Args: request: The HTTP request object. Returns: dict: A dictionary representing the dataset of questions organized by their parent questions. Comments: - Get sorted questions of the current report. - Mark all questions that are part of the current report. - Identify the last question in the current report. - Check for any unanswered questions before and after the last question. - Mark questions as \"Do Not Know\" or \"No\" if applicable. - Handle the status of parent questions and their child questions. Example Usage: The function is typically used to prepare the question dataset for rendering in the evaluation question form. get_vedio_urls(search_term) Retrieve YouTube video URLs related to a search term using the YouTube Data API. Args: search_term (str): The search term to query for videos. Returns: list: A list of YouTube video URLs as embed URLs. Comments: - Constructs a search URL for the YouTube Data API. - Sends a GET request to the API with the specified parameters. - Parses the JSON response to extract video information. - Constructs embed URLs for each video and adds them to the result list. Example Usage: video_urls = get_vedio_urls(\"Python programming tutorials\") for url in video_urls: print(url) vedio_urls(request, search_term) Retrieve YouTube video URLs related to a search term and store them in the database if not already saved. Args: request: The HTTP request object. search_term (str): The search term to query for videos. Returns: HttpResponse: A rendered HTML template with the video URLs as context data. Comments: - Check if video URLs for the given search term are already saved in the database. - If saved URLs exist and are less than 7 days old, use them. Otherwise, update and save new URLs. - If no saved URLs are found, fetch video URLs using the get_vedio_urls function and save them. - Return the video URLs as context data for rendering in the 'eva_youtube.html' template. Example Usage: In a Django view, you can call this function to retrieve and display YouTube video URLs. std_oils_block(request, slug) Render a template for displaying standardized oils block for a specific question. Args: request: The HTTP request object. slug (str): The unique slug identifying the question. Returns: HttpResponse: A rendered HTML template with the question as context data. Comments: - Retrieve a specific question based on its unique slug. - Render the 'std_oils_block.html' template with the question as context data. Example Usage: Use this function as a view to display standardized oils blocks for specific questions. quotation_block(request, slug) Render a template for displaying a quotation block for a specific question. Args: request: The HTTP request object. slug (str): The unique slug identifying the question. Returns: HttpResponse: A rendered HTML template with the question and related information as context data. Comments: - Retrieve a specific question based on its unique slug using the get_all_questions function. - Determine the next activities (picked_na) related to the question using the get_picked_na function. - Render the 'quotation_block.html' template with the question and next activities as context data. Example Usage: Use this function as a view to display a quotation block for a specific question. eva_question(request, evaluator_id, slug) Render the main interface for the evaluation process. Args: request: The HTTP request object. evaluator_id: The ID of the evaluator/report being evaluated. slug: The unique slug identifying the question. Returns: HttpResponse: A rendered HTML template with the evaluation interface. Comments: - Ensure that the report generator is coming from the initial page. - Check if there is an active, unfinished report for the user. - Validate access permissions for editing reports. - Verify if the parent question has been answered as \"Yes\" to allow access to child questions. - Set the default selected option for the question. - Prepare context data for rendering the evaluation interface. Example Usage: Use this function as a view to display the main evaluation interface during the evaluation process.","title":"6. option_add2 Function"},{"location":"evaluation.html#eva_index2_view","text":"This view renders the initial interface for data collection during the evaluation process. Args: - request: The HTTP request object. Returns: - HttpResponse: A rendered HTML template with the initial evaluation interface. Comments: - Essential part of the evaluation process, where login is required. - Collect initial data for the evaluation report. - Redirect users to a previously submitted question or gather initial data. - Check if a first question has been set by the admin. - Handle form submissions for initializing a new evaluation report. - Set labels for the new report. - Handle meta data for SEO purposes. Example Usage: Use this function as a view to display the initial interface for data collection during the evaluation process.","title":"eva_index2 View"},{"location":"evaluation.html#thanks_view","text":"This view renders the thank you page after completing the evaluation process. Args: - request: The HTTP request object. Returns: - HttpResponse: A rendered HTML template for the thank you page. Comments: - Essential part where login is required. - Check for the user's user type and last reports. - Calculate and display results on the thank you page. - Build report editing URLs for parents selected by the admin. - Paginate and display reports. - Handle meta data for SEO purposes. Example Usage: Use this function as a view to display the thank you page after completing the evaluation process.","title":"thanks View"},{"location":"evaluation.html#trafic_light_hori_view","text":"This view renders a horizontal traffic light evaluation page based on the last available report. Args: - request: The HTTP request object. - last_reports: The ID of the last report to be used for rendering. Returns: - HttpResponse: A rendered HTML page displaying the horizontal traffic light evaluation. Note: This function retrieves data from the database, prepares it for rendering, and returns an HTML page with the evaluation results.","title":"trafic_light_hori View"},{"location":"evaluation.html#fuel_history_view","text":"This view renders a fuel history chart based on the data from the last available report. Args: - request: The HTTP request object. - last_reports: The ID of the last report to be used for rendering. Returns: - HttpResponse: A rendered HTML page displaying the fuel history chart. Note: This function retrieves historical fuel data from the database, prepares it for rendering, and returns an HTML page with the fuel history chart.","title":"fuel_history View"},{"location":"evaluation.html#report_view","text":"This view renders a report page based on the provided report slug. Args: - request (HttpRequest): The HTTP request object. - slug (str): The unique slug identifier for the report. Returns: - HttpResponse: A rendered HTML page or PDF report displaying the report details. Comments: - Essential part where login is required. - Clears session data, as the report may have been marked as completed in the thank you page. - Generates a PDF report, if applicable. - Determines the status of next activities. Example Usage: Use this function as a view to display a report page based on the provided report slug.","title":"report View"},{"location":"evaluation.html#create_notification_to_consumer_function","text":"This function creates notifications for consumers regarding a report. Args: - report: The report for which notifications are to be created. Returns: - None Comments: - Retrieves a list of consumer emails. - Creates ConsumerMailQueue instances. - Bulk inserts the instances into the database. Example Usage: Call this function to create notifications for consumers regarding a report.","title":"create_notification_to_consumer Function"},{"location":"evaluation.html#nreport_view","text":"This view renders a new report creation/editing page based on the provided report slug. Args: - request (HttpRequest): The HTTP request object. - slug (str): The unique slug identifier for the report. Returns: - HttpResponse: A rendered HTML page displaying the report creation/editing form. Comments: - Essential part where login is required. - Clears session data. - Handles report creation or editing. - Generates notifications for consumers when the 'confirm' parameter is present in the request. - Sets metadata for the page. Example Usage: Use this function as a view to display a new report creation/editing page based on the provided report slug.","title":"nreport View"},{"location":"evaluation.html#nreport_pdf_view","text":"This view generates a PDF report based on ReportLab for a new evaluation report. Args: - request (HttpRequest): The HTTP request object. - slug (str): The unique slug identifier for the report. Returns: - FileResponse: An HTTP response with the generated PDF report. Comments: - Uses the ReportLab library to create a PDF report. - Sets document metadata, margins, and page size. - Generates the content (Story) for the PDF report. Example Usage: Use this function as a view to generate a PDF report for a new evaluation report.","title":"nreport_pdf View"},{"location":"evaluation.html#stdoils_view","text":"This view renders a list of standard oils based on the selected biofuel. Args: - request (HttpRequest): The HTTP request object. Returns: - HttpResponse: A rendered HTML page displaying a list of standard oils. Comments: - Retrieves a list of standard oils filtered by the selected biofuel ID. - Renders the list in the 'std_oils.html' template. Example Usage: Use this function as a view to display a list of standard oils based on the selected biofuel.","title":"stdoils View"},{"location":"evaluation.html#get_glossary_view","text":"This view renders the glossary page with a list of glossary items. Args: - request (HttpRequest): The HTTP request object. Returns: - HttpResponse: A rendered HTML page displaying a glossary with a list of glossary items. Comments: - Retrieves a list of glossary items using 'get_all_glosaries()'. - Renders the list in the 'glossary_template.html' template. Example Usage: Use this function as a view to display a glossary page with a list of glossary items.","title":"get_glossary View"},{"location":"evaluation.html#edit_report_view","text":"This view allows the creator of a report to edit its details. Args: - request (HttpRequest): The HTTP request object. - slug (str): The unique slug identifier for the report to be edited. Returns: - HttpResponse: A rendered HTML page displaying the report edit form. Comments: - Restricted to report creators. - Allows report creators to edit the details of a specific report. - Uses the 'EvaluatorEditForm' to handle form submission and update the report's information. Example Usage: Use this function as a view to allow report creators to edit report details.","title":"edit_report View"},{"location":"evaluation.html#contributing","text":"Contributions to the 'Evaluation' app are welcome! If you'd like to contribute, please review the contribution guidelines in the project's repository.","title":"Contributing"},{"location":"evaluation.html#license","text":"This module is distributed under the [Insert License Here] license. See the LICENSE file for more information.","title":"License"},{"location":"feedback.html","text":"Feedback App README \u00b6 This README provides an overview of the Feedback app in Django, explaining its components and functionality. Admin Configuration (admin.py) \u00b6 The admin.py file contains the Django Admin configuration for the Feedback Model. It defines how the Feedback model is displayed and filtered in the Django Admin interface. Here's an explanation of the key aspects: .. code-block:: python from django.contrib import admin from .models import Feedback @admin.register(Feedback) class FeedbackAdmin(admin.ModelAdmin): \"\"\" Custom admin configuration for the Feedback model. This class defines how the Feedback model should be displayed and filtered in the Django admin interface. Attributes: list_display (list of str): Fields to display in the list view. list_filter (tuple of str): Fields to use for filtering records. search_fields (tuple of str): Fields to use for searching records. ordering (tuple of str): Fields to determine the default ordering of records. readonly_fields (tuple of str): Fields that should be read-only in the admin interface. \"\"\" # Display these fields in the list view of the admin interface. list_display = [f.name for f in Feedback._meta.fields if f.editable and not f.name == \"id\"] # Allow filtering by the 'url' field in the right sidebar. list_filter = ('url', ) # Enable searching by 'message', 'name', and 'email' fields. search_fields = ('message', 'name', 'email', ) # Order records by 'created_at' in descending order by default. ordering = ('-created_at',) # Make 'url', 'message', 'name', 'email', and 'phone' fields read-only. readonly_fields = ('url', 'message', 'name', 'email', 'phone',) Feedback App Forms \u00b6 This module defines a Django form used for collecting and validating user feedback. FeedbackForm A Django form for the Feedback model. It includes fields for 'name', 'phone', 'email', 'url', and 'message', along with widget configurations for the form fields. The 'url' field is hidden and captures the URL from which feedback is submitted. Usage: - Import the form in your views. - Use it to collect and validate user feedback data. - Save the feedback instance to the database. Example: ```python from .forms import FeedbackForm Create an instance of the form \u00b6 form = FeedbackForm(request.POST) Check if the form is valid \u00b6 if form.is_valid(): # Save the feedback instance feedback = form.save() Feedback App Models \u00b6 models.py contains the Django model definition for storing user feedback. Feedback Model A Django model to represent user feedback. This model defines the structure and data fields for storing user feedback. It includes fields for 'name', 'phone', 'email', 'message', 'url', and 'created_at', along with the default ordering for feedback instances. Attributes: - name (models.CharField): The name of the person providing feedback. - phone (models.CharField): The phone number of the person providing feedback. - email (models.EmailField): The email address of the person providing feedback. - message (models.TextField): The feedback message. - url (models.URLField): The URL from which the feedback was submitted. - created_at (models.DateTimeField): The timestamp when the feedback was created. Example Usage: ```python from .models import Feedback Create a new feedback instance \u00b6 feedback = Feedback(name='John Doe', phone='123-456-7890', email='john@example.com', message='Great service!', url='http://example.com') Save the feedback instance to the database \u00b6 feedback.save() Feedback App URL Configuration \u00b6 urls.py defines the URL patterns and routing configuration for the Feedback app. App Namespace The app defines a namespace named 'feedback' using app_name . This helps organize and group related URLs. URL Patterns: - /submit/ : Handles the submission of user feedback. - /hx/ : Placeholder for additional URL patterns related to 'hx' (Hypertext) views. Example Usage: Submitting Feedback: URL: /submit/ View: submit_feedback Name: 'submit_feedback' Use this URL to access the feedback submission form. Hypertext (hx) Views: Additional URL patterns related to dynamic updates in web applications can be added here under the /hx/ namespace. ```python Import the view for submitting feedback \u00b6 from .views import submit_feedback from django.urls import path Define the app namespace \u00b6 app_name = 'feedback' Define URL patterns \u00b6 urlpatterns = [ # URL pattern for submitting feedback path('submit/', submit_feedback, name='submit_feedback'), ] Placeholder for additional 'hx' URL patterns \u00b6 hx_urlpatterns = [ # Add additional 'hx' URL patterns here if needed. ] Include 'hx' URL patterns in the main urlpatterns \u00b6 urlpatterns += hx_urlpatterns Feedback App Views \u00b6 views.py contains view functions for user feedback submissions in the Feedback app. submit_feedback View A view for handling user feedback submissions. It processes both GET and POST requests. When valid feedback data is submitted, it is saved, and the action is logged. For GET requests, the form is pre-filled with relevant data. URL: /submit/ HTTP Method: POST for submission, GET for pre-filling. Handles form submission, data validation, and logging. Returns a success message on successful submission. For more details, refer to the code in views.py .","title":"Feedback"},{"location":"feedback.html#feedback_app_readme","text":"This README provides an overview of the Feedback app in Django, explaining its components and functionality.","title":"Feedback App README"},{"location":"feedback.html#admin_configuration_adminpy","text":"The admin.py file contains the Django Admin configuration for the Feedback Model. It defines how the Feedback model is displayed and filtered in the Django Admin interface. Here's an explanation of the key aspects: .. code-block:: python from django.contrib import admin from .models import Feedback @admin.register(Feedback) class FeedbackAdmin(admin.ModelAdmin): \"\"\" Custom admin configuration for the Feedback model. This class defines how the Feedback model should be displayed and filtered in the Django admin interface. Attributes: list_display (list of str): Fields to display in the list view. list_filter (tuple of str): Fields to use for filtering records. search_fields (tuple of str): Fields to use for searching records. ordering (tuple of str): Fields to determine the default ordering of records. readonly_fields (tuple of str): Fields that should be read-only in the admin interface. \"\"\" # Display these fields in the list view of the admin interface. list_display = [f.name for f in Feedback._meta.fields if f.editable and not f.name == \"id\"] # Allow filtering by the 'url' field in the right sidebar. list_filter = ('url', ) # Enable searching by 'message', 'name', and 'email' fields. search_fields = ('message', 'name', 'email', ) # Order records by 'created_at' in descending order by default. ordering = ('-created_at',) # Make 'url', 'message', 'name', 'email', and 'phone' fields read-only. readonly_fields = ('url', 'message', 'name', 'email', 'phone',)","title":"Admin Configuration (admin.py)"},{"location":"feedback.html#feedback_app_forms","text":"This module defines a Django form used for collecting and validating user feedback. FeedbackForm A Django form for the Feedback model. It includes fields for 'name', 'phone', 'email', 'url', and 'message', along with widget configurations for the form fields. The 'url' field is hidden and captures the URL from which feedback is submitted. Usage: - Import the form in your views. - Use it to collect and validate user feedback data. - Save the feedback instance to the database. Example: ```python from .forms import FeedbackForm","title":"Feedback App Forms"},{"location":"feedback.html#create_an_instance_of_the_form","text":"form = FeedbackForm(request.POST)","title":"Create an instance of the form"},{"location":"feedback.html#check_if_the_form_is_valid","text":"if form.is_valid(): # Save the feedback instance feedback = form.save()","title":"Check if the form is valid"},{"location":"feedback.html#feedback_app_models","text":"models.py contains the Django model definition for storing user feedback. Feedback Model A Django model to represent user feedback. This model defines the structure and data fields for storing user feedback. It includes fields for 'name', 'phone', 'email', 'message', 'url', and 'created_at', along with the default ordering for feedback instances. Attributes: - name (models.CharField): The name of the person providing feedback. - phone (models.CharField): The phone number of the person providing feedback. - email (models.EmailField): The email address of the person providing feedback. - message (models.TextField): The feedback message. - url (models.URLField): The URL from which the feedback was submitted. - created_at (models.DateTimeField): The timestamp when the feedback was created. Example Usage: ```python from .models import Feedback","title":"Feedback App Models"},{"location":"feedback.html#create_a_new_feedback_instance","text":"feedback = Feedback(name='John Doe', phone='123-456-7890', email='john@example.com', message='Great service!', url='http://example.com')","title":"Create a new feedback instance"},{"location":"feedback.html#save_the_feedback_instance_to_the_database","text":"feedback.save()","title":"Save the feedback instance to the database"},{"location":"feedback.html#feedback_app_url_configuration","text":"urls.py defines the URL patterns and routing configuration for the Feedback app. App Namespace The app defines a namespace named 'feedback' using app_name . This helps organize and group related URLs. URL Patterns: - /submit/ : Handles the submission of user feedback. - /hx/ : Placeholder for additional URL patterns related to 'hx' (Hypertext) views. Example Usage: Submitting Feedback: URL: /submit/ View: submit_feedback Name: 'submit_feedback' Use this URL to access the feedback submission form. Hypertext (hx) Views: Additional URL patterns related to dynamic updates in web applications can be added here under the /hx/ namespace. ```python","title":"Feedback App URL Configuration"},{"location":"feedback.html#import_the_view_for_submitting_feedback","text":"from .views import submit_feedback from django.urls import path","title":"Import the view for submitting feedback"},{"location":"feedback.html#define_the_app_namespace","text":"app_name = 'feedback'","title":"Define the app namespace"},{"location":"feedback.html#define_url_patterns","text":"urlpatterns = [ # URL pattern for submitting feedback path('submit/', submit_feedback, name='submit_feedback'), ]","title":"Define URL patterns"},{"location":"feedback.html#placeholder_for_additional_hx_url_patterns","text":"hx_urlpatterns = [ # Add additional 'hx' URL patterns here if needed. ]","title":"Placeholder for additional 'hx' URL patterns"},{"location":"feedback.html#include_hx_url_patterns_in_the_main_urlpatterns","text":"urlpatterns += hx_urlpatterns","title":"Include 'hx' URL patterns in the main urlpatterns"},{"location":"feedback.html#feedback_app_views","text":"views.py contains view functions for user feedback submissions in the Feedback app. submit_feedback View A view for handling user feedback submissions. It processes both GET and POST requests. When valid feedback data is submitted, it is saved, and the action is logged. For GET requests, the form is pre-filled with relevant data. URL: /submit/ HTTP Method: POST for submission, GET for pre-filling. Handles form submission, data validation, and logging. Returns a success message on successful submission. For more details, refer to the code in views.py .","title":"Feedback App Views"},{"location":"gfvp.html","text":"====================================================== Django Project: GFVP (Green Fuel Validation Platform) ====================================================== Project Structure \u00b6 The 'gfvp' project has the following directory structure: :: gfvp/ \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 settings/ \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 dev.py \u2502 \u251c\u2500\u2500 pro.py \u2502 \u251c\u2500\u2500 settings_axes.py \u2502 \u251c\u2500\u2500 settings_database.py \u2502 \u251c\u2500\u2500 settings_debug_toolbar.py \u2502 \u251c\u2500\u2500 settings_email.py \u2502 \u251c\u2500\u2500 settings_local.py \u2502 \u251c\u2500\u2500 settings_logs.py \u2502 \u251c\u2500\u2500 settings_maintenance.py \u2502 \u251c\u2500\u2500 settings_material_admin.py \u2502 \u251c\u2500\u2500 settings_mkdocs.py \u2502 \u251c\u2500\u2500 settings_security.py \u2502 \u251c\u2500\u2500 settings_summernote.py \u251c\u2500\u2500 addset.cpython-39-x86_64-linux-gnu.so \u251c\u2500\u2500 addset.cp39-win_amd64.pyd \u251c\u2500\u2500 urls.py \u251c\u2500\u2500 wsgi.py \u2514\u2500\u2500 asgi.py Overview \u00b6 GFVP (Green Fuel Validation Platform) is a Django-based web application for managing and verifying green fuel data. It includes various features and modules for fuel evaluation, user management, content management, and more. Getting Started \u00b6 Install Dependencies: Make sure you have Python 3.9 or higher installed. Create a virtual environment and activate it. Install required Python packages using pip install -r requirements.txt . Configure Settings: Customize the project settings in the 'gfvp/settings' directory based on your environment (e.g., development or production). Review 'gfvp/settings/settings_material_admin.py' for Material Admin configuration. Review CustomFileBasedCache in project __init__.py Database Setup: Configure your database settings in 'gfvp/settings/settings_database.py'. Run migrations using python manage.py migrate to create the database schema. Serve the Application: Start the development server with python manage.py runserver . Project Features \u00b6 Admin Panel: Access the admin panel at '/admin/' with customizable branding. Manage various entities and settings. Debugging: Enable debugging using the Django Debug Toolbar at '/ debug /'. Additional Modules: Utilize various app modules like 'evaluation', 'home', 'crm', 'guide', 'blog', 'glossary', 'feedback', and more. User Management: Handle user registration types with the 'null_session' view. Authentication and account-related URLs are available under '/accounts/'. WYSIWYG Editor: Integrate the Summernote WYSIWYG editor with '/summernote/'. Taggit Autosuggest: Use the '/taggit_autosuggest/' URL for tag suggestions. Documentation: Include documentation using MkDocs at '/docs/'. Documetation for eacch app added in each app directory. Additional Views: View GDPR policy at '/gdpr-policy/'. View terms and conditions at '/terms/'. Deployment \u00b6 Configure your server for deployment. Set up environment variables and server-specific configurations. Use 'wsgi.py' (for non-Windows systems) or 'asgi.py' (for ASGI deployment) as your application entry point. Ensure proper permissions for cache and static/media files as required. Contributing \u00b6 Feel free to contribute to this project by following our contribution guidelines and opening pull requests. License \u00b6 This project is licensed under the XYZ License - see the 'LICENSE' file for details. Acknowledgments \u00b6 Special thanks to all contributors and the Django community for their support. For more information and detailed documentation, refer to the project's official documentation. For the latest updates and issues, visit the project repository on GitHub. Project Repository: https://github.com/haradhansharma/biofuel <https://github.com/harahansharma/biofuel> _","title":"Project"},{"location":"gfvp.html#project_structure","text":"The 'gfvp' project has the following directory structure: :: gfvp/ \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 settings/ \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 dev.py \u2502 \u251c\u2500\u2500 pro.py \u2502 \u251c\u2500\u2500 settings_axes.py \u2502 \u251c\u2500\u2500 settings_database.py \u2502 \u251c\u2500\u2500 settings_debug_toolbar.py \u2502 \u251c\u2500\u2500 settings_email.py \u2502 \u251c\u2500\u2500 settings_local.py \u2502 \u251c\u2500\u2500 settings_logs.py \u2502 \u251c\u2500\u2500 settings_maintenance.py \u2502 \u251c\u2500\u2500 settings_material_admin.py \u2502 \u251c\u2500\u2500 settings_mkdocs.py \u2502 \u251c\u2500\u2500 settings_security.py \u2502 \u251c\u2500\u2500 settings_summernote.py \u251c\u2500\u2500 addset.cpython-39-x86_64-linux-gnu.so \u251c\u2500\u2500 addset.cp39-win_amd64.pyd \u251c\u2500\u2500 urls.py \u251c\u2500\u2500 wsgi.py \u2514\u2500\u2500 asgi.py","title":"Project Structure"},{"location":"gfvp.html#overview","text":"GFVP (Green Fuel Validation Platform) is a Django-based web application for managing and verifying green fuel data. It includes various features and modules for fuel evaluation, user management, content management, and more.","title":"Overview"},{"location":"gfvp.html#getting_started","text":"Install Dependencies: Make sure you have Python 3.9 or higher installed. Create a virtual environment and activate it. Install required Python packages using pip install -r requirements.txt . Configure Settings: Customize the project settings in the 'gfvp/settings' directory based on your environment (e.g., development or production). Review 'gfvp/settings/settings_material_admin.py' for Material Admin configuration. Review CustomFileBasedCache in project __init__.py Database Setup: Configure your database settings in 'gfvp/settings/settings_database.py'. Run migrations using python manage.py migrate to create the database schema. Serve the Application: Start the development server with python manage.py runserver .","title":"Getting Started"},{"location":"gfvp.html#project_features","text":"Admin Panel: Access the admin panel at '/admin/' with customizable branding. Manage various entities and settings. Debugging: Enable debugging using the Django Debug Toolbar at '/ debug /'. Additional Modules: Utilize various app modules like 'evaluation', 'home', 'crm', 'guide', 'blog', 'glossary', 'feedback', and more. User Management: Handle user registration types with the 'null_session' view. Authentication and account-related URLs are available under '/accounts/'. WYSIWYG Editor: Integrate the Summernote WYSIWYG editor with '/summernote/'. Taggit Autosuggest: Use the '/taggit_autosuggest/' URL for tag suggestions. Documentation: Include documentation using MkDocs at '/docs/'. Documetation for eacch app added in each app directory. Additional Views: View GDPR policy at '/gdpr-policy/'. View terms and conditions at '/terms/'.","title":"Project Features"},{"location":"gfvp.html#deployment","text":"Configure your server for deployment. Set up environment variables and server-specific configurations. Use 'wsgi.py' (for non-Windows systems) or 'asgi.py' (for ASGI deployment) as your application entry point. Ensure proper permissions for cache and static/media files as required.","title":"Deployment"},{"location":"gfvp.html#contributing","text":"Feel free to contribute to this project by following our contribution guidelines and opening pull requests.","title":"Contributing"},{"location":"gfvp.html#license","text":"This project is licensed under the XYZ License - see the 'LICENSE' file for details.","title":"License"},{"location":"gfvp.html#acknowledgments","text":"Special thanks to all contributors and the Django community for their support. For more information and detailed documentation, refer to the project's official documentation. For the latest updates and issues, visit the project repository on GitHub. Project Repository: https://github.com/haradhansharma/biofuel <https://github.com/harahansharma/biofuel> _","title":"Acknowledgments"},{"location":"glossary.html","text":"Glossary App \u00b6 Introduction \u00b6 The Glossary app is a Django application designed to manage and display glossary entries and user-submitted glossary requests within the Green Fuel Validation Platform project. Features \u00b6 Display a list of glossary entries. Allow users to submit glossary requests. Custom Django admin settings for managing glossary entries and requests. ... Installation \u00b6 Clone the repository or download the project files. Install the required dependencies using pip install -r requirements.txt . Add 'glossary' to the INSTALLED_APPS list in your project's settings. Run migrations to create the database tables: python manage.py migrate . Contact \u00b6 If you have any questions or need further assistance, please contact [haradhan.sharma@gmail.com]. Admin Configuration (admin.py) \u00b6 In the admin.py file of the Glossary app, we configure the Django admin interface for managing glossary entries and requests. Here's an overview of what's done in this file: ```python Import necessary modules and classes from Django. \u00b6 ... \u00b6 Define an inline class for RelatedLinks to be used within the GlossaryAdmin. \u00b6 ... \u00b6 Define the admin class for the Glossary model. \u00b6 class GlossaryAdmin(admin.ModelAdmin): \"\"\" Custom admin settings for the Glossary model. \"\"\" # Specify the model this admin class is associated with. # ... # Define the list of fields to be displayed in the admin list view. # ... # Define fields that can be searched in the admin list view. # ... # Include the RelatedLinksInline class as an inline form. # ... Register the GlossaryAdmin class with the Django admin site for the Glossary model. \u00b6 admin.site.register(Glossary, GlossaryAdmin) Define the admin class for the GRequests model. \u00b6 class GRequestsAdmin(admin.ModelAdmin): \"\"\" Custom admin settings for the GRequests model. \"\"\" # Specify the form to be used for this admin class. # ... # Specify the model this admin class is associated with. # ... # Define the list of fields to be displayed in the admin list view. # ... Register the GRequestsAdmin class with the Django admin site for the GRequests model. \u00b6 admin.site.register(GRequests, GRequestsAdmin) AppConfig (app.py) \u00b6 The AppConfig in the app.py file of the Glossary app provides configuration settings for the app within the Django project. Here's an overview of what's defined in this configuration: ```python Import necessary modules from Django. \u00b6 from django.apps import AppConfig class GlossaryConfig(AppConfig): \"\"\" AppConfig for the 'glossary' app. This class defines configuration settings for the 'glossary' app. \"\"\" # Specify the default auto field for this app's models. default_auto_field = 'django.db.models.BigAutoField' # Set the name of the app. This should match the name of the app's directory. name = 'glossary' def ready(self): \"\"\" Override the ready() method to import signals when the app is ready. This method is called when the application is loaded, and it provides an opportunity to perform initialization tasks. In this case, we are importing signals defined in the 'glossary.signals' module to ensure they are registered and ready to be used. \"\"\" import glossary.signals forms.py - Glossary App Forms The forms.py file in the Glossary app defines the forms used for submitting and changing GRequests, including custom validation for certain fields. GRequestsChangeForm \u00b6 The GRequestsChangeForm is used for changing GRequests model data. It includes custom validation for the 'description' field to ensure it is not empty. ```python class GRequestsChangeForm(forms.ModelForm): \"\"\" Form for changing GRequests model data. This form is used for changing the data of the GRequests model. It includes a custom validation for the 'description' field to ensure it is not empty. Attributes: Meta: A nested class defining metadata options for the form. \"\"\" class Meta: model = GRequests fields = '__all__' def clean(self, *args, **kwargs): \"\"\" Custom clean method for validating the 'description' field. This method checks if the 'description' field is empty and raises a forms.ValidationError if it is. Args: *args: Additional positional arguments. **kwargs: Additional keyword arguments. Returns: dict: A cleaned data dictionary. \"\"\" description = self.cleaned_data.get('description') if description == '': raise forms.ValidationError(\"Description Required\") return super(GRequestsChangeForm, self).clean(*args, **kwargs) Glossary App Models \u00b6 Glossary \u00b6 The Glossary model represents glossary entries in the system. It stores information about each entry, including its title, description, and automatically generated slug and anchor fields. Attributes: created (DateTimeField): The date and time when the entry was created (auto-generated). modified (DateTimeField): The date and time when the entry was last modified (auto-generated). title (CharField): The title of the glossary entry. slug (SlugField): A unique slug based on the title (auto-generated). anchor (SlugField): A non-unique slug derived from the first character of the title (auto-generated). description (TextField): The description or definition of the glossary entry. Methods: __str__ : A string representation of the glossary entry, using its title. save : Custom save method to generate the slug and anchor fields based on the title. Meta: ordering (list): Default ordering for glossary entries, first by title, then by modification date. RelatedLinks \u00b6 The RelatedLinks model represents related links for glossary entries. It stores information about related links associated with glossary entries, including their title, URL link, and a foreign key reference to the related glossary entry. Attributes: title (CharField): The title of the related link. link (URLField): The URL link. glossary (ForeignKey): A foreign key reference to the related glossary entry. Methods: __str__ : A string representation of the related link, including the associated glossary entry's title. GRequests \u00b6 The GRequests model represents user-submitted requests for glossary entries. It stores information about G Requests, including their title and an optional description. Attributes: created (DateTimeField): The date and time when the G Request was created (auto-generated). modified (DateTimeField): The date and time when the G Request was last modified (auto-generated). title (CharField): The title of the G Request. description (TextField, optional): Additional description or details of the request. Methods: __str__ : A string representation of the G Request, using its title. Meta: verbose_name (str): The singular name for this model in the admin interface. verbose_name_plural (str): The plural name for this model in the admin interface. signals.py \u00b6 In the signals.py file of the Glossary app, we define and configure signal receivers that respond to specific events in the application. In particular, we have a receiver function that gets triggered after a GRequests instance is saved. Here's an overview of what's done in this file: ```python Import necessary modules for working with Django signals. \u00b6 from django.db.models.signals import post_save, pre_save from django.dispatch import receiver Import models and other dependencies from the current app. \u00b6 from .models import * Import logging module for creating log entries. \u00b6 import logging Get a logger instance named 'log'. \u00b6 log = logging.getLogger('log') Define a receiver function to be triggered after saving a GRequests instance. \u00b6 @receiver(post_save, sender=GRequests) def make_glossary(sender, instance, created, args, *kwargs): \"\"\" Receiver function triggered after saving a GRequests instance. This function is a signal receiver that gets triggered after a GRequests instance is saved. It checks if the instance is newly created (created=True), and if not, it creates a Glossary entry based on the GRequests instance and then deletes the GRequests instance. Args: sender: The sender of the signal. instance: The instance of the GRequests model. created (bool): Indicates whether the GRequests instance was newly created. *args: Additional positional arguments. **kwargs: Additional keyword arguments. \"\"\" if created: # If the GRequests instance is newly created, do nothing. pass else: # If the GRequests instance is not newly created, create a Glossary entry. log.info('Glossary created from request________________') Glossary.objects.create(title = instance.title, description = instance.description) # Delete the GRequests instance since it's now been converted to a Glossary entry. instance.delete() URL Configuration (urls.py) \u00b6 In the urls.py file of the Glossary app, we define the URL patterns for accessing the app's views. Here's an overview of the URL configuration: ```python Import necessary modules and views from the Glossary app. \u00b6 ... \u00b6 Define the app name for URL namespace. \u00b6 app_name = 'glossary' Define URL patterns for the 'glossary' app. \u00b6 urlpatterns = [ # Define a URL pattern for the glossary list view. path('', views.Glist.as_view(), name='g_list'), ] Views (views.py) \u00b6 In the views.py file of the Glossary app, we define view functions and classes responsible for rendering glossary-related web pages, handling user requests, and providing additional context data. Here's an overview of the views and their functionality: Glist (Class-based View) \u00b6 The Glist class-based view is responsible for displaying the glossary list, handling glossary request submissions, and providing additional context data. Here's a breakdown of its attributes and methods: Attributes: model (Glossary) : The model to query for glossary entries. paginate_by (int, optional) : Uncomment to enable pagination with a specific number of entries per page. Methods: get_context_data(**kwargs) : Overrides the base class method to provide additional context data for rendering the glossary list view. It includes a form for submitting glossary requests and meta information. post(request, *args, **kwargs) : Handles POST requests for submitting glossary requests. It validates the request form, saves the request if it's valid, and provides feedback to the user via messages. The Glist view plays a crucial role in managing glossary entries and user interactions with the glossary section of the application. By using this view, users can view glossary entries, submit requests for new glossary entries, and receive feedback on their submissions. This view also incorporates meta information for SEO purposes, enhancing the user experience. Keep in mind that pagination can be enabled by uncommenting the paginate_by attribute and specifying the desired number of entries per page. ```python model = Glossary paginate_by = 100 # Uncomment to enable pagination with a specific number of entries per page. \u00b6","title":"Glossary"},{"location":"glossary.html#glossary_app","text":"","title":"Glossary App"},{"location":"glossary.html#introduction","text":"The Glossary app is a Django application designed to manage and display glossary entries and user-submitted glossary requests within the Green Fuel Validation Platform project.","title":"Introduction"},{"location":"glossary.html#features","text":"Display a list of glossary entries. Allow users to submit glossary requests. Custom Django admin settings for managing glossary entries and requests. ...","title":"Features"},{"location":"glossary.html#installation","text":"Clone the repository or download the project files. Install the required dependencies using pip install -r requirements.txt . Add 'glossary' to the INSTALLED_APPS list in your project's settings. Run migrations to create the database tables: python manage.py migrate .","title":"Installation"},{"location":"glossary.html#contact","text":"If you have any questions or need further assistance, please contact [haradhan.sharma@gmail.com].","title":"Contact"},{"location":"glossary.html#admin_configuration_adminpy","text":"In the admin.py file of the Glossary app, we configure the Django admin interface for managing glossary entries and requests. Here's an overview of what's done in this file: ```python","title":"Admin Configuration (admin.py)"},{"location":"glossary.html#import_necessary_modules_and_classes_from_django","text":"","title":"Import necessary modules and classes from Django."},{"location":"glossary.html#_1","text":"","title":"..."},{"location":"glossary.html#define_an_inline_class_for_relatedlinks_to_be_used_within_the_glossaryadmin","text":"","title":"Define an inline class for RelatedLinks to be used within the GlossaryAdmin."},{"location":"glossary.html#_2","text":"","title":"..."},{"location":"glossary.html#define_the_admin_class_for_the_glossary_model","text":"class GlossaryAdmin(admin.ModelAdmin): \"\"\" Custom admin settings for the Glossary model. \"\"\" # Specify the model this admin class is associated with. # ... # Define the list of fields to be displayed in the admin list view. # ... # Define fields that can be searched in the admin list view. # ... # Include the RelatedLinksInline class as an inline form. # ...","title":"Define the admin class for the Glossary model."},{"location":"glossary.html#register_the_glossaryadmin_class_with_the_django_admin_site_for_the_glossary_model","text":"admin.site.register(Glossary, GlossaryAdmin)","title":"Register the GlossaryAdmin class with the Django admin site for the Glossary model."},{"location":"glossary.html#define_the_admin_class_for_the_grequests_model","text":"class GRequestsAdmin(admin.ModelAdmin): \"\"\" Custom admin settings for the GRequests model. \"\"\" # Specify the form to be used for this admin class. # ... # Specify the model this admin class is associated with. # ... # Define the list of fields to be displayed in the admin list view. # ...","title":"Define the admin class for the GRequests model."},{"location":"glossary.html#register_the_grequestsadmin_class_with_the_django_admin_site_for_the_grequests_model","text":"admin.site.register(GRequests, GRequestsAdmin)","title":"Register the GRequestsAdmin class with the Django admin site for the GRequests model."},{"location":"glossary.html#appconfig_apppy","text":"The AppConfig in the app.py file of the Glossary app provides configuration settings for the app within the Django project. Here's an overview of what's defined in this configuration: ```python","title":"AppConfig (app.py)"},{"location":"glossary.html#import_necessary_modules_from_django","text":"from django.apps import AppConfig class GlossaryConfig(AppConfig): \"\"\" AppConfig for the 'glossary' app. This class defines configuration settings for the 'glossary' app. \"\"\" # Specify the default auto field for this app's models. default_auto_field = 'django.db.models.BigAutoField' # Set the name of the app. This should match the name of the app's directory. name = 'glossary' def ready(self): \"\"\" Override the ready() method to import signals when the app is ready. This method is called when the application is loaded, and it provides an opportunity to perform initialization tasks. In this case, we are importing signals defined in the 'glossary.signals' module to ensure they are registered and ready to be used. \"\"\" import glossary.signals forms.py - Glossary App Forms The forms.py file in the Glossary app defines the forms used for submitting and changing GRequests, including custom validation for certain fields.","title":"Import necessary modules from Django."},{"location":"glossary.html#grequestschangeform","text":"The GRequestsChangeForm is used for changing GRequests model data. It includes custom validation for the 'description' field to ensure it is not empty. ```python class GRequestsChangeForm(forms.ModelForm): \"\"\" Form for changing GRequests model data. This form is used for changing the data of the GRequests model. It includes a custom validation for the 'description' field to ensure it is not empty. Attributes: Meta: A nested class defining metadata options for the form. \"\"\" class Meta: model = GRequests fields = '__all__' def clean(self, *args, **kwargs): \"\"\" Custom clean method for validating the 'description' field. This method checks if the 'description' field is empty and raises a forms.ValidationError if it is. Args: *args: Additional positional arguments. **kwargs: Additional keyword arguments. Returns: dict: A cleaned data dictionary. \"\"\" description = self.cleaned_data.get('description') if description == '': raise forms.ValidationError(\"Description Required\") return super(GRequestsChangeForm, self).clean(*args, **kwargs)","title":"GRequestsChangeForm"},{"location":"glossary.html#glossary_app_models","text":"","title":"Glossary App Models"},{"location":"glossary.html#glossary","text":"The Glossary model represents glossary entries in the system. It stores information about each entry, including its title, description, and automatically generated slug and anchor fields. Attributes: created (DateTimeField): The date and time when the entry was created (auto-generated). modified (DateTimeField): The date and time when the entry was last modified (auto-generated). title (CharField): The title of the glossary entry. slug (SlugField): A unique slug based on the title (auto-generated). anchor (SlugField): A non-unique slug derived from the first character of the title (auto-generated). description (TextField): The description or definition of the glossary entry. Methods: __str__ : A string representation of the glossary entry, using its title. save : Custom save method to generate the slug and anchor fields based on the title. Meta: ordering (list): Default ordering for glossary entries, first by title, then by modification date.","title":"Glossary"},{"location":"glossary.html#relatedlinks","text":"The RelatedLinks model represents related links for glossary entries. It stores information about related links associated with glossary entries, including their title, URL link, and a foreign key reference to the related glossary entry. Attributes: title (CharField): The title of the related link. link (URLField): The URL link. glossary (ForeignKey): A foreign key reference to the related glossary entry. Methods: __str__ : A string representation of the related link, including the associated glossary entry's title.","title":"RelatedLinks"},{"location":"glossary.html#grequests","text":"The GRequests model represents user-submitted requests for glossary entries. It stores information about G Requests, including their title and an optional description. Attributes: created (DateTimeField): The date and time when the G Request was created (auto-generated). modified (DateTimeField): The date and time when the G Request was last modified (auto-generated). title (CharField): The title of the G Request. description (TextField, optional): Additional description or details of the request. Methods: __str__ : A string representation of the G Request, using its title. Meta: verbose_name (str): The singular name for this model in the admin interface. verbose_name_plural (str): The plural name for this model in the admin interface.","title":"GRequests"},{"location":"glossary.html#signalspy","text":"In the signals.py file of the Glossary app, we define and configure signal receivers that respond to specific events in the application. In particular, we have a receiver function that gets triggered after a GRequests instance is saved. Here's an overview of what's done in this file: ```python","title":"signals.py"},{"location":"glossary.html#import_necessary_modules_for_working_with_django_signals","text":"from django.db.models.signals import post_save, pre_save from django.dispatch import receiver","title":"Import necessary modules for working with Django signals."},{"location":"glossary.html#import_models_and_other_dependencies_from_the_current_app","text":"from .models import *","title":"Import models and other dependencies from the current app."},{"location":"glossary.html#import_logging_module_for_creating_log_entries","text":"import logging","title":"Import logging module for creating log entries."},{"location":"glossary.html#get_a_logger_instance_named_log","text":"log = logging.getLogger('log')","title":"Get a logger instance named 'log'."},{"location":"glossary.html#define_a_receiver_function_to_be_triggered_after_saving_a_grequests_instance","text":"@receiver(post_save, sender=GRequests) def make_glossary(sender, instance, created, args, *kwargs): \"\"\" Receiver function triggered after saving a GRequests instance. This function is a signal receiver that gets triggered after a GRequests instance is saved. It checks if the instance is newly created (created=True), and if not, it creates a Glossary entry based on the GRequests instance and then deletes the GRequests instance. Args: sender: The sender of the signal. instance: The instance of the GRequests model. created (bool): Indicates whether the GRequests instance was newly created. *args: Additional positional arguments. **kwargs: Additional keyword arguments. \"\"\" if created: # If the GRequests instance is newly created, do nothing. pass else: # If the GRequests instance is not newly created, create a Glossary entry. log.info('Glossary created from request________________') Glossary.objects.create(title = instance.title, description = instance.description) # Delete the GRequests instance since it's now been converted to a Glossary entry. instance.delete()","title":"Define a receiver function to be triggered after saving a GRequests instance."},{"location":"glossary.html#url_configuration_urlspy","text":"In the urls.py file of the Glossary app, we define the URL patterns for accessing the app's views. Here's an overview of the URL configuration: ```python","title":"URL Configuration (urls.py)"},{"location":"glossary.html#import_necessary_modules_and_views_from_the_glossary_app","text":"","title":"Import necessary modules and views from the Glossary app."},{"location":"glossary.html#_3","text":"","title":"..."},{"location":"glossary.html#define_the_app_name_for_url_namespace","text":"app_name = 'glossary'","title":"Define the app name for URL namespace."},{"location":"glossary.html#define_url_patterns_for_the_glossary_app","text":"urlpatterns = [ # Define a URL pattern for the glossary list view. path('', views.Glist.as_view(), name='g_list'), ]","title":"Define URL patterns for the 'glossary' app."},{"location":"glossary.html#views_viewspy","text":"In the views.py file of the Glossary app, we define view functions and classes responsible for rendering glossary-related web pages, handling user requests, and providing additional context data. Here's an overview of the views and their functionality:","title":"Views (views.py)"},{"location":"glossary.html#glist_class-based_view","text":"The Glist class-based view is responsible for displaying the glossary list, handling glossary request submissions, and providing additional context data. Here's a breakdown of its attributes and methods: Attributes: model (Glossary) : The model to query for glossary entries. paginate_by (int, optional) : Uncomment to enable pagination with a specific number of entries per page. Methods: get_context_data(**kwargs) : Overrides the base class method to provide additional context data for rendering the glossary list view. It includes a form for submitting glossary requests and meta information. post(request, *args, **kwargs) : Handles POST requests for submitting glossary requests. It validates the request form, saves the request if it's valid, and provides feedback to the user via messages. The Glist view plays a crucial role in managing glossary entries and user interactions with the glossary section of the application. By using this view, users can view glossary entries, submit requests for new glossary entries, and receive feedback on their submissions. This view also incorporates meta information for SEO purposes, enhancing the user experience. Keep in mind that pagination can be enabled by uncommenting the paginate_by attribute and specifying the desired number of entries per page. ```python model = Glossary","title":"Glist (Class-based View)"},{"location":"glossary.html#paginate_by_100_uncomment_to_enable_pagination_with_a_specific_number_of_entries_per_page","text":"","title":"paginate_by = 100  # Uncomment to enable pagination with a specific number of entries per page."},{"location":"guide.html","text":"===================================== Django Guide App - Developer's Guide ===================================== This is the developer's guide for the Django Guide App, an application designed to manage and display guides in a Django project. This guide will walk you through the key components of the app, starting with the admin.py file. Admin Configuration ( admin.py ) \u00b6 The admin.py file is where we define the admin interface for managing our guide-related models. Here, we'll provide an overview of each admin class and its functionality. GenarelGuideAdmin : This admin class is used to manage instances of the GenarelGuide model. It extends SummernoteModelAdmin to enable a rich text editor for the content field. The list_filter attribute adds a filter for the menu field in the admin interface. @admin.register(GenarelGuide) class GenarelGuideAdmin(SummernoteModelAdmin): summernote_fields = ('content',) # Enable Summernote for the 'content' field list_filter = ('menu',) # Add a filter for the 'menu' field GuideTypeAdmin : This admin class is used to manage instances of the GuideType model. It includes the prepopulated_fields attribute, which automatically generates the key field based on the title field. If you want the key field to be read-only, uncomment the readonly_fields attribute. @admin.register(GuideType) class GuideTypeAdmin(admin.ModelAdmin): prepopulated_fields = {'key': ('title',)} # Auto-generate 'key' based on 'title' # readonly_fields = ('key',) # Uncomment this line if 'key' should be read-only GuideMenuAdmin : This admin class is used to manage instances of the GuideMenu model. Similar to GuideTypeAdmin , it includes the prepopulated_fields attribute, which generates the slug field based on the title field. The list_filter attribute adds a filter for the guidetype field in the admin interface. @admin.register(GuideMenu) class GuideMenuAdmin(admin.ModelAdmin): prepopulated_fields = {'slug': ('title',)} # Auto-generate 'slug' based on 'title' list_filter = ('guidetype',) # Add a filter for the 'guidetype' field Installation and Usage \u00b6 To use the Django Guide App in your project, follow these steps: Install the app by adding it to your project's INSTALLED_APPS in the project's settings: python INSTALLED_APPS = [ # ... 'guide', # Add 'guide' to your installed apps # ... ] Configure the app's database models by running migrations: bash python manage.py makemigrations guide python manage.py migrate Create a superuser to access the admin interface: bash python manage.py createsuperuser Register your guide-related models in the admin.py file as shown above. Start the development server: bash python manage.py runserver Access the admin interface at http://localhost:8000/admin/ and use the registered admin classes to manage guides, guide types, and guide menus. =============================== Django Guide App - Models Guide =============================== This is the models guide for the Django Guide App, explaining the structure and attributes of the models defined in the models.py file. Models Overview ( models.py ) \u00b6 The models.py file defines three main models used in the Django Guide App: GuideType , GuideMenu , and GenarelGuide . Each model represents a different aspect of managing guides. GuideType Model: Model representing different types of guides. Attributes: title (CharField): The title of the guide type. position (IntegerField): The position of the guide type. key (SlugField): A slug field used for identifying the guide type. icon_image (ImageField): An image field for the guide type's icon. The __str__ method returns the title of the guide type. The get_absolute_url method returns the absolute URL for the guide type. GuideMenu Model: Model representing menus for guides. Attributes: title (CharField): The title of the guide menu. position (IntegerField): The position of the guide menu. guidetype (ForeignKey): A foreign key to the associated guide type. slug (SlugField): A slug field used for identifying the menu. The __str__ method returns the title of the guide menu. The get_absolute_url method returns the absolute URL for a general guide within this menu. GenarelGuide Model: Model representing general guides. Attributes: title (CharField): The title of the general guide. position (IntegerField): The position of the general guide. menu (ForeignKey): A foreign key to the related guide menu. anchor (CharField): An anchor field. parent (ForeignKey): A foreign key to a parent guide (self-referential relationship). content (TextField): The content of the general guide. The __str__ method returns the title of the general guide along with its parent information. Usage and Relationships \u00b6 These models are designed to create a structured system for managing and displaying guides within your Django project. GuideType defines the types of guides, GuideMenu organizes guides into menus, and GenarelGuide contains the actual guide content. GuideType and GuideMenu are related through a foreign key, allowing you to group menus by guide type. GenarelGuide is related to GuideMenu to associate guides with specific menus. You can further customize these models or add additional fields to suit the specific requirements of your project. For more information on using Django models, refer to the official Django documentation: https://docs.djangoproject.com/ ============================= Django Guide App - URLs Guide ============================= This is the URLs guide for the Django Guide App, explaining the URL patterns and their associated views defined in the urls.py file. URL Patterns Overview ( urls.py ) \u00b6 The urls.py file defines the URL patterns that map URLs to views within the Django Guide App. Here's an overview of the defined URL patterns: Guide Home Page: URL Pattern: /guide View: views.guide_home Name: 'guide:guide_home' Description: This URL pattern maps to the guide_home view, which serves as the home page for the guide app. Specific Guide Type: URL Pattern: /guide/<str:key> View: views.guide_type Name: 'guide:guide_type' Description: This URL pattern is used to display guides of a specific type. The key parameter is a dynamic part of the URL. General Guide Under a Specific Guide Type: URL Pattern: /guide/<str:gt>/<str:slug> View: views.genarel_guide Name: 'guide:genarel_guide' Description: This URL pattern is used to display a general guide under a specific guide type. It takes two dynamic parameters, gt and slug . Using these URL patterns, you can navigate to different sections of the guide app, view guides of specific types, and access individual general guides. Namespace and app_name \u00b6 The 'guide' namespace is set using the app_name variable at the beginning of the urls.py file. This namespace is used to organize and avoid naming conflicts with URL patterns from other apps in your Django project. Each URL pattern is associated with a unique name, which can be used for reverse URL lookups or in templates. The names are prefixed with 'guide:' to specify the namespace. For example: - 'guide:guide_home' refers to the URL pattern for the guide home page. - 'guide:guide_type' refers to the URL pattern for displaying guides of a specific type. - 'guide:genarel_guide' refers to the URL pattern for displaying a general guide under a specific guide type. ============================= Django Guide App - Views Guide ============================= This is the views guide for the Django Guide App, explaining the purpose and functionality of each view defined in the views.py file. Views Overview ( views.py ) \u00b6 The views.py file contains view functions that handle HTTP requests and define the behavior of different pages in the Django Guide App. Here's an overview of each view: guide_home View: URL: /guide Description: This view function serves as the home page for the guide app. It retrieves information about guide types and renders the home page template with guide type information. Args: request (HttpRequest): The request object. Returns: HttpResponse : The rendered home page. guide_type View: URL: /guide/<str:key> Description: This view function displays guides of a specific type. It retrieves guide menus for the specified guide type and renders the guide type template. Args: request (HttpRequest): The request object. key (str): The key of the guide type. Returns: HttpResponse : The rendered guide type page. genarel_guide View: URL: /guide/<str:gt>/<str:slug> Description: This view function displays a general guide under a specific guide type and menu. It retrieves general guides for the specified guide type and menu and renders the general guide template. Args: request (HttpRequest): The request object. gt (str): The key of the guide type. slug (str): The slug of the guide menu. Returns: HttpResponse : The rendered general guide page. Each view function takes a request parameter, which represents the incoming HTTP request, and returns an HttpResponse object that represents the rendered HTML page. Meta Information and SEO \u00b6 Each view includes meta information for SEO (Search Engine Optimization) and social sharing. This information helps improve the visibility and sharing of the guide content. It includes metadata such as titles, descriptions, tags, and images. Customization \u00b6 You can customize the app further to meet your project's specific requirements. For example, you can extend the models, add additional fields, or modify the admin classes to tailor the admin interface to your needs. For more information on Django development and customization, refer to the official Django documentation: https://docs.djangoproject.com/ Feedback and Contributions \u00b6 We welcome feedback, bug reports, and contributions to this project. If you encounter any issues or have suggestions for improvements, please open an issue on the GitHub repository of this project. Thank you for using the Django Guide App! ```","title":"User Guide"},{"location":"guide.html#admin_configuration_adminpy","text":"The admin.py file is where we define the admin interface for managing our guide-related models. Here, we'll provide an overview of each admin class and its functionality. GenarelGuideAdmin : This admin class is used to manage instances of the GenarelGuide model. It extends SummernoteModelAdmin to enable a rich text editor for the content field. The list_filter attribute adds a filter for the menu field in the admin interface. @admin.register(GenarelGuide) class GenarelGuideAdmin(SummernoteModelAdmin): summernote_fields = ('content',) # Enable Summernote for the 'content' field list_filter = ('menu',) # Add a filter for the 'menu' field GuideTypeAdmin : This admin class is used to manage instances of the GuideType model. It includes the prepopulated_fields attribute, which automatically generates the key field based on the title field. If you want the key field to be read-only, uncomment the readonly_fields attribute. @admin.register(GuideType) class GuideTypeAdmin(admin.ModelAdmin): prepopulated_fields = {'key': ('title',)} # Auto-generate 'key' based on 'title' # readonly_fields = ('key',) # Uncomment this line if 'key' should be read-only GuideMenuAdmin : This admin class is used to manage instances of the GuideMenu model. Similar to GuideTypeAdmin , it includes the prepopulated_fields attribute, which generates the slug field based on the title field. The list_filter attribute adds a filter for the guidetype field in the admin interface. @admin.register(GuideMenu) class GuideMenuAdmin(admin.ModelAdmin): prepopulated_fields = {'slug': ('title',)} # Auto-generate 'slug' based on 'title' list_filter = ('guidetype',) # Add a filter for the 'guidetype' field","title":"Admin Configuration (admin.py)"},{"location":"guide.html#installation_and_usage","text":"To use the Django Guide App in your project, follow these steps: Install the app by adding it to your project's INSTALLED_APPS in the project's settings: python INSTALLED_APPS = [ # ... 'guide', # Add 'guide' to your installed apps # ... ] Configure the app's database models by running migrations: bash python manage.py makemigrations guide python manage.py migrate Create a superuser to access the admin interface: bash python manage.py createsuperuser Register your guide-related models in the admin.py file as shown above. Start the development server: bash python manage.py runserver Access the admin interface at http://localhost:8000/admin/ and use the registered admin classes to manage guides, guide types, and guide menus. =============================== Django Guide App - Models Guide =============================== This is the models guide for the Django Guide App, explaining the structure and attributes of the models defined in the models.py file.","title":"Installation and Usage"},{"location":"guide.html#models_overview_modelspy","text":"The models.py file defines three main models used in the Django Guide App: GuideType , GuideMenu , and GenarelGuide . Each model represents a different aspect of managing guides. GuideType Model: Model representing different types of guides. Attributes: title (CharField): The title of the guide type. position (IntegerField): The position of the guide type. key (SlugField): A slug field used for identifying the guide type. icon_image (ImageField): An image field for the guide type's icon. The __str__ method returns the title of the guide type. The get_absolute_url method returns the absolute URL for the guide type. GuideMenu Model: Model representing menus for guides. Attributes: title (CharField): The title of the guide menu. position (IntegerField): The position of the guide menu. guidetype (ForeignKey): A foreign key to the associated guide type. slug (SlugField): A slug field used for identifying the menu. The __str__ method returns the title of the guide menu. The get_absolute_url method returns the absolute URL for a general guide within this menu. GenarelGuide Model: Model representing general guides. Attributes: title (CharField): The title of the general guide. position (IntegerField): The position of the general guide. menu (ForeignKey): A foreign key to the related guide menu. anchor (CharField): An anchor field. parent (ForeignKey): A foreign key to a parent guide (self-referential relationship). content (TextField): The content of the general guide. The __str__ method returns the title of the general guide along with its parent information.","title":"Models Overview (models.py)"},{"location":"guide.html#usage_and_relationships","text":"These models are designed to create a structured system for managing and displaying guides within your Django project. GuideType defines the types of guides, GuideMenu organizes guides into menus, and GenarelGuide contains the actual guide content. GuideType and GuideMenu are related through a foreign key, allowing you to group menus by guide type. GenarelGuide is related to GuideMenu to associate guides with specific menus. You can further customize these models or add additional fields to suit the specific requirements of your project. For more information on using Django models, refer to the official Django documentation: https://docs.djangoproject.com/ ============================= Django Guide App - URLs Guide ============================= This is the URLs guide for the Django Guide App, explaining the URL patterns and their associated views defined in the urls.py file.","title":"Usage and Relationships"},{"location":"guide.html#url_patterns_overview_urlspy","text":"The urls.py file defines the URL patterns that map URLs to views within the Django Guide App. Here's an overview of the defined URL patterns: Guide Home Page: URL Pattern: /guide View: views.guide_home Name: 'guide:guide_home' Description: This URL pattern maps to the guide_home view, which serves as the home page for the guide app. Specific Guide Type: URL Pattern: /guide/<str:key> View: views.guide_type Name: 'guide:guide_type' Description: This URL pattern is used to display guides of a specific type. The key parameter is a dynamic part of the URL. General Guide Under a Specific Guide Type: URL Pattern: /guide/<str:gt>/<str:slug> View: views.genarel_guide Name: 'guide:genarel_guide' Description: This URL pattern is used to display a general guide under a specific guide type. It takes two dynamic parameters, gt and slug . Using these URL patterns, you can navigate to different sections of the guide app, view guides of specific types, and access individual general guides.","title":"URL Patterns Overview (urls.py)"},{"location":"guide.html#namespace_and_app_name","text":"The 'guide' namespace is set using the app_name variable at the beginning of the urls.py file. This namespace is used to organize and avoid naming conflicts with URL patterns from other apps in your Django project. Each URL pattern is associated with a unique name, which can be used for reverse URL lookups or in templates. The names are prefixed with 'guide:' to specify the namespace. For example: - 'guide:guide_home' refers to the URL pattern for the guide home page. - 'guide:guide_type' refers to the URL pattern for displaying guides of a specific type. - 'guide:genarel_guide' refers to the URL pattern for displaying a general guide under a specific guide type. ============================= Django Guide App - Views Guide ============================= This is the views guide for the Django Guide App, explaining the purpose and functionality of each view defined in the views.py file.","title":"Namespace and app_name"},{"location":"guide.html#views_overview_viewspy","text":"The views.py file contains view functions that handle HTTP requests and define the behavior of different pages in the Django Guide App. Here's an overview of each view: guide_home View: URL: /guide Description: This view function serves as the home page for the guide app. It retrieves information about guide types and renders the home page template with guide type information. Args: request (HttpRequest): The request object. Returns: HttpResponse : The rendered home page. guide_type View: URL: /guide/<str:key> Description: This view function displays guides of a specific type. It retrieves guide menus for the specified guide type and renders the guide type template. Args: request (HttpRequest): The request object. key (str): The key of the guide type. Returns: HttpResponse : The rendered guide type page. genarel_guide View: URL: /guide/<str:gt>/<str:slug> Description: This view function displays a general guide under a specific guide type and menu. It retrieves general guides for the specified guide type and menu and renders the general guide template. Args: request (HttpRequest): The request object. gt (str): The key of the guide type. slug (str): The slug of the guide menu. Returns: HttpResponse : The rendered general guide page. Each view function takes a request parameter, which represents the incoming HTTP request, and returns an HttpResponse object that represents the rendered HTML page.","title":"Views Overview (views.py)"},{"location":"guide.html#meta_information_and_seo","text":"Each view includes meta information for SEO (Search Engine Optimization) and social sharing. This information helps improve the visibility and sharing of the guide content. It includes metadata such as titles, descriptions, tags, and images.","title":"Meta Information and SEO"},{"location":"guide.html#customization","text":"You can customize the app further to meet your project's specific requirements. For example, you can extend the models, add additional fields, or modify the admin classes to tailor the admin interface to your needs. For more information on Django development and customization, refer to the official Django documentation: https://docs.djangoproject.com/","title":"Customization"},{"location":"guide.html#feedback_and_contributions","text":"We welcome feedback, bug reports, and contributions to this project. If you encounter any issues or have suggestions for improvements, please open an issue on the GitHub repository of this project. Thank you for using the Django Guide App! ```","title":"Feedback and Contributions"},{"location":"home.html","text":"================================== Home App - Django Project Skeleton ================================== Description \u00b6 The \"home\" app is an integral part of the Django project. It includes various components that are essential for the functionality of the project. This readme provides an overview of the key components within the \"home\" app. Components \u00b6 admin.py : This module contains configurations for Django's admin interface, allowing administrators to manage data associated with the \"home\" app. forms.py : The forms module includes form classes used for user input validation and data submission within the app. models.py : In this module, the database models are defined, which represent the data structures and relationships for the \"home\" app. views.py : The views module contains view functions that handle user requests, process data, and render templates. - helper.py : This module may include any utility functions or helpers used across the \"home\" app to streamline common tasks or logic. \u00b6 admin.py \u00b6 admin.py : This module contains configurations for Django's admin interface, allowing administrators to manage data associated with the \"home\" app. In this file, various models are registered with the Django admin site to provide an interface for administrators to manage data. The following models are registered: PriceUnit : Registered with the Django admin site to manage price units. WeightUnit : Registered with the Django admin site to manage weight units. TimeUnit : Registered with the Django admin site to manage time units. QuotationDocType : Registered with the Django admin site to manage quotation document types. Quotation : Registered with the Django admin site to manage quotations. These registrations enable administrators to create, edit, and delete records related to these models using the Django admin interface. forms.py \u00b6 This forms.py file defines custom form classes for various aspects of a web application. These form classes are designed to provide a more tailored and user-friendly experience for creating and editing user profiles, updating company logos, and managing questions. PasswordChangeForm The PasswordChangeForm is a custom form for changing a user's password. It enhances the default Django PasswordChangeForm by updating the widget attributes to improve user experience. Specifically, it sets the autocomplete values for old and new passwords and assigns CSS classes for styling. UserForm The UserForm is used for creating and editing user profiles. It is based on the Django ModelForm and is associated with the User model. The form fields are customized with placeholders, CSS classes, and ARIA labels to make the user interface more user-friendly. CompanyLogoForm The CompanyLogoForm is designed for updating company logos in user profiles. It is also based on the ModelForm and is associated with the Profile model. It customizes the widget for the company_logo field, providing a user-friendly way to update the company's logo. ProfileForm The ProfileForm is used for creating and editing user profiles. It is similar to the UserForm but focuses on fields related to a user's personal profile, such as about information, location, and establishment date. The form fields are customized with placeholders, CSS classes, and ARIA labels for improved user experience. QuestionForm The QuestionForm is employed for creating and editing questions. It is associated with the Question model and customizes the widget for the name field. It also provides a more user-friendly experience by adding placeholders, CSS classes, and ARIA labels to the form fields. OptionForm The OptionForm is used for creating and editing options. It is associated with the Option model and customizes the widget for the 'name' and 'statement' fields. These fields have placeholders, CSS classes, and ARIA labels for a better user interface. QuotationForm The QuotationForm is designed for creating and editing quotations. It is associated with the Quotation model and provides extensive customization for various fields. These customizations include input styling, CSS classes, and ARIA labels for fields like price, time, unit, document requirements, and more. Additionally, it handles file uploads for quotation formats. NextActivitiesOnQuotation The NextActivitiesOnQuotation form is intended for updating next activities on quotations. It is associated with the Quotation model and customizes the widget for the 'next_activities' field with styling and a select input. SuggestionForm The SuggestionForm allows the creation and editing of suggestions. It is associated with the Suggestions model and provides customization for fields like suggestion type, title, and statement. The form includes select inputs, text inputs, and text areas with appropriate attributes to enhance user interaction. QuesSugestionForm The QuesSugestionForm is a custom form for creating and editing question suggestions. It is associated with the Suggestions model and includes a special constructor ( __init__ ) that populates choices for the 'related_qs' field based on a custom function. The form also customizes the widget for 'su_type,' 'title,' 'statement,' and 'related_qs' fields. It provides select inputs, text inputs, and text areas, along with appropriate placeholders and attributes. This form enhances the user experience in creating and editing question suggestions. NextActivitiesForm The NextActivitiesForm is used for creating and editing next activities. It is associated with the NextActivities model and includes a constructor to handle the 'request' object. The form customizes the widget for various fields, including 'related_questions,' 'compulsory_questions,' 'name_and_standared,' 'priority,' and others. It provides input styling, placeholders, and attributes for an improved user experience. The form also includes a custom save method that checks for the existence of instances with the same selected IDs and, if found, takes specific actions such as updating user IDs and sending notifications to the admin. Developers can use these forms as part of the application's functionality for creating, editing, and managing options, quotations, and suggestions. Ensure that these forms are integrated into your Django project as needed and referenced in associated views and templates. For more information on using these forms and their integration into your Django project, please refer to the associated views and templates in your application. helper.py \u00b6 The helper.py module contains a set of custom helper methods aimed at assisting with data calculation and retrieval. These methods offer valuable functionality for calculating the total number of reports, the total number of reports created by the current user, and counting the number of users under each label. total_reports(request) The total_reports method calculates the total number of reports in the database. It queries the Evaluator model and counts all instances. This count is useful for generating statistics and insights regarding the reports within your application. total_this_user_report(request) The total_this_user_report method calculates the total number of reports created by the current user. It filters the Evaluator model by the creator attribute, which is set to the current user, and counts the instances. This count helps users monitor and manage their own reports. users_under_each_label(request) The users_under_each_label method counts the number of users associated with each label. It retrieves a list of labels by calling get_all_definedlabel() and filters out labels marked as common. To optimize database queries, it prefetches related users for each label. The method constructs a dictionary where the keys represent label names, and the values indicate the count of users under each label. This information is valuable for analyzing user distribution based on labels. reports_under_each_biofuel(request) The reports_under_each_biofuel method counts the number of reports under each biofuel category. It retrieves the biofuel categories and calculates the count of reports associated with each category. The results are stored in a dictionary where the keys represent biofuel names, and the values represent the count of reports under each biofuel category. This information is valuable for understanding the distribution of reports based on biofuel types. weeks_results(request) The weeks_results method retrieves the number of reports generated in the last year and formats the results. It calculates the date one year ago from the current date, filters reports created in the last year, and aggregates the report counts by month/year. The results are formatted into a dictionary where keys are formatted date strings (month/year), and values represent the report counts. This information is useful for tracking report generation trends over time. all_reports(request) The all_reports method retrieves and filters reports based on user roles and calculates additional statistics. It checks the user's role, and if they are a staff member or superuser, all reports are shown. For regular users, only their reports are displayed. The method calculates the number of answered, positive, and \"don't know\" responses for each report, providing insights into response patterns. The results are paginated, with 10 reports per page, and additional statistics are included in each report's information. This method streamlines report management, making it easier to access and analyze data. typewise_user(request) The `typewise_user` method fetches all user types, each of which represents a specific classification or role for users in your application. To optimize database queries, it prefetches related users for each user type. The method returns a dictionary where the keys are user type objects, and the values are lists of associated users, limited to the first 4 users for each type. This limitation helps provide a concise overview of user types and their members. This method is beneficial for various purposes, including generating user statistics, understanding user role distributions, and facilitating user management. These helper methods simplify data processing and statistics generation within your application. Developers can leverage these methods in various scenarios, such as generating reports, user management, or label-based analytics. Integration into your views or other application components is essential to maximize the benefits of these methods. For detailed information on using these methods and their integration into your Django project, please refer to the associated views and templates in your application. These methods serve as essential components for data analysis and user management. models.py \u00b6 This section of models.py introduces several essential models designed to represent various attributes within the application, such as price units, time units, weight units, and quotation document types. These models serve as fundamental components for managing and categorizing data. Here's a detailed explanation: User Model The User model is dynamically defined based on the project's AUTH_USER_MODEL setting. It represents the user entities within your application. This model stores user-related information and is used for user authentication and management. The specific fields and attributes associated with the User model are determined by your project's settings. PriceUnit Model The PriceUnit model represents different price units used in the application, such as currency symbols (e.g., USD, EUR). Each instance of this model corresponds to a specific price unit. The name attribute stores the name of the price unit. This model simplifies the handling of price-related data. TimeUnit Model The TimeUnit model represents time units, such as minutes and hours. Each instance of this model corresponds to a specific time unit. The name attribute stores the name of the time unit. This model is valuable for dealing with time-related calculations and data presentation. WeightUnit Model The WeightUnit model represents various weight units, such as kilograms (kg) and pounds (lb). Each instance of this model corresponds to a specific weight unit. The name attribute stores the name of the weight unit. This model simplifies the handling of weight-related data. QuotationDocType Model The QuotationDocType model represents different document types that can be associated with quotations. Examples of document types include PDF and Word documents. Each instance of this model corresponds to a specific document type. The name attribute stores the name of the document type. This model categorizes and manages document types associated with quotations. Quotation Model The Quotation model represents a quotation for testing services. It stores essential information related to the quotation and is used to manage quotations provided by service providers. Below are the attributes and their descriptions associated with the Quotation model: service_provider (ForeignKey to User) Represents the user who provides the quotation. show_alternate_email (EmailField, optional) Represents an alternate email address for the quotation (optional). show_alternate_business (CharField, optional) Represents an alternate business name for the quotation (optional). show_alternate_phone (CharField, optional) Represents an alternate phone number for the quotation (optional). price (DecimalField) Stores the quotation's price. Users should provide the price for the service. price_unit (ForeignKey to PriceUnit) Represents the unit of the price. Users can choose from available pricing units. needy_time (IntegerField) Indicates the time needed for the test to be conducted. needy_time_unit (ForeignKey to TimeUnit) Represents the unit of time needed for the test. sample_amount (IntegerField) Stores the amount of sample needed for the test. sample_amount_unit (ForeignKey to WeightUnit) Represents the unit of weight for the sample amount. require_documents (ManyToManyField to QuotationDocType) Represents the documents needed for the test. Users can select multiple document types required for the service. factory_pickup (BooleanField) Indicates whether the sample will be collected from the factory. test_for (ForeignKey to Question) Represents the question for which the test is conducted. Users can select from available questions. related_questions (ManyToManyField to Question) Allows the selection of other questions that are tested within the provided quotation. Users can select multiple related questions. quotation_format (FileField) Allows the uploading of a quotation file, which must be in PDF format. next_activities (ForeignKey to NextActivities, optional) Represents next activities related to the quotation (optional). display_site_address (BooleanField) Indicates if the site address should be displayed. comments (TextField, optional) Provides an additional space for users to add comments related to the quotation (optional). Key Properties and Methods: - get_quot_url : Returns the URL to add a new quotation for the corresponding question. - get_business_name : Retrieves the business name for the quotation based on display settings. - get_phone : Retrieves the phone number for the quotation based on display settings. - get_email : Retrieves the email address for the quotation based on display settings. - get_absolute_url : Gets the absolute URL for the quotation report. The Quotation model is a fundamental component of your application for managing quotations for testing services, facilitating interactions between service providers and users seeking testing services. These models are vital for maintaining consistent and organized data storage within your application. Developers can create, update, and retrieve instances of these models as needed to manage and categorize various attributes and data types effectively. For detailed information on using these models, including creating and managing instances, refer to the relevant views, forms, and templates in your application. These models serve as the foundation for data representation and management. views.py \u00b6 This document provides an overview of the views defined in the project's views.py file. Views are responsible for handling HTTP requests and returning appropriate HTTP responses. Below are the main views and their descriptions: home(request) View for the home page. Displays information on the home page. Caches user types and latest blog posts for efficient access. Meta data is set for page details. Available context data: user_types : Cached user types. latest_blogs : Cached latest blog posts. site_info : Meta data for the page. user_types(request, slug) View for displaying different user types and initiating the user signup journey. Sets the 'interested_in' session variable to the selected user type's slug. Ensures the user is logged in to initiate enrollment. Determines enrollment options based on user type and permissions. Retrieves user type data and related users. Meta data is set for page details. Available context data: user_type : Selected user type. users : Users associated with the selected user type. enroll : Enrollment options. site_info : Meta data for the page. dashboard(request) View for displaying the user dashboard. Requires the user to be logged in. Provides a summary of dashboard data, including weekly results, user labels, biofuel records, and more. Meta data is set for page details. Available context data: user_of_labels : User labels statistics. biofuel_records : Biofuel records statistics. day_of_week : Days of the week for weekly results. total_of_day : Total reports for each day of the week. total_reports : Total number of reports. allreports : Paginated list of reports and additional statistics. typewise_user : User types and associated users. site_info : Meta data for the page. questionsint(request) View for displaying questions related to the current marine user. Protected with @login_required and @marine_required decorators, ensuring that only logged-in marine users can access it. Provides specialized questions to get feedback from marine experts. Retrieves parent questions and related child questions. Paginates the results for display. Meta data is set for page details. Available context data: questions : Specialized questions for marine users. site_info : Meta data for the page. user_setting(request) View for managing user settings and profile. Allows logged-in users to update their general information, profile data, password, company logo, and notification settings. Handles different form submissions for various sections of user settings. Initializes form instances for different sections. Meta data is set for page details. Available context data: user : The logged-in user. user_form : Form for general user information. profile_form : Form for user profile data. password_form : Form for changing the password. company_logo_form : Form for updating the company logo. notification_form : Form for notification settings. site_info : Meta data for the page. delete_avatar(request) View for deleting the user's avatar. Deletes the user's company logo from the profile. Redirects to the user settings page after deletion. password_change(request) View for changing the user's password. Allows logged-in users to change their password by providing the current and new password. Handles form submissions for changing the password. Initializes the form instance for changing the password. Updates the session auth hash after password change. Meta data is set for page details. Available context data: user : The logged-in user. password_form : Form for changing the password. site_info : Meta data for the page. get_question_of_label(request) View to retrieve questions of a specific label. Checks if the user has the necessary permissions (staff, superuser, expert, marine) to access questions. If the user has the required permissions, it retrieves all questions. If the user lacks permissions, it redirects and displays a warning message. Available context data: questions : A list of questions (or a redirection if user lacks permissions). child_modal_data(request, id) View to retrieve data for a child question modal. Designed to fetch data for a child question modal. Checks if the user is logged in, returning a message if not. Ensures access is allowed to experts only, returning a message if the user lacks the necessary permissions. Retrieves the question data with related data prefetching. Renders a child question modal data template. Available context data: qquestion : Question data. quotations(request) View to display quotations related to questions. Allows logged-in experts (staff, superuser) to access quotations associated with questions. Retrieves questions and their related data, including quotations. Provides a paginated response for viewing. Meta data is set for page details. Available context data: questions : Paginated list of questions with related quotations. site_info : Meta data for the page. quotationsatg(request) View to display quotations at a glance. Allows logged-in experts (staff, superuser) to access quotations at a glance. Quotations can be accessed by staff, superusers, or the service provider (user) who created them. Retrieves quotations and provides a paginated response for viewing. Meta data is set for page details. Available context data: quotations : Paginated list of quotations. site_info : Meta data for the page. add_quatation(request, slug) View to add or edit a quotation for a specific question. Available to logged-in experts (staff, superuser). Checks if the user is logged in, has the necessary permissions, and allows adding or editing quotations. Manages form submissions for adding/editing quotations. Saves the quotations, related questions, and next activities. Checks and validates data related to quotations. Deletes the session of next activities after saving the quotation. Ensures that a question exists for adding/editing quotations. Meta data is set for page details. Available context data: question : The specific question for which the quotation is added or edited. form : Form for adding/editing quotations. na_form : Form for selecting next activities. quatation : The quotation being added/edited. report_link : Link to view the quotation report. site_info : Meta data for the page. get_verbose_name(instance, field_name) Helper function to get the verbose_name for a field in a model instance. Takes the model instance and the field name as arguments. Returns the verbose_name of the specified field title-cased. quotation_report2(request, quotation_data) Sub-function to generate a PDF report based on quotation data. Generates a PDF report for a given quotation data. Creates a PDF document using the ReportLab library and includes quotation details, related questions, and additional information. Returns the generated PDF as a BytesIO buffer. quotation_report(request, question, quotation) View to return a final report with an attachment as a PDF. Generates a final report in PDF format by merging the contents of a quotation report and an attachment (if available) into a single PDF document. Uses the PyPDF2 library to merge the two PDFs. Returns the generated PDF report as an HTTP response. Available context data: question : The question associated with the quotation. quotation : The ID of the quotation for which the report is generated. questions_details(request, slug) View to display and edit the details of a specific question. Marine experts can view and edit the question text, associated options, and other attributes. The view uses a combined form that includes the main question and its associated options. Available context data: slug : The slug of the question to be displayed and edited. question : The specific question to be edited. Returns an HTTP response containing the question details and an editable form. new_questions(request) View to add a new question and associated options. Marine experts can add a new question along with its associated options. The view provides a form for inputting the question text and options for the new question. Available context data: No specific context data other than site metadata. Returns an HTTP response containing the form for adding a new question and options. allreports(request) View to display a list of evaluation reports for biofuels. Admin users can see all reports, while biofuel producers can only see their own reports. The view provides a list of evaluation reports for biofuels. Available context data: No specific context data other than site metadata. Returns an HTTP response containing the list of evaluation reports. check_type_to_get_expert(request) View to check the user type selected during registration and set session variables accordingly. Used during the registration process to determine the user type selected by the user and set session variables based on that selection. Retrieves the user type from the request's POST data and sets the 'interested_in' session variable to the user type's slug. Sets the 'hidden' session variable to 'hidden' if the user type is not an expert, indicating that certain form fields should be hidden in the registration form. Returns a redirection to the registration page. add_extra(request, pk) View to add an extra form field. Increments the 'extra' session variable to control front-end behavior. Returns a redirection to the question details page. sub_extra(request, pk) View to subtract an extra form field. Decrements the 'extra' session variable if it's greater than or equal to 1 to control front-end behavior. Returns a redirection to the question details page. webmanifest(request) View to generate a web app manifest. Creates a web app manifest containing data such as the app's name, icons, and other configuration options. Returns a JSON response containing the web app manifest data. AddSugestion(View) Class-based view for adding or editing suggestions related to a question. Handles both GET and POST requests for displaying the form and processing form submissions. Attributes: get_temp (str): Template file for rendering the form. form_class (class): Form class used for suggestion input. Methods: get(self, request, *args, **kwargs) : Handles GET requests to display the suggestion form. post(self, request, *args, **kwargs) : Handles POST requests to process form submissions. get_edit_sugestion(request, slug, pk) View to edit an existing suggestion related to a question. Allows marine users to edit an existing suggestion for a specific question based on its primary key (pk). get_sugestion_list(request, slug) View to display a list of suggestions related to a specific question. Retrieves and displays a list of suggestions related to a specific question, identified by its slug. delete_sugestion(request, pk) View to delete a suggestion. Allows authenticated users, typically marine experts, to delete a specific suggestion based on its primary key (pk). Users must have the necessary permissions to delete the suggestion. Only the creator of the suggestion, admin users, and superusers can delete it. sugest_new_ques_option(request) View to suggest new questions and options for evaluation. Allows marine experts to submit suggestions for new questions and corresponding options. The submitted suggestions are reviewed and, if approved, added to the evaluation pool. Displays previously suggested questions by the same expert. get_edit_new_sugestion(request, pk) View to edit a new suggestion. Allows marine experts to edit a previously suggested question or option. Experts can update the statement, title, related questions, and suggestion type. Changes are saved if the expert is the creator of the suggestion or has staff/superuser privileges. get_new_sugestion_list(request) View to display a list of new suggestions created by the marine expert. Retrieves and displays a list of new suggestions created by the marine expert. These suggestions have not been associated with a specific question or option yet. add_new_service(request, user_id) View to allow an expert to add a new service or select an existing service for a visiting user. Allows an expert user to add a new service or select an existing service for a visiting user. The expert can provide details about the service and associate it with related and compulsory questions. If an existing service is found for the selected questions, the expert is prompted to select that service. These views empower expert users to provide services and options to visiting users and facilitate the management of services associated with specific questions. Please note that these views are part of the project's features for user interaction and service management. Additional views and features may be defined elsewhere in the project based on specific requirements. These views serve as the core components of the project, handling various functionalities and interactions with users on the website. Please note that the mentioned views are not the entire list of views in the project. Additional views may be defined elsewhere in the project based on specific requirements. Contributing \u00b6 Feel free to contribute to this app or report any issues by following the guidelines in the project's repository. License \u00b6 This app is open-source and is distributed under the [License Name]. Refer to the LICENSE file for details.","title":"Home And Dash"},{"location":"home.html#description","text":"The \"home\" app is an integral part of the Django project. It includes various components that are essential for the functionality of the project. This readme provides an overview of the key components within the \"home\" app.","title":"Description"},{"location":"home.html#components","text":"admin.py : This module contains configurations for Django's admin interface, allowing administrators to manage data associated with the \"home\" app. forms.py : The forms module includes form classes used for user input validation and data submission within the app. models.py : In this module, the database models are defined, which represent the data structures and relationships for the \"home\" app. views.py : The views module contains view functions that handle user requests, process data, and render templates.","title":"Components"},{"location":"home.html#-_helperpy_this_module_may_include_any_utility_functions_or_helpers_used_across_the_home_app_to_streamline_common_tasks_or_logic","text":"","title":"- helper.py: This module may include any utility functions or helpers used across the \"home\" app to streamline common tasks or logic."},{"location":"home.html#adminpy","text":"admin.py : This module contains configurations for Django's admin interface, allowing administrators to manage data associated with the \"home\" app. In this file, various models are registered with the Django admin site to provide an interface for administrators to manage data. The following models are registered: PriceUnit : Registered with the Django admin site to manage price units. WeightUnit : Registered with the Django admin site to manage weight units. TimeUnit : Registered with the Django admin site to manage time units. QuotationDocType : Registered with the Django admin site to manage quotation document types. Quotation : Registered with the Django admin site to manage quotations. These registrations enable administrators to create, edit, and delete records related to these models using the Django admin interface.","title":"admin.py"},{"location":"home.html#formspy","text":"This forms.py file defines custom form classes for various aspects of a web application. These form classes are designed to provide a more tailored and user-friendly experience for creating and editing user profiles, updating company logos, and managing questions. PasswordChangeForm The PasswordChangeForm is a custom form for changing a user's password. It enhances the default Django PasswordChangeForm by updating the widget attributes to improve user experience. Specifically, it sets the autocomplete values for old and new passwords and assigns CSS classes for styling. UserForm The UserForm is used for creating and editing user profiles. It is based on the Django ModelForm and is associated with the User model. The form fields are customized with placeholders, CSS classes, and ARIA labels to make the user interface more user-friendly. CompanyLogoForm The CompanyLogoForm is designed for updating company logos in user profiles. It is also based on the ModelForm and is associated with the Profile model. It customizes the widget for the company_logo field, providing a user-friendly way to update the company's logo. ProfileForm The ProfileForm is used for creating and editing user profiles. It is similar to the UserForm but focuses on fields related to a user's personal profile, such as about information, location, and establishment date. The form fields are customized with placeholders, CSS classes, and ARIA labels for improved user experience. QuestionForm The QuestionForm is employed for creating and editing questions. It is associated with the Question model and customizes the widget for the name field. It also provides a more user-friendly experience by adding placeholders, CSS classes, and ARIA labels to the form fields. OptionForm The OptionForm is used for creating and editing options. It is associated with the Option model and customizes the widget for the 'name' and 'statement' fields. These fields have placeholders, CSS classes, and ARIA labels for a better user interface. QuotationForm The QuotationForm is designed for creating and editing quotations. It is associated with the Quotation model and provides extensive customization for various fields. These customizations include input styling, CSS classes, and ARIA labels for fields like price, time, unit, document requirements, and more. Additionally, it handles file uploads for quotation formats. NextActivitiesOnQuotation The NextActivitiesOnQuotation form is intended for updating next activities on quotations. It is associated with the Quotation model and customizes the widget for the 'next_activities' field with styling and a select input. SuggestionForm The SuggestionForm allows the creation and editing of suggestions. It is associated with the Suggestions model and provides customization for fields like suggestion type, title, and statement. The form includes select inputs, text inputs, and text areas with appropriate attributes to enhance user interaction. QuesSugestionForm The QuesSugestionForm is a custom form for creating and editing question suggestions. It is associated with the Suggestions model and includes a special constructor ( __init__ ) that populates choices for the 'related_qs' field based on a custom function. The form also customizes the widget for 'su_type,' 'title,' 'statement,' and 'related_qs' fields. It provides select inputs, text inputs, and text areas, along with appropriate placeholders and attributes. This form enhances the user experience in creating and editing question suggestions. NextActivitiesForm The NextActivitiesForm is used for creating and editing next activities. It is associated with the NextActivities model and includes a constructor to handle the 'request' object. The form customizes the widget for various fields, including 'related_questions,' 'compulsory_questions,' 'name_and_standared,' 'priority,' and others. It provides input styling, placeholders, and attributes for an improved user experience. The form also includes a custom save method that checks for the existence of instances with the same selected IDs and, if found, takes specific actions such as updating user IDs and sending notifications to the admin. Developers can use these forms as part of the application's functionality for creating, editing, and managing options, quotations, and suggestions. Ensure that these forms are integrated into your Django project as needed and referenced in associated views and templates. For more information on using these forms and their integration into your Django project, please refer to the associated views and templates in your application.","title":"forms.py"},{"location":"home.html#helperpy","text":"The helper.py module contains a set of custom helper methods aimed at assisting with data calculation and retrieval. These methods offer valuable functionality for calculating the total number of reports, the total number of reports created by the current user, and counting the number of users under each label. total_reports(request) The total_reports method calculates the total number of reports in the database. It queries the Evaluator model and counts all instances. This count is useful for generating statistics and insights regarding the reports within your application. total_this_user_report(request) The total_this_user_report method calculates the total number of reports created by the current user. It filters the Evaluator model by the creator attribute, which is set to the current user, and counts the instances. This count helps users monitor and manage their own reports. users_under_each_label(request) The users_under_each_label method counts the number of users associated with each label. It retrieves a list of labels by calling get_all_definedlabel() and filters out labels marked as common. To optimize database queries, it prefetches related users for each label. The method constructs a dictionary where the keys represent label names, and the values indicate the count of users under each label. This information is valuable for analyzing user distribution based on labels. reports_under_each_biofuel(request) The reports_under_each_biofuel method counts the number of reports under each biofuel category. It retrieves the biofuel categories and calculates the count of reports associated with each category. The results are stored in a dictionary where the keys represent biofuel names, and the values represent the count of reports under each biofuel category. This information is valuable for understanding the distribution of reports based on biofuel types. weeks_results(request) The weeks_results method retrieves the number of reports generated in the last year and formats the results. It calculates the date one year ago from the current date, filters reports created in the last year, and aggregates the report counts by month/year. The results are formatted into a dictionary where keys are formatted date strings (month/year), and values represent the report counts. This information is useful for tracking report generation trends over time. all_reports(request) The all_reports method retrieves and filters reports based on user roles and calculates additional statistics. It checks the user's role, and if they are a staff member or superuser, all reports are shown. For regular users, only their reports are displayed. The method calculates the number of answered, positive, and \"don't know\" responses for each report, providing insights into response patterns. The results are paginated, with 10 reports per page, and additional statistics are included in each report's information. This method streamlines report management, making it easier to access and analyze data. typewise_user(request) The `typewise_user` method fetches all user types, each of which represents a specific classification or role for users in your application. To optimize database queries, it prefetches related users for each user type. The method returns a dictionary where the keys are user type objects, and the values are lists of associated users, limited to the first 4 users for each type. This limitation helps provide a concise overview of user types and their members. This method is beneficial for various purposes, including generating user statistics, understanding user role distributions, and facilitating user management. These helper methods simplify data processing and statistics generation within your application. Developers can leverage these methods in various scenarios, such as generating reports, user management, or label-based analytics. Integration into your views or other application components is essential to maximize the benefits of these methods. For detailed information on using these methods and their integration into your Django project, please refer to the associated views and templates in your application. These methods serve as essential components for data analysis and user management.","title":"helper.py"},{"location":"home.html#modelspy","text":"This section of models.py introduces several essential models designed to represent various attributes within the application, such as price units, time units, weight units, and quotation document types. These models serve as fundamental components for managing and categorizing data. Here's a detailed explanation: User Model The User model is dynamically defined based on the project's AUTH_USER_MODEL setting. It represents the user entities within your application. This model stores user-related information and is used for user authentication and management. The specific fields and attributes associated with the User model are determined by your project's settings. PriceUnit Model The PriceUnit model represents different price units used in the application, such as currency symbols (e.g., USD, EUR). Each instance of this model corresponds to a specific price unit. The name attribute stores the name of the price unit. This model simplifies the handling of price-related data. TimeUnit Model The TimeUnit model represents time units, such as minutes and hours. Each instance of this model corresponds to a specific time unit. The name attribute stores the name of the time unit. This model is valuable for dealing with time-related calculations and data presentation. WeightUnit Model The WeightUnit model represents various weight units, such as kilograms (kg) and pounds (lb). Each instance of this model corresponds to a specific weight unit. The name attribute stores the name of the weight unit. This model simplifies the handling of weight-related data. QuotationDocType Model The QuotationDocType model represents different document types that can be associated with quotations. Examples of document types include PDF and Word documents. Each instance of this model corresponds to a specific document type. The name attribute stores the name of the document type. This model categorizes and manages document types associated with quotations. Quotation Model The Quotation model represents a quotation for testing services. It stores essential information related to the quotation and is used to manage quotations provided by service providers. Below are the attributes and their descriptions associated with the Quotation model: service_provider (ForeignKey to User) Represents the user who provides the quotation. show_alternate_email (EmailField, optional) Represents an alternate email address for the quotation (optional). show_alternate_business (CharField, optional) Represents an alternate business name for the quotation (optional). show_alternate_phone (CharField, optional) Represents an alternate phone number for the quotation (optional). price (DecimalField) Stores the quotation's price. Users should provide the price for the service. price_unit (ForeignKey to PriceUnit) Represents the unit of the price. Users can choose from available pricing units. needy_time (IntegerField) Indicates the time needed for the test to be conducted. needy_time_unit (ForeignKey to TimeUnit) Represents the unit of time needed for the test. sample_amount (IntegerField) Stores the amount of sample needed for the test. sample_amount_unit (ForeignKey to WeightUnit) Represents the unit of weight for the sample amount. require_documents (ManyToManyField to QuotationDocType) Represents the documents needed for the test. Users can select multiple document types required for the service. factory_pickup (BooleanField) Indicates whether the sample will be collected from the factory. test_for (ForeignKey to Question) Represents the question for which the test is conducted. Users can select from available questions. related_questions (ManyToManyField to Question) Allows the selection of other questions that are tested within the provided quotation. Users can select multiple related questions. quotation_format (FileField) Allows the uploading of a quotation file, which must be in PDF format. next_activities (ForeignKey to NextActivities, optional) Represents next activities related to the quotation (optional). display_site_address (BooleanField) Indicates if the site address should be displayed. comments (TextField, optional) Provides an additional space for users to add comments related to the quotation (optional). Key Properties and Methods: - get_quot_url : Returns the URL to add a new quotation for the corresponding question. - get_business_name : Retrieves the business name for the quotation based on display settings. - get_phone : Retrieves the phone number for the quotation based on display settings. - get_email : Retrieves the email address for the quotation based on display settings. - get_absolute_url : Gets the absolute URL for the quotation report. The Quotation model is a fundamental component of your application for managing quotations for testing services, facilitating interactions between service providers and users seeking testing services. These models are vital for maintaining consistent and organized data storage within your application. Developers can create, update, and retrieve instances of these models as needed to manage and categorize various attributes and data types effectively. For detailed information on using these models, including creating and managing instances, refer to the relevant views, forms, and templates in your application. These models serve as the foundation for data representation and management.","title":"models.py"},{"location":"home.html#viewspy","text":"This document provides an overview of the views defined in the project's views.py file. Views are responsible for handling HTTP requests and returning appropriate HTTP responses. Below are the main views and their descriptions: home(request) View for the home page. Displays information on the home page. Caches user types and latest blog posts for efficient access. Meta data is set for page details. Available context data: user_types : Cached user types. latest_blogs : Cached latest blog posts. site_info : Meta data for the page. user_types(request, slug) View for displaying different user types and initiating the user signup journey. Sets the 'interested_in' session variable to the selected user type's slug. Ensures the user is logged in to initiate enrollment. Determines enrollment options based on user type and permissions. Retrieves user type data and related users. Meta data is set for page details. Available context data: user_type : Selected user type. users : Users associated with the selected user type. enroll : Enrollment options. site_info : Meta data for the page. dashboard(request) View for displaying the user dashboard. Requires the user to be logged in. Provides a summary of dashboard data, including weekly results, user labels, biofuel records, and more. Meta data is set for page details. Available context data: user_of_labels : User labels statistics. biofuel_records : Biofuel records statistics. day_of_week : Days of the week for weekly results. total_of_day : Total reports for each day of the week. total_reports : Total number of reports. allreports : Paginated list of reports and additional statistics. typewise_user : User types and associated users. site_info : Meta data for the page. questionsint(request) View for displaying questions related to the current marine user. Protected with @login_required and @marine_required decorators, ensuring that only logged-in marine users can access it. Provides specialized questions to get feedback from marine experts. Retrieves parent questions and related child questions. Paginates the results for display. Meta data is set for page details. Available context data: questions : Specialized questions for marine users. site_info : Meta data for the page. user_setting(request) View for managing user settings and profile. Allows logged-in users to update their general information, profile data, password, company logo, and notification settings. Handles different form submissions for various sections of user settings. Initializes form instances for different sections. Meta data is set for page details. Available context data: user : The logged-in user. user_form : Form for general user information. profile_form : Form for user profile data. password_form : Form for changing the password. company_logo_form : Form for updating the company logo. notification_form : Form for notification settings. site_info : Meta data for the page. delete_avatar(request) View for deleting the user's avatar. Deletes the user's company logo from the profile. Redirects to the user settings page after deletion. password_change(request) View for changing the user's password. Allows logged-in users to change their password by providing the current and new password. Handles form submissions for changing the password. Initializes the form instance for changing the password. Updates the session auth hash after password change. Meta data is set for page details. Available context data: user : The logged-in user. password_form : Form for changing the password. site_info : Meta data for the page. get_question_of_label(request) View to retrieve questions of a specific label. Checks if the user has the necessary permissions (staff, superuser, expert, marine) to access questions. If the user has the required permissions, it retrieves all questions. If the user lacks permissions, it redirects and displays a warning message. Available context data: questions : A list of questions (or a redirection if user lacks permissions). child_modal_data(request, id) View to retrieve data for a child question modal. Designed to fetch data for a child question modal. Checks if the user is logged in, returning a message if not. Ensures access is allowed to experts only, returning a message if the user lacks the necessary permissions. Retrieves the question data with related data prefetching. Renders a child question modal data template. Available context data: qquestion : Question data. quotations(request) View to display quotations related to questions. Allows logged-in experts (staff, superuser) to access quotations associated with questions. Retrieves questions and their related data, including quotations. Provides a paginated response for viewing. Meta data is set for page details. Available context data: questions : Paginated list of questions with related quotations. site_info : Meta data for the page. quotationsatg(request) View to display quotations at a glance. Allows logged-in experts (staff, superuser) to access quotations at a glance. Quotations can be accessed by staff, superusers, or the service provider (user) who created them. Retrieves quotations and provides a paginated response for viewing. Meta data is set for page details. Available context data: quotations : Paginated list of quotations. site_info : Meta data for the page. add_quatation(request, slug) View to add or edit a quotation for a specific question. Available to logged-in experts (staff, superuser). Checks if the user is logged in, has the necessary permissions, and allows adding or editing quotations. Manages form submissions for adding/editing quotations. Saves the quotations, related questions, and next activities. Checks and validates data related to quotations. Deletes the session of next activities after saving the quotation. Ensures that a question exists for adding/editing quotations. Meta data is set for page details. Available context data: question : The specific question for which the quotation is added or edited. form : Form for adding/editing quotations. na_form : Form for selecting next activities. quatation : The quotation being added/edited. report_link : Link to view the quotation report. site_info : Meta data for the page. get_verbose_name(instance, field_name) Helper function to get the verbose_name for a field in a model instance. Takes the model instance and the field name as arguments. Returns the verbose_name of the specified field title-cased. quotation_report2(request, quotation_data) Sub-function to generate a PDF report based on quotation data. Generates a PDF report for a given quotation data. Creates a PDF document using the ReportLab library and includes quotation details, related questions, and additional information. Returns the generated PDF as a BytesIO buffer. quotation_report(request, question, quotation) View to return a final report with an attachment as a PDF. Generates a final report in PDF format by merging the contents of a quotation report and an attachment (if available) into a single PDF document. Uses the PyPDF2 library to merge the two PDFs. Returns the generated PDF report as an HTTP response. Available context data: question : The question associated with the quotation. quotation : The ID of the quotation for which the report is generated. questions_details(request, slug) View to display and edit the details of a specific question. Marine experts can view and edit the question text, associated options, and other attributes. The view uses a combined form that includes the main question and its associated options. Available context data: slug : The slug of the question to be displayed and edited. question : The specific question to be edited. Returns an HTTP response containing the question details and an editable form. new_questions(request) View to add a new question and associated options. Marine experts can add a new question along with its associated options. The view provides a form for inputting the question text and options for the new question. Available context data: No specific context data other than site metadata. Returns an HTTP response containing the form for adding a new question and options. allreports(request) View to display a list of evaluation reports for biofuels. Admin users can see all reports, while biofuel producers can only see their own reports. The view provides a list of evaluation reports for biofuels. Available context data: No specific context data other than site metadata. Returns an HTTP response containing the list of evaluation reports. check_type_to_get_expert(request) View to check the user type selected during registration and set session variables accordingly. Used during the registration process to determine the user type selected by the user and set session variables based on that selection. Retrieves the user type from the request's POST data and sets the 'interested_in' session variable to the user type's slug. Sets the 'hidden' session variable to 'hidden' if the user type is not an expert, indicating that certain form fields should be hidden in the registration form. Returns a redirection to the registration page. add_extra(request, pk) View to add an extra form field. Increments the 'extra' session variable to control front-end behavior. Returns a redirection to the question details page. sub_extra(request, pk) View to subtract an extra form field. Decrements the 'extra' session variable if it's greater than or equal to 1 to control front-end behavior. Returns a redirection to the question details page. webmanifest(request) View to generate a web app manifest. Creates a web app manifest containing data such as the app's name, icons, and other configuration options. Returns a JSON response containing the web app manifest data. AddSugestion(View) Class-based view for adding or editing suggestions related to a question. Handles both GET and POST requests for displaying the form and processing form submissions. Attributes: get_temp (str): Template file for rendering the form. form_class (class): Form class used for suggestion input. Methods: get(self, request, *args, **kwargs) : Handles GET requests to display the suggestion form. post(self, request, *args, **kwargs) : Handles POST requests to process form submissions. get_edit_sugestion(request, slug, pk) View to edit an existing suggestion related to a question. Allows marine users to edit an existing suggestion for a specific question based on its primary key (pk). get_sugestion_list(request, slug) View to display a list of suggestions related to a specific question. Retrieves and displays a list of suggestions related to a specific question, identified by its slug. delete_sugestion(request, pk) View to delete a suggestion. Allows authenticated users, typically marine experts, to delete a specific suggestion based on its primary key (pk). Users must have the necessary permissions to delete the suggestion. Only the creator of the suggestion, admin users, and superusers can delete it. sugest_new_ques_option(request) View to suggest new questions and options for evaluation. Allows marine experts to submit suggestions for new questions and corresponding options. The submitted suggestions are reviewed and, if approved, added to the evaluation pool. Displays previously suggested questions by the same expert. get_edit_new_sugestion(request, pk) View to edit a new suggestion. Allows marine experts to edit a previously suggested question or option. Experts can update the statement, title, related questions, and suggestion type. Changes are saved if the expert is the creator of the suggestion or has staff/superuser privileges. get_new_sugestion_list(request) View to display a list of new suggestions created by the marine expert. Retrieves and displays a list of new suggestions created by the marine expert. These suggestions have not been associated with a specific question or option yet. add_new_service(request, user_id) View to allow an expert to add a new service or select an existing service for a visiting user. Allows an expert user to add a new service or select an existing service for a visiting user. The expert can provide details about the service and associate it with related and compulsory questions. If an existing service is found for the selected questions, the expert is prompted to select that service. These views empower expert users to provide services and options to visiting users and facilitate the management of services associated with specific questions. Please note that these views are part of the project's features for user interaction and service management. Additional views and features may be defined elsewhere in the project based on specific requirements. These views serve as the core components of the project, handling various functionalities and interactions with users on the website. Please note that the mentioned views are not the entire list of views in the project. Additional views may be defined elsewhere in the project based on specific requirements.","title":"views.py"},{"location":"home.html#contributing","text":"Feel free to contribute to this app or report any issues by following the guidelines in the project's repository.","title":"Contributing"},{"location":"home.html#license","text":"This app is open-source and is distributed under the [License Name]. Refer to the LICENSE file for details.","title":"License"},{"location":"navigation.html","text":"Navigation App \u00b6 The Navigation App is a lightweight Django app designed to generate navigation menus and provide menu items for various parts of your website based on user roles and permissions. Purpose \u00b6 This app simplifies the process of generating dynamic navigation menus in your Django web application. It provides functions to create lists of menu items for different parts of your website, making it easy to manage what users see in their navigation menu. Key Features \u00b6 Dynamic menu generation based on user roles and permissions. Provides functions for generating dashboard, header, and account-related menus. Flexible and easy-to-use menu items structure. Helps maintain a clean and organized navigation structure. Usage \u00b6 Installation : Install the Navigation app by including it in your Django project. You can do this by adding 'navigation' to your INSTALLED_APPS in your Django project's settings. Integration : You can integrate the Navigation app by using the provided functions to generate menu items. The app supports dynamic menu generation based on user roles, making it simple to customize the menus for different user groups. Function Usage : To use the app's functions, import them into your views or templates. The provided functions allow you to generate menus for your dashboard, header, and account-related sections. Customization : You can customize the menu items' appearance and behavior as needed for your specific web application. You can modify the menu structure, add or remove menu items, and apply your own styles. Example Usage \u00b6 Here's a quick example of how to use the Navigation app in your Django project: ```python views.py \u00b6 from navigation.menu import dashboard_menu def dashboard(request): # Generate the dashboard menu items menu_items = dashboard_menu(request) # ... your view logic ... template.html \u00b6 {% load navigation_tags %} {% for item in menu_items %} {{ item.title }} {% endfor %} Support and Contributions \u00b6 If you encounter any issues, have suggestions, or want to contribute to the Navigation app, please visit the GitHub repository and submit your feedback or pull requests.","title":"Navigation"},{"location":"navigation.html#navigation_app","text":"The Navigation App is a lightweight Django app designed to generate navigation menus and provide menu items for various parts of your website based on user roles and permissions.","title":"Navigation App"},{"location":"navigation.html#purpose","text":"This app simplifies the process of generating dynamic navigation menus in your Django web application. It provides functions to create lists of menu items for different parts of your website, making it easy to manage what users see in their navigation menu.","title":"Purpose"},{"location":"navigation.html#key_features","text":"Dynamic menu generation based on user roles and permissions. Provides functions for generating dashboard, header, and account-related menus. Flexible and easy-to-use menu items structure. Helps maintain a clean and organized navigation structure.","title":"Key Features"},{"location":"navigation.html#usage","text":"Installation : Install the Navigation app by including it in your Django project. You can do this by adding 'navigation' to your INSTALLED_APPS in your Django project's settings. Integration : You can integrate the Navigation app by using the provided functions to generate menu items. The app supports dynamic menu generation based on user roles, making it simple to customize the menus for different user groups. Function Usage : To use the app's functions, import them into your views or templates. The provided functions allow you to generate menus for your dashboard, header, and account-related sections. Customization : You can customize the menu items' appearance and behavior as needed for your specific web application. You can modify the menu structure, add or remove menu items, and apply your own styles.","title":"Usage"},{"location":"navigation.html#example_usage","text":"Here's a quick example of how to use the Navigation app in your Django project: ```python","title":"Example Usage"},{"location":"navigation.html#viewspy","text":"from navigation.menu import dashboard_menu def dashboard(request): # Generate the dashboard menu items menu_items = dashboard_menu(request) # ... your view logic ...","title":"views.py"},{"location":"navigation.html#templatehtml","text":"{% load navigation_tags %} {% for item in menu_items %} {{ item.title }} {% endfor %}","title":"template.html"},{"location":"navigation.html#support_and_contributions","text":"If you encounter any issues, have suggestions, or want to contribute to the Navigation app, please visit the GitHub repository and submit your feedback or pull requests.","title":"Support and Contributions"}]}